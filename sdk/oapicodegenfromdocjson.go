// Copyright 2023 Specter Ops, Inc.
//
// Licensed under the Apache License, Version 2.0
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

//Package oapicodegenfromsdocjson provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package oapiclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	"gopkg.in/yaml.v2"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"
)

const (
	HMACSignatureScopes  = "HMACSignature.Scopes"
	JWTBearerTokenScopes = "JWTBearerToken.Scopes"
	RequestDateScopes    = "RequestDate.Scopes"
	SignedRequestScopes  = "SignedRequest.Scopes"
)

// Defines values for EnumAuditLogStatus.
const (
	Failure EnumAuditLogStatus = "failure"
	Intent  EnumAuditLogStatus = "intent"
	Success EnumAuditLogStatus = "success"
)

// Defines values for EnumClientType.
const (
	Azurehound EnumClientType = "azurehound"
	Sharphound EnumClientType = "sharphound"
)

// Defines values for EnumDatapipeStatus.
const (
	Analyzing EnumDatapipeStatus = "analyzing"
	Idle      EnumDatapipeStatus = "idle"
	Ingesting EnumDatapipeStatus = "ingesting"
)

// Defines values for EnumJobStatus.
const (
	Minus1 EnumJobStatus = -1
	N0     EnumJobStatus = 0
	N1     EnumJobStatus = 1
	N2     EnumJobStatus = 2
	N3     EnumJobStatus = 3
	N4     EnumJobStatus = 4
	N5     EnumJobStatus = 5
	N6     EnumJobStatus = 6
	N7     EnumJobStatus = 7
	N8     EnumJobStatus = 8
)

// Defines values for EnumMfaActivationStatus.
const (
	Activated   EnumMfaActivationStatus = "activated"
	Deactivated EnumMfaActivationStatus = "deactivated"
	Pending     EnumMfaActivationStatus = "pending"
)

// Defines values for EnumRiskAcceptance.
const (
	Accepted   EnumRiskAcceptance = "accepted"
	All        EnumRiskAcceptance = "all"
	Empty      EnumRiskAcceptance = ""
	Unaccepted EnumRiskAcceptance = "unaccepted"
)

// Defines values for ModelAssetGroupSelectorSpecAction.
const (
	Add    ModelAssetGroupSelectorSpecAction = "add"
	Remove ModelAssetGroupSelectorSpecAction = "remove"
)

// Defines values for QueryEntityType.
const (
	QueryEntityTypeCount QueryEntityType = "count"
	QueryEntityTypeGraph QueryEntityType = "graph"
	QueryEntityTypeList  QueryEntityType = "list"
)

// Defines values for GetAiaCaEntityControllersParamsType.
const (
	GetAiaCaEntityControllersParamsTypeCount GetAiaCaEntityControllersParamsType = "count"
	GetAiaCaEntityControllersParamsTypeGraph GetAiaCaEntityControllersParamsType = "graph"
	GetAiaCaEntityControllersParamsTypeList  GetAiaCaEntityControllersParamsType = "list"
)

// Defines values for GetAzureEntityParamsType.
const (
	GetAzureEntityParamsTypeGraph GetAzureEntityParamsType = "graph"
	GetAzureEntityParamsTypeList  GetAzureEntityParamsType = "list"
)

// Defines values for GetEntityControllablesParamsType.
const (
	GetEntityControllablesParamsTypeCount GetEntityControllablesParamsType = "count"
	GetEntityControllablesParamsTypeGraph GetEntityControllablesParamsType = "graph"
	GetEntityControllablesParamsTypeList  GetEntityControllablesParamsType = "list"
)

// Defines values for GetEntityControllersParamsType.
const (
	GetEntityControllersParamsTypeCount GetEntityControllersParamsType = "count"
	GetEntityControllersParamsTypeGraph GetEntityControllersParamsType = "graph"
	GetEntityControllersParamsTypeList  GetEntityControllersParamsType = "list"
)

// Defines values for GetCertTemplateEntityControllersParamsType.
const (
	GetCertTemplateEntityControllersParamsTypeCount GetCertTemplateEntityControllersParamsType = "count"
	GetCertTemplateEntityControllersParamsTypeGraph GetCertTemplateEntityControllersParamsType = "graph"
	GetCertTemplateEntityControllersParamsTypeList  GetCertTemplateEntityControllersParamsType = "list"
)

// Defines values for GetComputerEntityAdminRightsParamsType.
const (
	GetComputerEntityAdminRightsParamsTypeCount GetComputerEntityAdminRightsParamsType = "count"
	GetComputerEntityAdminRightsParamsTypeGraph GetComputerEntityAdminRightsParamsType = "graph"
	GetComputerEntityAdminRightsParamsTypeList  GetComputerEntityAdminRightsParamsType = "list"
)

// Defines values for GetComputerEntityAdminsParamsType.
const (
	GetComputerEntityAdminsParamsTypeCount GetComputerEntityAdminsParamsType = "count"
	GetComputerEntityAdminsParamsTypeGraph GetComputerEntityAdminsParamsType = "graph"
	GetComputerEntityAdminsParamsTypeList  GetComputerEntityAdminsParamsType = "list"
)

// Defines values for GetComputerEntityConstrainedDelegationRightsParamsType.
const (
	GetComputerEntityConstrainedDelegationRightsParamsTypeCount GetComputerEntityConstrainedDelegationRightsParamsType = "count"
	GetComputerEntityConstrainedDelegationRightsParamsTypeGraph GetComputerEntityConstrainedDelegationRightsParamsType = "graph"
	GetComputerEntityConstrainedDelegationRightsParamsTypeList  GetComputerEntityConstrainedDelegationRightsParamsType = "list"
)

// Defines values for GetComputerEntityConstrainedUsersParamsType.
const (
	GetComputerEntityConstrainedUsersParamsTypeCount GetComputerEntityConstrainedUsersParamsType = "count"
	GetComputerEntityConstrainedUsersParamsTypeGraph GetComputerEntityConstrainedUsersParamsType = "graph"
	GetComputerEntityConstrainedUsersParamsTypeList  GetComputerEntityConstrainedUsersParamsType = "list"
)

// Defines values for GetComputerEntityControllablesParamsType.
const (
	GetComputerEntityControllablesParamsTypeCount GetComputerEntityControllablesParamsType = "count"
	GetComputerEntityControllablesParamsTypeGraph GetComputerEntityControllablesParamsType = "graph"
	GetComputerEntityControllablesParamsTypeList  GetComputerEntityControllablesParamsType = "list"
)

// Defines values for GetComputerEntityControllersParamsType.
const (
	GetComputerEntityControllersParamsTypeCount GetComputerEntityControllersParamsType = "count"
	GetComputerEntityControllersParamsTypeGraph GetComputerEntityControllersParamsType = "graph"
	GetComputerEntityControllersParamsTypeList  GetComputerEntityControllersParamsType = "list"
)

// Defines values for GetComputerEntityDcomRightsParamsType.
const (
	GetComputerEntityDcomRightsParamsTypeCount GetComputerEntityDcomRightsParamsType = "count"
	GetComputerEntityDcomRightsParamsTypeGraph GetComputerEntityDcomRightsParamsType = "graph"
	GetComputerEntityDcomRightsParamsTypeList  GetComputerEntityDcomRightsParamsType = "list"
)

// Defines values for GetComputerEntityDcomUsersParamsType.
const (
	GetComputerEntityDcomUsersParamsTypeCount GetComputerEntityDcomUsersParamsType = "count"
	GetComputerEntityDcomUsersParamsTypeGraph GetComputerEntityDcomUsersParamsType = "graph"
	GetComputerEntityDcomUsersParamsTypeList  GetComputerEntityDcomUsersParamsType = "list"
)

// Defines values for GetComputerEntityGroupMembershipParamsType.
const (
	GetComputerEntityGroupMembershipParamsTypeCount GetComputerEntityGroupMembershipParamsType = "count"
	GetComputerEntityGroupMembershipParamsTypeGraph GetComputerEntityGroupMembershipParamsType = "graph"
	GetComputerEntityGroupMembershipParamsTypeList  GetComputerEntityGroupMembershipParamsType = "list"
)

// Defines values for GetComputerEntityPsRemoteRightsParamsType.
const (
	GetComputerEntityPsRemoteRightsParamsTypeCount GetComputerEntityPsRemoteRightsParamsType = "count"
	GetComputerEntityPsRemoteRightsParamsTypeGraph GetComputerEntityPsRemoteRightsParamsType = "graph"
	GetComputerEntityPsRemoteRightsParamsTypeList  GetComputerEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetComputerEntityPsRemoteUsersParamsType.
const (
	GetComputerEntityPsRemoteUsersParamsTypeCount GetComputerEntityPsRemoteUsersParamsType = "count"
	GetComputerEntityPsRemoteUsersParamsTypeGraph GetComputerEntityPsRemoteUsersParamsType = "graph"
	GetComputerEntityPsRemoteUsersParamsTypeList  GetComputerEntityPsRemoteUsersParamsType = "list"
)

// Defines values for GetComputerEntityRdpRightsParamsType.
const (
	GetComputerEntityRdpRightsParamsTypeCount GetComputerEntityRdpRightsParamsType = "count"
	GetComputerEntityRdpRightsParamsTypeGraph GetComputerEntityRdpRightsParamsType = "graph"
	GetComputerEntityRdpRightsParamsTypeList  GetComputerEntityRdpRightsParamsType = "list"
)

// Defines values for GetComputerEntityRdpUsersParamsType.
const (
	GetComputerEntityRdpUsersParamsTypeCount GetComputerEntityRdpUsersParamsType = "count"
	GetComputerEntityRdpUsersParamsTypeGraph GetComputerEntityRdpUsersParamsType = "graph"
	GetComputerEntityRdpUsersParamsTypeList  GetComputerEntityRdpUsersParamsType = "list"
)

// Defines values for GetComputerEntitySessionsParamsType.
const (
	GetComputerEntitySessionsParamsTypeCount GetComputerEntitySessionsParamsType = "count"
	GetComputerEntitySessionsParamsTypeGraph GetComputerEntitySessionsParamsType = "graph"
	GetComputerEntitySessionsParamsTypeList  GetComputerEntitySessionsParamsType = "list"
)

// Defines values for GetComputerEntitySqlAdminsParamsType.
const (
	GetComputerEntitySqlAdminsParamsTypeCount GetComputerEntitySqlAdminsParamsType = "count"
	GetComputerEntitySqlAdminsParamsTypeGraph GetComputerEntitySqlAdminsParamsType = "graph"
	GetComputerEntitySqlAdminsParamsTypeList  GetComputerEntitySqlAdminsParamsType = "list"
)

// Defines values for GetContainerEntityControllersParamsType.
const (
	GetContainerEntityControllersParamsTypeCount GetContainerEntityControllersParamsType = "count"
	GetContainerEntityControllersParamsTypeGraph GetContainerEntityControllersParamsType = "graph"
	GetContainerEntityControllersParamsTypeList  GetContainerEntityControllersParamsType = "list"
)

// Defines values for GetDomainEntityComputersParamsType.
const (
	GetDomainEntityComputersParamsTypeCount GetDomainEntityComputersParamsType = "count"
	GetDomainEntityComputersParamsTypeGraph GetDomainEntityComputersParamsType = "graph"
	GetDomainEntityComputersParamsTypeList  GetDomainEntityComputersParamsType = "list"
)

// Defines values for GetDomainEntityControllersParamsType.
const (
	GetDomainEntityControllersParamsTypeCount GetDomainEntityControllersParamsType = "count"
	GetDomainEntityControllersParamsTypeGraph GetDomainEntityControllersParamsType = "graph"
	GetDomainEntityControllersParamsTypeList  GetDomainEntityControllersParamsType = "list"
)

// Defines values for GetDomainEntityDcSyncersParamsType.
const (
	GetDomainEntityDcSyncersParamsTypeCount GetDomainEntityDcSyncersParamsType = "count"
	GetDomainEntityDcSyncersParamsTypeGraph GetDomainEntityDcSyncersParamsType = "graph"
	GetDomainEntityDcSyncersParamsTypeList  GetDomainEntityDcSyncersParamsType = "list"
)

// Defines values for GetDomainEntityForeignAdminsParamsType.
const (
	GetDomainEntityForeignAdminsParamsTypeCount GetDomainEntityForeignAdminsParamsType = "count"
	GetDomainEntityForeignAdminsParamsTypeGraph GetDomainEntityForeignAdminsParamsType = "graph"
	GetDomainEntityForeignAdminsParamsTypeList  GetDomainEntityForeignAdminsParamsType = "list"
)

// Defines values for GetDomainEntityForeignGpoControllersParamsType.
const (
	GetDomainEntityForeignGpoControllersParamsTypeCount GetDomainEntityForeignGpoControllersParamsType = "count"
	GetDomainEntityForeignGpoControllersParamsTypeGraph GetDomainEntityForeignGpoControllersParamsType = "graph"
	GetDomainEntityForeignGpoControllersParamsTypeList  GetDomainEntityForeignGpoControllersParamsType = "list"
)

// Defines values for GetDomainEntityForeignGroupsParamsType.
const (
	GetDomainEntityForeignGroupsParamsTypeCount GetDomainEntityForeignGroupsParamsType = "count"
	GetDomainEntityForeignGroupsParamsTypeGraph GetDomainEntityForeignGroupsParamsType = "graph"
	GetDomainEntityForeignGroupsParamsTypeList  GetDomainEntityForeignGroupsParamsType = "list"
)

// Defines values for GetDomainEntityForeignUsersParamsType.
const (
	GetDomainEntityForeignUsersParamsTypeCount GetDomainEntityForeignUsersParamsType = "count"
	GetDomainEntityForeignUsersParamsTypeGraph GetDomainEntityForeignUsersParamsType = "graph"
	GetDomainEntityForeignUsersParamsTypeList  GetDomainEntityForeignUsersParamsType = "list"
)

// Defines values for GetDomainEntityGposParamsType.
const (
	GetDomainEntityGposParamsTypeCount GetDomainEntityGposParamsType = "count"
	GetDomainEntityGposParamsTypeGraph GetDomainEntityGposParamsType = "graph"
	GetDomainEntityGposParamsTypeList  GetDomainEntityGposParamsType = "list"
)

// Defines values for GetDomainEntityGroupsParamsType.
const (
	GetDomainEntityGroupsParamsTypeCount GetDomainEntityGroupsParamsType = "count"
	GetDomainEntityGroupsParamsTypeGraph GetDomainEntityGroupsParamsType = "graph"
	GetDomainEntityGroupsParamsTypeList  GetDomainEntityGroupsParamsType = "list"
)

// Defines values for GetDomainEntityInboundTrustsParamsType.
const (
	GetDomainEntityInboundTrustsParamsTypeCount GetDomainEntityInboundTrustsParamsType = "count"
	GetDomainEntityInboundTrustsParamsTypeGraph GetDomainEntityInboundTrustsParamsType = "graph"
	GetDomainEntityInboundTrustsParamsTypeList  GetDomainEntityInboundTrustsParamsType = "list"
)

// Defines values for GetDomainEntityLinkedGposParamsType.
const (
	GetDomainEntityLinkedGposParamsTypeCount GetDomainEntityLinkedGposParamsType = "count"
	GetDomainEntityLinkedGposParamsTypeGraph GetDomainEntityLinkedGposParamsType = "graph"
	GetDomainEntityLinkedGposParamsTypeList  GetDomainEntityLinkedGposParamsType = "list"
)

// Defines values for GetDomainEntityOusParamsType.
const (
	GetDomainEntityOusParamsTypeCount GetDomainEntityOusParamsType = "count"
	GetDomainEntityOusParamsTypeGraph GetDomainEntityOusParamsType = "graph"
	GetDomainEntityOusParamsTypeList  GetDomainEntityOusParamsType = "list"
)

// Defines values for GetDomainEntityOutboundTrustsParamsType.
const (
	GetDomainEntityOutboundTrustsParamsTypeCount GetDomainEntityOutboundTrustsParamsType = "count"
	GetDomainEntityOutboundTrustsParamsTypeGraph GetDomainEntityOutboundTrustsParamsType = "graph"
	GetDomainEntityOutboundTrustsParamsTypeList  GetDomainEntityOutboundTrustsParamsType = "list"
)

// Defines values for GetDomainEntityUsersParamsType.
const (
	GetDomainEntityUsersParamsTypeCount GetDomainEntityUsersParamsType = "count"
	GetDomainEntityUsersParamsTypeGraph GetDomainEntityUsersParamsType = "graph"
	GetDomainEntityUsersParamsTypeList  GetDomainEntityUsersParamsType = "list"
)

// Defines values for GetEnterpriseCaEntityControllersParamsType.
const (
	GetEnterpriseCaEntityControllersParamsTypeCount GetEnterpriseCaEntityControllersParamsType = "count"
	GetEnterpriseCaEntityControllersParamsTypeGraph GetEnterpriseCaEntityControllersParamsType = "graph"
	GetEnterpriseCaEntityControllersParamsTypeList  GetEnterpriseCaEntityControllersParamsType = "list"
)

// Defines values for GetGpoEntityComputersParamsType.
const (
	GetGpoEntityComputersParamsTypeCount GetGpoEntityComputersParamsType = "count"
	GetGpoEntityComputersParamsTypeGraph GetGpoEntityComputersParamsType = "graph"
	GetGpoEntityComputersParamsTypeList  GetGpoEntityComputersParamsType = "list"
)

// Defines values for GetGpoEntityControllersParamsType.
const (
	GetGpoEntityControllersParamsTypeCount GetGpoEntityControllersParamsType = "count"
	GetGpoEntityControllersParamsTypeGraph GetGpoEntityControllersParamsType = "graph"
	GetGpoEntityControllersParamsTypeList  GetGpoEntityControllersParamsType = "list"
)

// Defines values for GetGpoEntityOusParamsType.
const (
	GetGpoEntityOusParamsTypeCount GetGpoEntityOusParamsType = "count"
	GetGpoEntityOusParamsTypeGraph GetGpoEntityOusParamsType = "graph"
	GetGpoEntityOusParamsTypeList  GetGpoEntityOusParamsType = "list"
)

// Defines values for GetGpoEntityTierZeroParamsType.
const (
	GetGpoEntityTierZeroParamsTypeCount GetGpoEntityTierZeroParamsType = "count"
	GetGpoEntityTierZeroParamsTypeGraph GetGpoEntityTierZeroParamsType = "graph"
	GetGpoEntityTierZeroParamsTypeList  GetGpoEntityTierZeroParamsType = "list"
)

// Defines values for GetGpoEntityUsersParamsType.
const (
	GetGpoEntityUsersParamsTypeCount GetGpoEntityUsersParamsType = "count"
	GetGpoEntityUsersParamsTypeGraph GetGpoEntityUsersParamsType = "graph"
	GetGpoEntityUsersParamsTypeList  GetGpoEntityUsersParamsType = "list"
)

// Defines values for GetSearchResultParamsType.
const (
	Exact GetSearchResultParamsType = "exact"
	Fuzzy GetSearchResultParamsType = "fuzzy"
)

// Defines values for GetGroupEntityAdminRightsParamsType.
const (
	GetGroupEntityAdminRightsParamsTypeCount GetGroupEntityAdminRightsParamsType = "count"
	GetGroupEntityAdminRightsParamsTypeGraph GetGroupEntityAdminRightsParamsType = "graph"
	GetGroupEntityAdminRightsParamsTypeList  GetGroupEntityAdminRightsParamsType = "list"
)

// Defines values for GetGroupEntityControllablesParamsType.
const (
	GetGroupEntityControllablesParamsTypeCount GetGroupEntityControllablesParamsType = "count"
	GetGroupEntityControllablesParamsTypeGraph GetGroupEntityControllablesParamsType = "graph"
	GetGroupEntityControllablesParamsTypeList  GetGroupEntityControllablesParamsType = "list"
)

// Defines values for GetGroupEntityControllersParamsType.
const (
	GetGroupEntityControllersParamsTypeCount GetGroupEntityControllersParamsType = "count"
	GetGroupEntityControllersParamsTypeGraph GetGroupEntityControllersParamsType = "graph"
	GetGroupEntityControllersParamsTypeList  GetGroupEntityControllersParamsType = "list"
)

// Defines values for GetGroupEntityDcomRightsParamsType.
const (
	GetGroupEntityDcomRightsParamsTypeCount GetGroupEntityDcomRightsParamsType = "count"
	GetGroupEntityDcomRightsParamsTypeGraph GetGroupEntityDcomRightsParamsType = "graph"
	GetGroupEntityDcomRightsParamsTypeList  GetGroupEntityDcomRightsParamsType = "list"
)

// Defines values for GetGroupEntityMembersParamsType.
const (
	GetGroupEntityMembersParamsTypeCount GetGroupEntityMembersParamsType = "count"
	GetGroupEntityMembersParamsTypeGraph GetGroupEntityMembersParamsType = "graph"
	GetGroupEntityMembersParamsTypeList  GetGroupEntityMembersParamsType = "list"
)

// Defines values for GetGroupEntityMembershipsParamsType.
const (
	GetGroupEntityMembershipsParamsTypeCount GetGroupEntityMembershipsParamsType = "count"
	GetGroupEntityMembershipsParamsTypeGraph GetGroupEntityMembershipsParamsType = "graph"
	GetGroupEntityMembershipsParamsTypeList  GetGroupEntityMembershipsParamsType = "list"
)

// Defines values for GetGroupEntityPsRemoteRightsParamsType.
const (
	GetGroupEntityPsRemoteRightsParamsTypeCount GetGroupEntityPsRemoteRightsParamsType = "count"
	GetGroupEntityPsRemoteRightsParamsTypeGraph GetGroupEntityPsRemoteRightsParamsType = "graph"
	GetGroupEntityPsRemoteRightsParamsTypeList  GetGroupEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetGroupEntityRdpRightsParamsType.
const (
	GetGroupEntityRdpRightsParamsTypeCount GetGroupEntityRdpRightsParamsType = "count"
	GetGroupEntityRdpRightsParamsTypeGraph GetGroupEntityRdpRightsParamsType = "graph"
	GetGroupEntityRdpRightsParamsTypeList  GetGroupEntityRdpRightsParamsType = "list"
)

// Defines values for GetGroupEntitySessionsParamsType.
const (
	GetGroupEntitySessionsParamsTypeCount GetGroupEntitySessionsParamsType = "count"
	GetGroupEntitySessionsParamsTypeGraph GetGroupEntitySessionsParamsType = "graph"
	GetGroupEntitySessionsParamsTypeList  GetGroupEntitySessionsParamsType = "list"
)

// Defines values for LoginJSONBodyLoginMethod.
const (
	Secret LoginJSONBodyLoginMethod = "secret"
)

// Defines values for GetNtAuthStoreEntityControllersParamsType.
const (
	GetNtAuthStoreEntityControllersParamsTypeCount GetNtAuthStoreEntityControllersParamsType = "count"
	GetNtAuthStoreEntityControllersParamsTypeGraph GetNtAuthStoreEntityControllersParamsType = "graph"
	GetNtAuthStoreEntityControllersParamsTypeList  GetNtAuthStoreEntityControllersParamsType = "list"
)

// Defines values for GetOuEntityComputersParamsType.
const (
	GetOuEntityComputersParamsTypeCount GetOuEntityComputersParamsType = "count"
	GetOuEntityComputersParamsTypeGraph GetOuEntityComputersParamsType = "graph"
	GetOuEntityComputersParamsTypeList  GetOuEntityComputersParamsType = "list"
)

// Defines values for GetOuEntityGposParamsType.
const (
	GetOuEntityGposParamsTypeCount GetOuEntityGposParamsType = "count"
	GetOuEntityGposParamsTypeGraph GetOuEntityGposParamsType = "graph"
	GetOuEntityGposParamsTypeList  GetOuEntityGposParamsType = "list"
)

// Defines values for GetOuEntityGroupsParamsType.
const (
	GetOuEntityGroupsParamsTypeCount GetOuEntityGroupsParamsType = "count"
	GetOuEntityGroupsParamsTypeGraph GetOuEntityGroupsParamsType = "graph"
	GetOuEntityGroupsParamsTypeList  GetOuEntityGroupsParamsType = "list"
)

// Defines values for GetOuEntityUsersParamsType.
const (
	GetOuEntityUsersParamsTypeCount GetOuEntityUsersParamsType = "count"
	GetOuEntityUsersParamsTypeGraph GetOuEntityUsersParamsType = "graph"
	GetOuEntityUsersParamsTypeList  GetOuEntityUsersParamsType = "list"
)

// Defines values for GetRootCaEntityControllersParamsType.
const (
	GetRootCaEntityControllersParamsTypeCount GetRootCaEntityControllersParamsType = "count"
	GetRootCaEntityControllersParamsTypeGraph GetRootCaEntityControllersParamsType = "graph"
	GetRootCaEntityControllersParamsTypeList  GetRootCaEntityControllersParamsType = "list"
)

// Defines values for GetUserEntityAdminRightsParamsType.
const (
	GetUserEntityAdminRightsParamsTypeCount GetUserEntityAdminRightsParamsType = "count"
	GetUserEntityAdminRightsParamsTypeGraph GetUserEntityAdminRightsParamsType = "graph"
	GetUserEntityAdminRightsParamsTypeList  GetUserEntityAdminRightsParamsType = "list"
)

// Defines values for GetUserEntityConstrainedDelegationRightsParamsType.
const (
	GetUserEntityConstrainedDelegationRightsParamsTypeCount GetUserEntityConstrainedDelegationRightsParamsType = "count"
	GetUserEntityConstrainedDelegationRightsParamsTypeGraph GetUserEntityConstrainedDelegationRightsParamsType = "graph"
	GetUserEntityConstrainedDelegationRightsParamsTypeList  GetUserEntityConstrainedDelegationRightsParamsType = "list"
)

// Defines values for GetUserEntityControllablesParamsType.
const (
	GetUserEntityControllablesParamsTypeCount GetUserEntityControllablesParamsType = "count"
	GetUserEntityControllablesParamsTypeGraph GetUserEntityControllablesParamsType = "graph"
	GetUserEntityControllablesParamsTypeList  GetUserEntityControllablesParamsType = "list"
)

// Defines values for GetUserEntityControllersParamsType.
const (
	GetUserEntityControllersParamsTypeCount GetUserEntityControllersParamsType = "count"
	GetUserEntityControllersParamsTypeGraph GetUserEntityControllersParamsType = "graph"
	GetUserEntityControllersParamsTypeList  GetUserEntityControllersParamsType = "list"
)

// Defines values for GetUserEntityDcomRightsParamsType.
const (
	GetUserEntityDcomRightsParamsTypeCount GetUserEntityDcomRightsParamsType = "count"
	GetUserEntityDcomRightsParamsTypeGraph GetUserEntityDcomRightsParamsType = "graph"
	GetUserEntityDcomRightsParamsTypeList  GetUserEntityDcomRightsParamsType = "list"
)

// Defines values for GetUserEntityMembershipParamsType.
const (
	GetUserEntityMembershipParamsTypeCount GetUserEntityMembershipParamsType = "count"
	GetUserEntityMembershipParamsTypeGraph GetUserEntityMembershipParamsType = "graph"
	GetUserEntityMembershipParamsTypeList  GetUserEntityMembershipParamsType = "list"
)

// Defines values for GetUserEntityPsRemoteRightsParamsType.
const (
	GetUserEntityPsRemoteRightsParamsTypeCount GetUserEntityPsRemoteRightsParamsType = "count"
	GetUserEntityPsRemoteRightsParamsTypeGraph GetUserEntityPsRemoteRightsParamsType = "graph"
	GetUserEntityPsRemoteRightsParamsTypeList  GetUserEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetUserEntityRdpRightsParamsType.
const (
	GetUserEntityRdpRightsParamsTypeCount GetUserEntityRdpRightsParamsType = "count"
	GetUserEntityRdpRightsParamsTypeGraph GetUserEntityRdpRightsParamsType = "graph"
	GetUserEntityRdpRightsParamsTypeList  GetUserEntityRdpRightsParamsType = "list"
)

// Defines values for GetUserEntitySessionsParamsType.
const (
	GetUserEntitySessionsParamsTypeCount GetUserEntitySessionsParamsType = "count"
	GetUserEntitySessionsParamsTypeGraph GetUserEntitySessionsParamsType = "graph"
	GetUserEntitySessionsParamsTypeList  GetUserEntitySessionsParamsType = "list"
)

// Defines values for GetUserEntitySqlAdminRightsParamsType.
const (
	Count GetUserEntitySqlAdminRightsParamsType = "count"
	Graph GetUserEntitySqlAdminRightsParamsType = "graph"
	List  GetUserEntitySqlAdminRightsParamsType = "list"
)

// ApiErrorDetail defines model for api.error-detail.
type ApiErrorDetail struct {
	// Context The context in which the error took place
	Context *string `json:"context,omitempty"`

	// Message A human-readable description of the error
	Message *string `json:"message,omitempty"`
}

// ApiErrorWrapper defines model for api.error-wrapper.
type ApiErrorWrapper struct {
	// Errors The error(s) that occurred from processing the request
	Errors *[]ApiErrorDetail `json:"errors,omitempty"`

	// HttpStatus The HTTP status code
	HttpStatus *int `json:"http_status,omitempty"`

	// RequestId The unique identifier of the request that failed
	RequestId *openapi_types.UUID `json:"request_id,omitempty"`

	// Timestamp The RFC-3339 timestamp in which the error response was sent
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// ApiParamsPredicateFilterBoolean Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type ApiParamsPredicateFilterBoolean = bool

// ApiParamsPredicateFilterContains The contains predicate checks a property against the values in a given comma separated list.
// - `in` checks if the property matches an element in the given comma separated list.
//   - `in:Contains,GetChangesAll,MemberOf`
//
// - `nin` checks if the property does not match an element in the given comma separated list.
//   - `nin:LocalToComputer,MemberOfLocalGroup`
type ApiParamsPredicateFilterContains = string

// ApiParamsPredicateFilterInteger Filter results by column integer value. Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type ApiParamsPredicateFilterInteger = int

// ApiParamsPredicateFilterString Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type ApiParamsPredicateFilterString = string

// ApiParamsPredicateFilterTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type ApiParamsPredicateFilterTime = time.Time

// ApiParamsPredicateFilterUuid Filter results by column string-formatted uuid value. Valid filter predicates are `eq`, `neq`.
type ApiParamsPredicateFilterUuid = openapi_types.UUID

// ApiParamsQueryLimit The limit of results requested by the client.
type ApiParamsQueryLimit = int

// ApiParamsQuerySkip The number of items to skip in a paginated response.
type ApiParamsQuerySkip = int

// ApiParamsQuerySortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order.
// See parameter description for details about which columns are sortable.
type ApiParamsQuerySortBy = string

// ApiRequestsUserSetSecret defines model for api.requests.user.set-secret.
type ApiRequestsUserSetSecret struct {
	NeedsPasswordReset *bool   `json:"needs_password_reset,omitempty"`
	Secret             *string `json:"secret,omitempty"`
}

// ApiRequestsUserUpdate defines model for api.requests.user.update.
type ApiRequestsUserUpdate struct {
	EmailAddress   *openapi_types.Email `json:"email_address,omitempty"`
	FirstName      *string              `json:"first_name,omitempty"`
	IsDisabled     *bool                `json:"is_disabled,omitempty"`
	LastName       *string              `json:"last_name,omitempty"`
	Principal      *string              `json:"principal,omitempty"`
	Roles          *[]int32             `json:"roles,omitempty"`
	SamlProviderId *string              `json:"saml_provider_id,omitempty"`
}

// ApiResponseAuthenticatedRequester defines model for api.response.authenticated-requester.
type ApiResponseAuthenticatedRequester struct {
	Data *ApiResponseAuthenticatedRequester_Data `json:"data,omitempty"`
}

// ApiResponseAuthenticatedRequester_Data defines model for ApiResponseAuthenticatedRequester.Data.
type ApiResponseAuthenticatedRequester_Data struct {
	union json.RawMessage
}

// ApiResponseDataQualityPlatformAggregate defines model for api.response.data-quality-platform-aggregate.
type ApiResponseDataQualityPlatformAggregate struct {
	Data *struct {
		// Count The total number of results.
		Count *int                                                      `json:"count,omitempty"`
		Data  *[]ApiResponseDataQualityPlatformAggregate_Data_Data_Item `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	} `json:"data,omitempty"`
}

// ApiResponseDataQualityPlatformAggregate_Data_Data_Item defines model for ApiResponseDataQualityPlatformAggregate.Data.Data.Item.
type ApiResponseDataQualityPlatformAggregate_Data_Data_Item struct {
	union json.RawMessage
}

// ApiResponseFinding defines model for api.response.finding.
type ApiResponseFinding struct {
	Data *ApiResponseFinding_Data `json:"data,omitempty"`
}

// ApiResponseFinding_Data defines model for ApiResponseFinding.Data.
type ApiResponseFinding_Data struct {
	union json.RawMessage
}

// ApiResponsePagination defines model for api.response.pagination.
type ApiResponsePagination struct {
	// Count The total number of results.
	Count *int `json:"count,omitempty"`

	// Limit The limit of results requested by the client.
	Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

	// Skip The number of items to skip in a paginated response.
	Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
}

// ApiResponseTimeWindow defines model for api.response.time-window.
type ApiResponseTimeWindow struct {
	// End The RFC-3339 timestamp to describe the end of a time range
	End *time.Time `json:"end,omitempty"`

	// Start The RFC-3339 timestamp to describe the beginning of a time range
	Start *time.Time `json:"start,omitempty"`
}

// EnumAuditLogStatus defines model for enum.audit-log-status.
type EnumAuditLogStatus string

// EnumClientType This enum describes the collector client type.
type EnumClientType string

// EnumDatapipeStatus defines model for enum.datapipe-status.
type EnumDatapipeStatus string

// EnumJobStatus This enum describes the current status of a Job. Values are:
// - `-1` Invalid
// - `0` Ready
// - `1` Running
// - `2` Complete
// - `3` Canceled
// - `4` Timed Out
// - `5` Failed
// - `6` Ingesting
// - `7` Analyzing
// - `8` Partially Complete
type EnumJobStatus int

// EnumMfaActivationStatus The activation status of multi-factor authentication on a BloodHound user.
type EnumMfaActivationStatus string

// EnumRiskAcceptance defines model for enum.risk-acceptance.
type EnumRiskAcceptance string

// ModelAdDataQualityAggregation defines model for model.ad-data-quality-aggregation.
type ModelAdDataQualityAggregation struct {
	Acls          *int       `json:"acls,omitempty"`
	Aiacas        *int       `json:"aiacas,omitempty"`
	Certtemplates *int       `json:"certtemplates,omitempty"`
	Computers     *int       `json:"computers,omitempty"`
	Containers    *int       `json:"containers,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	DeletedAt     *NullTime  `json:"deleted_at,omitempty"`
	Domains       *int       `json:"domains,omitempty"`
	Enterprisecas *int       `json:"enterprisecas,omitempty"`
	Gpos          *int       `json:"gpos,omitempty"`
	Groups        *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                     *int32              `json:"id,omitempty"`
	LocalGroupCompleteness *float32            `json:"local_group_completeness,omitempty"`
	Ntauthstores           *int                `json:"ntauthstores,omitempty"`
	Ous                    *int                `json:"ous,omitempty"`
	Relationships          *int                `json:"relationships,omitempty"`
	Rootcas                *int                `json:"rootcas,omitempty"`
	RunId                  *openapi_types.UUID `json:"run_id,omitempty"`
	SessionCompleteness    *float32            `json:"session_completeness,omitempty"`
	Sessions               *int                `json:"sessions,omitempty"`
	UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
	Users                  *int                `json:"users,omitempty"`
}

// ModelAdDataQualityStat defines model for model.ad-data-quality-stat.
type ModelAdDataQualityStat struct {
	Acls          *int       `json:"acls,omitempty"`
	Aiacas        *int       `json:"aiacas,omitempty"`
	Certtemplates *int       `json:"certtemplates,omitempty"`
	Computers     *int       `json:"computers,omitempty"`
	Containers    *int       `json:"containers,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	DeletedAt     *NullTime  `json:"deleted_at,omitempty"`
	DomainSid     *string    `json:"domain_sid,omitempty"`
	Enterprisecas *int       `json:"enterprisecas,omitempty"`
	Gpos          *int       `json:"gpos,omitempty"`
	Groups        *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                     *int32              `json:"id,omitempty"`
	LocalGroupCompleteness *float64            `json:"local_group_completeness,omitempty"`
	Ntauthstores           *int                `json:"ntauthstores,omitempty"`
	Ous                    *int                `json:"ous,omitempty"`
	Relationships          *int                `json:"relationships,omitempty"`
	Rootcas                *int                `json:"rootcas,omitempty"`
	RunId                  *openapi_types.UUID `json:"run_id,omitempty"`
	SessionCompleteness    *float64            `json:"session_completeness,omitempty"`
	Sessions               *int                `json:"sessions,omitempty"`
	UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
	Users                  *int                `json:"users,omitempty"`
}

// ModelAppConfigParam defines model for model.app-config-param.
type ModelAppConfigParam struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32                  `json:"id,omitempty"`
	Key       *string                 `json:"key,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	UpdatedAt *time.Time              `json:"updated_at,omitempty"`
	Value     *map[string]interface{} `json:"value,omitempty"`
}

// ModelAssetGroup defines model for model.asset-group.
type ModelAssetGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *int32                     `json:"id,omitempty"`
	MemberCount *int                       `json:"member_count,omitempty"`
	Name        *string                    `json:"name,omitempty"`
	Selectors   *[]ModelAssetGroupSelector `json:"selectors,omitempty"`
	SystemGroup *bool                      `json:"system_group,omitempty"`
	Tag         *string                    `json:"tag,omitempty"`
	UpdatedAt   *time.Time                 `json:"updated_at,omitempty"`
}

// ModelAssetGroupCollection defines model for model.asset-group-collection.
type ModelAssetGroupCollection struct {
	CreatedAt *time.Time                        `json:"created_at,omitempty"`
	DeletedAt *NullTime                         `json:"deleted_at,omitempty"`
	Entries   *[]ModelAssetGroupCollectionEntry `json:"entries,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelAssetGroupCollectionEntry defines model for model.asset-group-collection-entry.
type ModelAssetGroupCollectionEntry struct {
	AssetGroupCollectionId *int64     `json:"asset_group_collection_id,omitempty"`
	CreatedAt              *time.Time `json:"created_at,omitempty"`
	DeletedAt              *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *int64                  `json:"id,omitempty"`
	NodeLabel  *string                 `json:"node_label,omitempty"`
	ObjectId   *string                 `json:"object_id,omitempty"`
	Properties *map[string]interface{} `json:"properties,omitempty"`
	UpdatedAt  *time.Time              `json:"updated_at,omitempty"`
}

// ModelAssetGroupMember defines model for model.asset-group-member.
type ModelAssetGroupMember struct {
	AssetGroupId    *int      `json:"asset_group_id,omitempty"`
	CustomMember    *bool     `json:"custom_member,omitempty"`
	EnvironmentId   *string   `json:"environment_id,omitempty"`
	EnvironmentKind *string   `json:"environment_kind,omitempty"`
	Kinds           *[]string `json:"kinds,omitempty"`
	Name            *string   `json:"name,omitempty"`
	ObjectId        *string   `json:"object_id,omitempty"`
	PrimaryKind     *string   `json:"primary_kind,omitempty"`
}

// ModelAssetGroupSelector defines model for model.asset-group-selector.
type ModelAssetGroupSelector struct {
	AssetGroupId *int32     `json:"asset_group_id,omitempty"`
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	DeletedAt    *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id             *int32     `json:"id,omitempty"`
	Name           *string    `json:"name,omitempty"`
	Selector       *string    `json:"selector,omitempty"`
	SystemSelector *bool      `json:"system_selector,omitempty"`
	UpdatedAt      *time.Time `json:"updated_at,omitempty"`
}

// ModelAssetGroupSelectorSpec defines model for model.asset-group-selector-spec.
type ModelAssetGroupSelectorSpec struct {
	Action       *ModelAssetGroupSelectorSpecAction `json:"action,omitempty"`
	SelectorName *string                            `json:"selector_name,omitempty"`
	Sid          *string                            `json:"sid,omitempty"`
}

// ModelAssetGroupSelectorSpecAction defines model for ModelAssetGroupSelectorSpec.Action.
type ModelAssetGroupSelectorSpecAction string

// ModelAuditLog defines model for model.audit-log.
type ModelAuditLog struct {
	Action     *string                 `json:"action,omitempty"`
	ActorEmail *openapi_types.Email    `json:"actor_email,omitempty"`
	ActorId    *openapi_types.UUID     `json:"actor_id,omitempty"`
	ActorName  *string                 `json:"actor_name,omitempty"`
	CommitId   *openapi_types.UUID     `json:"commit_id,omitempty"`
	CreatedAt  *time.Time              `json:"created_at,omitempty"`
	Fields     *map[string]interface{} `json:"fields,omitempty"`

	// Id This is the unique identifier for this object.
	Id              *int64              `json:"id,omitempty"`
	RequestId       *openapi_types.UUID `json:"request_id,omitempty"`
	SourceIpAddress *string             `json:"source_ip_address,omitempty"`
	Status          *EnumAuditLogStatus `json:"status,omitempty"`
}

// ModelAuthSecret defines model for model.auth-secret.
type ModelAuthSecret struct {
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	DeletedAt    *NullTime  `json:"deleted_at,omitempty"`
	DigestMethod *string    `json:"digest_method,omitempty"`
	ExpiresAt    *time.Time `json:"expires_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int32     `json:"id,omitempty"`
	TotpActivated *bool      `json:"totp_activated,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
}

// ModelAuthToken defines model for model.auth-token.
type ModelAuthToken struct {
	CreatedAt  *time.Time `json:"created_at,omitempty"`
	DeletedAt  *NullTime  `json:"deleted_at,omitempty"`
	HmacMethod *string    `json:"hmac_method,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *openapi_types.UUID `json:"id,omitempty"`
	Key        *string             `json:"key,omitempty"`
	LastAccess *time.Time  `json:"last_access,omitempty"`
	Name       *NullString `json:"name,omitempty"`
	UpdatedAt  *time.Time  `json:"updated_at,omitempty"`
	UserId     *NullUuid   `json:"user_id,omitempty"`
}

// ModelAzureDataQualityAggregation defines model for model.azure-data-quality-aggregation.
type ModelAzureDataQualityAggregation struct {
	Apps      *int       `json:"apps,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	Devices   *int       `json:"devices,omitempty"`
	Groups    *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                *int32              `json:"id,omitempty"`
	KeyVaults         *int                `json:"key_vaults,omitempty"`
	ManagementGroups  *int                `json:"management_groups,omitempty"`
	Relationships     *int                `json:"relationships,omitempty"`
	ResourceGroups    *int                `json:"resource_groups,omitempty"`
	RunId             *openapi_types.UUID `json:"run_id,omitempty"`
	ServicePrincipals *int                `json:"service_principals,omitempty"`
	Subscriptions     *int                `json:"subscriptions,omitempty"`
	Tenants           *int                `json:"tenants,omitempty"`
	UpdatedAt         *time.Time          `json:"updated_at,omitempty"`
	Users             *int                `json:"users,omitempty"`
	Vms               *int                `json:"vms,omitempty"`
}

// ModelAzureDataQualityStat defines model for model.azure-data-quality-stat.
type ModelAzureDataQualityStat struct {
	Apps      *int       `json:"apps,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	Devices   *int       `json:"devices,omitempty"`
	Groups    *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                *int32              `json:"id,omitempty"`
	KeyVaults         *int                `json:"key_vaults,omitempty"`
	ManagementGroups  *int                `json:"management_groups,omitempty"`
	Relationships     *int                `json:"relationships,omitempty"`
	ResourceGroups    *int                `json:"resource_groups,omitempty"`
	RunId             *openapi_types.UUID `json:"run_id,omitempty"`
	ServicePrincipals *int                `json:"service_principals,omitempty"`
	Subscriptions     *int                `json:"subscriptions,omitempty"`
	Tenantid          *openapi_types.UUID `json:"tenantid,omitempty"`
	UpdatedAt         *time.Time          `json:"updated_at,omitempty"`
	Users             *int                `json:"users,omitempty"`
	Vms               *int                `json:"vms,omitempty"`
}

// ModelBhGraphEdge defines model for model.bh-graph.edge.
type ModelBhGraphEdge struct {
	Color *string                            `json:"color,omitempty"`
	Data  *map[string]map[string]interface{} `json:"data,omitempty"`
	End1  *ModelBhGraphLinkEnd               `json:"end1,omitempty"`
	End2  *ModelBhGraphLinkEnd               `json:"end2,omitempty"`
	Fade  *bool                              `json:"fade,omitempty"`
	Flow  *struct {
		Velocity *int `json:"velocity,omitempty"`
	} `json:"flow,omitempty"`
	Glyphs    *[]ModelBhGraphGlyph `json:"glyphs,omitempty"`
	Id1       *string              `json:"id1,omitempty"`
	Id2       *string              `json:"id2,omitempty"`
	Label     *ModelBhGraphLabel   `json:"label,omitempty"`
	LineStyle *string              `json:"lineStyle,omitempty"`
	Width     *int                 `json:"width,omitempty"`
}

// ModelBhGraphFontIcon defines model for model.bh-graph.font-icon.
type ModelBhGraphFontIcon struct {
	Color      *string `json:"color,omitempty"`
	FontFamily *string `json:"fontFamily,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// ModelBhGraphGlyph defines model for model.bh-graph.glyph.
type ModelBhGraphGlyph struct {
	Angle    *int                    `json:"angle,omitempty"`
	Blink    *bool                   `json:"blink,omitempty"`
	Border   *ModelBhGraphItemBorder `json:"border,omitempty"`
	Color    *string                 `json:"color,omitempty"`
	FontIcon *ModelBhGraphFontIcon   `json:"fontIcon,omitempty"`
	Image    *string                 `json:"image,omitempty"`
	Label    *ModelBhGraphLabel      `json:"label,omitempty"`
	Position *string                 `json:"position,omitempty"`
	Radius   *int                    `json:"radius,omitempty"`
	Size     *int                    `json:"size,omitempty"`
}

// ModelBhGraphGraph defines model for model.bh-graph.graph.
type ModelBhGraphGraph map[string]ModelBhGraphGraph_AdditionalProperties

// ModelBhGraphGraph_AdditionalProperties defines model for model.bh-graph.graph.AdditionalProperties.
type ModelBhGraphGraph_AdditionalProperties struct {
	union json.RawMessage
}

// ModelBhGraphItem defines model for model.bh-graph.item.
type ModelBhGraphItem struct {
	Color  *string                            `json:"color,omitempty"`
	Data   *map[string]map[string]interface{} `json:"data,omitempty"`
	Fade   *bool                `json:"fade,omitempty"`
	Glyphs *[]ModelBhGraphGlyph `json:"glyphs,omitempty"`
}

// ModelBhGraphItemBorder defines model for model.bh-graph.item-border.
type ModelBhGraphItemBorder struct {
	Color *string `json:"color,omitempty"`
}

// ModelBhGraphLabel defines model for model.bh-graph.label.
type ModelBhGraphLabel struct {
	Bold       *bool   `json:"bold,omitempty"`
	Color      *string `json:"color,omitempty"`
	FontFamily *string `json:"fontFamily,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// ModelBhGraphLinkEnd defines model for model.bh-graph.link-end.
type ModelBhGraphLinkEnd struct {
	Arrow   *bool                `json:"arrow,omitempty"`
	BackOff *int                 `json:"backOff,omitempty"`
	Color   *string              `json:"color,omitempty"`
	Glyphs  *[]ModelBhGraphGlyph `json:"glyphs,omitempty"`
	Label   *ModelBhGraphLabel   `json:"label,omitempty"`
}

// ModelBhGraphNode defines model for model.bh-graph.node.
type ModelBhGraphNode struct {
	Border *struct {
		Color     *string `json:"color,omitempty"`
		LineStyle *string `json:"lineStyle,omitempty"`
		Width     *int    `json:"width,omitempty"`
	} `json:"border,omitempty"`
	Color       *string `json:"color,omitempty"`
	Coordinates *struct {
		Lat *int `json:"lat,omitempty"`
		Lng *int `json:"lng,omitempty"`
	} `json:"coordinates,omitempty"`
	Cutout   *bool                              `json:"cutout,omitempty"`
	Data     *map[string]map[string]interface{} `json:"data,omitempty"`
	Fade     *bool                 `json:"fade,omitempty"`
	FontIcon *ModelBhGraphFontIcon `json:"fontIcon,omitempty"`
	Glyphs   *[]ModelBhGraphGlyph  `json:"glyphs,omitempty"`
	Halos    *[]struct {
		Color  *string `json:"color,omitempty"`
		Radius *int    `json:"radius,omitempty"`
		Width  *int    `json:"width,omitempty"`
	} `json:"halos,omitempty"`
	Image *string `json:"image,omitempty"`
	Label *struct {
		BackgroundColor *string `json:"backgroundColor,omitempty"`
		Bold            *bool   `json:"bold,omitempty"`
		Center          *bool   `json:"center,omitempty"`
		Color           *string `json:"color,omitempty"`
		FontFamily      *string `json:"fontFamily,omitempty"`
		FontSize        *int    `json:"fontSize,omitempty"`
		Text            *string `json:"text,omitempty"`
	} `json:"label,omitempty"`
	Shape *string `json:"shape,omitempty"`
	Size  *int    `json:"size,omitempty"`
}

// ModelClient defines model for model.client.
type ModelClient struct {
	CompletedJobCount *int32                   `json:"completed_job_count,omitempty"`
	ConfiguredUser    *string                  `json:"configured_user,omitempty"`
	CreatedAt         *time.Time               `json:"created_at,omitempty"`
	CurrentJob        *ModelClientScheduledJob `json:"current_job,omitempty"`
	CurrentJobId      *NullInt64               `json:"current_job_id,omitempty"`
	DeletedAt         *NullTime                `json:"deleted_at,omitempty"`
	DomainController  *NullString              `json:"domain_controller,omitempty"`
	Events            *[]ModelClientSchedule   `json:"events,omitempty"`
	Hostname          *string                  `json:"hostname,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *openapi_types.UUID `json:"id,omitempty"`
	IpAddress   *string             `json:"ip_address,omitempty"`
	LastCheckin *time.Time          `json:"last_checkin,omitempty"`
	Name        *string         `json:"name,omitempty"`
	Token       *ModelAuthToken `json:"token,omitempty"`
	Type        *EnumClientType `json:"type,omitempty"`
	UpdatedAt   *time.Time      `json:"updated_at,omitempty"`
	UserSid     *NullString     `json:"user_sid,omitempty"`
	Version     *string         `json:"version,omitempty"`
}

// ModelClientDisplay defines model for model.client-display.
type ModelClientDisplay struct {
	CompletedJobCount  *int32                          `json:"completed_job_count,omitempty"`
	CompletedTaskCount *int32                          `json:"completed_task_count,omitempty"`
	ConfiguredUser     *string                         `json:"configured_user,omitempty"`
	CurrentJob         *ModelClientScheduledJobDisplay `json:"current_job,omitempty"`
	CurrentJobId       *NullInt64                      `json:"current_job_id,omitempty"`
	CurrentTask        *ModelClientScheduledJobDisplay `json:"current_task,omitempty"`
	CurrentTaskId      *NullInt64                      `json:"current_task_id,omitempty"`
	DomainController   *NullString                     `json:"domain_controller,omitempty"`
	Events             *[]ModelClientScheduleDisplay   `json:"events,omitempty"`
	Hostname           *string                         `json:"hostname,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *openapi_types.UUID `json:"id,omitempty"`
	IpAddress   *string             `json:"ip_address,omitempty"`
	LastCheckin *time.Time          `json:"last_checkin,omitempty"`
	Name        *string         `json:"name,omitempty"`
	Token       *ModelAuthToken `json:"token,omitempty"`

	// Type This enum describes the collector client type.
	Type    *EnumClientType `json:"type,omitempty"`
	UserSid *NullString     `json:"user_sid,omitempty"`
	Version *string         `json:"version,omitempty"`
}

// ModelClientSchedule defines model for model.client-schedule.
type ModelClientSchedule struct {
	AdStructureCollection  *bool               `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool               `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool               `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool               `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID `json:"client_id,omitempty"`
	CreatedAt              *time.Time          `json:"created_at,omitempty"`
	DcRegistryCollection   *bool     `json:"dc_registry_collection,omitempty"`
	DeletedAt              *NullTime `json:"deleted_at,omitempty"`
	Domains                *[]string `json:"domains,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int32     `json:"id,omitempty"`
	LocalGroupCollection *bool      `json:"local_group_collection,omitempty"`
	NextScheduledAt      *time.Time `json:"next_scheduled_at,omitempty"`
	Ous                  *[]string  `json:"ous,omitempty"`
	Rrule                *string    `json:"rrule,omitempty"`
	SessionCollection    *bool      `json:"session_collection,omitempty"`
	UpdatedAt            *time.Time `json:"updated_at,omitempty"`
}

// ModelClientScheduleDisplay defines model for model.client-schedule-display.
type ModelClientScheduleDisplay struct {
	AdStructureCollection  *bool                 `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                 `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                 `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                 `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID   `json:"client_id,omitempty"`
	DcRegistryCollection   *bool                 `json:"dc_registry_collection,omitempty"`
	Domains                *[]ModelDomainDetails `json:"domains,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int32            `json:"id,omitempty"`
	LocalGroupCollection *bool             `json:"local_group_collection,omitempty"`
	Ous                  *[]ModelOuDetails `json:"ous,omitempty"`
	Rrule                *string           `json:"rrule,omitempty"`
	SessionCollection    *bool             `json:"session_collection,omitempty"`
}

// ModelClientScheduledJob defines model for model.client-scheduled-job.
type ModelClientScheduledJob struct {
	AdStructureCollection  *bool                          `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                          `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                          `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                          `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID            `json:"client_id,omitempty"`
	ClientName             *string                        `json:"client_name,omitempty"`
	CreatedAt              *time.Time                     `json:"created_at,omitempty"`
	DcRegistryCollection   *bool                          `json:"dc_registry_collection,omitempty"`
	DeletedAt              *NullTime                      `json:"deleted_at,omitempty"`
	DomainController       *NullString                    `json:"domain_controller,omitempty"`
	DomainResults          *[]ModelDomainCollectionResult `json:"domain_results,omitempty"`
	Domains                *[]string                      `json:"domains,omitempty"`
	EndTime                *time.Time                     `json:"end_time,omitempty"`
	EventId                *NullInt32                     `json:"event_id,omitempty"`
	EventTitle             *string                        `json:"event_title,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int64         `json:"id,omitempty"`
	LastIngest           *time.Time     `json:"last_ingest,omitempty"`
	LocalGroupCollection *bool          `json:"local_group_collection,omitempty"`
	LogPath              *NullString    `json:"log_path,omitempty"`
	Ous                  *[]string      `json:"ous,omitempty"`
	SessionCollection    *bool          `json:"session_collection,omitempty"`
	StartTime            *time.Time     `json:"start_time,omitempty"`
	Status               *EnumJobStatus `json:"status,omitempty"`
	StatusMessage        *string        `json:"statusMessage,omitempty"`
	UpdatedAt            *time.Time     `json:"updated_at,omitempty"`
}

// ModelClientScheduledJobDisplay defines model for model.client-scheduled-job-display.
type ModelClientScheduledJobDisplay struct {
	AdStructureCollection  *bool                          `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                          `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                          `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                          `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID            `json:"client_id,omitempty"`
	ClientName             *string                        `json:"client_name,omitempty"`
	DcRegistryCollection   *bool                          `json:"dc_registry_collection,omitempty"`
	DomainController       *string                        `json:"domain_controller,omitempty"`
	DomainResults          *[]ModelDomainCollectionResult `json:"domain_results,omitempty"`
	Domains                *[]ModelDomainDetails          `json:"domains,omitempty"`
	EndTime                *time.Time                     `json:"end_time,omitempty"`
	EventId                *NullInt32                     `json:"event_id,omitempty"`
	ExecutionTime          *time.Time                     `json:"execution_time,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int64            `json:"id,omitempty"`
	LocalGroupCollection *bool             `json:"local_group_collection,omitempty"`
	Ous                  *[]ModelOuDetails `json:"ous,omitempty"`
	SessionCollection    *bool             `json:"session_collection,omitempty"`
	StartTime            *time.Time        `json:"start_time,omitempty"`

	// Status This enum describes the current status of a Job. Values are:
	// - `-1` Invalid
	// - `0` Ready
	// - `1` Running
	// - `2` Complete
	// - `3` Canceled
	// - `4` Timed Out
	// - `5` Failed
	// - `6` Ingesting
	// - `7` Analyzing
	// - `8` Partially Complete
	Status        *EnumJobStatus `json:"status,omitempty"`
	StatusMessage *string        `json:"status_message,omitempty"`
}

// ModelCollectorManifest defines model for model.collector-manifest.
type ModelCollectorManifest struct {
	Latest   *string                  `json:"latest,omitempty"`
	Versions *[]ModelCollectorVersion `json:"versions,omitempty"`
}

// ModelCollectorVersion defines model for model.collector-version.
type ModelCollectorVersion struct {
	Deprecated *bool   `json:"deprecated,omitempty"`
	Sha256sum  *string `json:"sha256sum,omitempty"`
	Version    *string `json:"version,omitempty"`
}

// ModelComponentsBaseAdEntity defines model for model.components.base-ad-entity.
type ModelComponentsBaseAdEntity struct {
	Exists   *bool   `json:"exists,omitempty"`
	Name     *string `json:"name,omitempty"`
	Objectid *string `json:"objectid,omitempty"`
}

// ModelComponentsInt32Id defines model for model.components.int32.id.
type ModelComponentsInt32Id struct {
	// Id This is the unique identifier for this object.
	Id *int32 `json:"id,omitempty"`
}

// ModelComponentsInt64Id defines model for model.components.int64.id.
type ModelComponentsInt64Id struct {
	// Id This is the unique identifier for this object.
	Id *int64 `json:"id,omitempty"`
}

// ModelComponentsTimestamps defines model for model.components.timestamps.
type ModelComponentsTimestamps struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelComponentsUuid defines model for model.components.uuid.
type ModelComponentsUuid struct {
	// Id This is the unique identifier for this object.
	Id *openapi_types.UUID `json:"id,omitempty"`
}

// ModelDomainCollectionResult defines model for model.domain-collection-result.
type ModelDomainCollectionResult struct {
	// AiacaCount A count of aiacas enumerated
	AiacaCount *int `json:"aiaca_count,omitempty"`

	// CerttemplateCount A count of certtemplates enumerated
	CerttemplateCount *int `json:"certtemplate_count,omitempty"`

	// ComputerCount A count of computers enumerated
	ComputerCount *int `json:"computer_count,omitempty"`

	// ContainerCount A count of containers enumerated
	ContainerCount *int       `json:"container_count,omitempty"`
	CreatedAt      *time.Time `json:"created_at,omitempty"`
	DeletedAt      *NullTime  `json:"deleted_at,omitempty"`

	// DeletedCount A count of deleted objects enumerated
	DeletedCount *int `json:"deleted_count,omitempty"`

	// DomainName Name of the domain that was enumerated
	DomainName *string `json:"domain_name,omitempty"`

	// EnterprisecaCount A count of enterprisecas enumerated
	EnterprisecaCount *int `json:"enterpriseca_count,omitempty"`

	// GpoCount A count of gpos enumerated
	GpoCount *int `json:"gpo_count,omitempty"`

	// GroupCount A count of groups enumerated
	GroupCount *int `json:"group_count,omitempty"`

	// Id This is the unique identifier for this object.
	Id    *int64 `json:"id,omitempty"`
	JobId *int64 `json:"job_id,omitempty"`

	// Message A status message for a domain enumeration result
	Message *string `json:"message,omitempty"`

	// NtauthstoreCount A count of ntauthstores enumerated
	NtauthstoreCount *int `json:"ntauthstore_count,omitempty"`

	// OuCount A count of ous enumerated
	OuCount *int `json:"ou_count,omitempty"`

	// RootcaCount A count of rootcas enumerated
	RootcaCount *int `json:"rootca_count,omitempty"`

	// Success A boolean value indicating whether the domain enumeration succeeded
	Success   *bool      `json:"success,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UserCount A count of users enumerated
	UserCount *int `json:"user_count,omitempty"`
}

// ModelDomainDetails defines model for model.domain-details.
type ModelDomainDetails struct {
	Exists   *bool   `json:"exists,omitempty"`
	Name     *string `json:"name,omitempty"`
	Objectid *string `json:"objectid,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// ModelDomainSelector defines model for model.domain-selector.
type ModelDomainSelector struct {
	Collected *bool   `json:"collected,omitempty"`
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// ModelFeatureFlag defines model for model.feature-flag.
type ModelFeatureFlag struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Enabled     *bool      `json:"enabled,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int32     `json:"id,omitempty"`
	Key           *string    `json:"key,omitempty"`
	Name          *string    `json:"name,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
	UserUpdatable *bool      `json:"user_updatable,omitempty"`
}

// ModelFileUploadJob defines model for model.file-upload-job.
type ModelFileUploadJob struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	EndTime   *time.Time `json:"end_time,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *int64     `json:"id,omitempty"`
	LastIngest *time.Time `json:"last_ingest,omitempty"`
	StartTime  *time.Time `json:"start_time,omitempty"`

	// Status This enum describes the current status of a Job. Values are:
	// - `-1` Invalid
	// - `0` Ready
	// - `1` Running
	// - `2` Complete
	// - `3` Canceled
	// - `4` Timed Out
	// - `5` Failed
	// - `6` Ingesting
	// - `7` Analyzing
	// - `8` Partially Complete
	Status           *EnumJobStatus `json:"status,omitempty"`
	StatusMessage    *string        `json:"status_message,omitempty"`
	UpdatedAt        *time.Time           `json:"updated_at,omitempty"`
	UserEmailAddress *openapi_types.Email `json:"user_email_address,omitempty"`
	UserId           *openapi_types.UUID  `json:"user_id,omitempty"`
}

// ModelListFinding defines model for model.list-finding.
type ModelListFinding struct {
	DomainSID     *string                            `json:"DomainSID,omitempty"`
	Finding       *string                            `json:"Finding,omitempty"`
	Principal     *string                            `json:"Principal,omitempty"`
	PrincipalKind *string                            `json:"PrincipalKind,omitempty"`
	Props         *map[string]map[string]interface{} `json:"Props,omitempty"`
	AcceptedUntil *time.Time                         `json:"accepted_until,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	DeletedAt     *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelOuDetails defines model for model.ou-details.
type ModelOuDetails struct {
	Distinguishedname *string `json:"distinguishedname,omitempty"`
	Exists            *bool   `json:"exists,omitempty"`
	Name              *string `json:"name,omitempty"`
	Objectid          *string `json:"objectid,omitempty"`
	Type              *string `json:"type,omitempty"`
}

// ModelPermission defines model for model.permission.
type ModelPermission struct {
	Authority *string    `json:"authority,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRelationshipFinding defines model for model.relationship-finding.
type ModelRelationshipFinding struct {
	AcceptedUntil        *time.Time `json:"AcceptedUntil,omitempty"`
	ComboGraphRelationID *NullInt64 `json:"ComboGraphRelationID,omitempty"`
	DomainSID            *string    `json:"DomainSID,omitempty"`
	Finding              *string                            `json:"Finding,omitempty"`
	FromPrincipal        *string                            `json:"FromPrincipal,omitempty"`
	FromPrincipalKind    *string                            `json:"FromPrincipalKind,omitempty"`
	FromPrincipalProps   *map[string]map[string]interface{} `json:"FromPrincipalProps,omitempty"`
	PrincipalHash        *string                            `json:"PrincipalHash,omitempty"`
	RelProps             *map[string]map[string]interface{} `json:"RelProps,omitempty"`
	ToPrincipal          *string                            `json:"ToPrincipal,omitempty"`
	ToPrincipalKind      *string                            `json:"ToPrincipalKind,omitempty"`
	ToPrincipalProps     *map[string]map[string]interface{} `json:"ToPrincipalProps,omitempty"`
	CreatedAt            *time.Time `json:"created_at,omitempty"`
	DeletedAt            *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRiskCounts defines model for model.risk-counts.
type ModelRiskCounts struct {
	CompositeRisk      *float64   `json:"CompositeRisk,omitempty"`
	DomainSID          *string    `json:"DomainSID,omitempty"`
	Finding            *string    `json:"Finding,omitempty"`
	FindingCount       *int       `json:"FindingCount,omitempty"`
	ImpactedAssetCount *int       `json:"ImpactedAssetCount,omitempty"`
	CreatedAt          *time.Time `json:"created_at,omitempty"`
	DeletedAt          *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRiskPostureStat defines model for model.risk-posture-stat.
type ModelRiskPostureStat struct {
	CreatedAt         *time.Time `json:"created_at,omitempty"`
	CriticalRiskCount *int      `json:"critical_risk_count,omitempty"`
	DeletedAt         *NullTime `json:"deleted_at,omitempty"`
	DomainSid         *string   `json:"domain_sid,omitempty"`
	ExposureIndex     *float64   `json:"exposure_index,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int64     `json:"id,omitempty"`
	TierZeroCount *int64     `json:"tier_zero_count,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
}

// ModelRole defines model for model.role.
type ModelRole struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *int32             `json:"id,omitempty"`
	Name        *string            `json:"name,omitempty"`
	Permissions *[]ModelPermission `json:"permissions,omitempty"`
	UpdatedAt   *time.Time         `json:"updated_at,omitempty"`
}

// ModelSamlProvider defines model for model.saml-provider.
type ModelSamlProvider struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	DisplayName *string    `json:"display_name,omitempty"`

	// Id This is the unique identifier for this object.
	Id                         *int32     `json:"id,omitempty"`
	IdpIssuerUri               *string    `json:"idp_issuer_uri,omitempty"`
	IdpSsoUri                  *string    `json:"idp_sso_uri,omitempty"`
	Name                       *string    `json:"name,omitempty"`
	PrincipalAttributeMappings *[]string  `json:"principal_attribute_mappings,omitempty"`
	SpAcsUri                   *string    `json:"sp_acs_uri,omitempty"`
	SpIssuerUri                *string    `json:"sp_issuer_uri,omitempty"`
	SpMetadataUri              *string    `json:"sp_metadata_uri,omitempty"`
	SpSsoUri                   *string    `json:"sp_sso_uri,omitempty"`
	UpdatedAt                  *time.Time `json:"updated_at,omitempty"`
}

// ModelSamlSignOnEndpoint defines model for model.saml-sign-on-endpoint.
type ModelSamlSignOnEndpoint struct {
	IdpUrl *string `json:"idp_url,omitempty"`
	Name   *string `json:"name,omitempty"`
}

// ModelSavedQuery defines model for model.saved-query.
type ModelSavedQuery struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64              `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Query     *string             `json:"query,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	UserId    *openapi_types.UUID `json:"user_id,omitempty"`
}

// ModelSearchResult defines model for model.search-result.
type ModelSearchResult struct {
	Distinguishedname *string `json:"distinguishedname,omitempty"`
	Name              *string `json:"name,omitempty"`
	Objectid          *string `json:"objectid,omitempty"`
	SystemTags        *string `json:"system_tags,omitempty"`
	Type              *string `json:"type,omitempty"`
}

// ModelUnifiedGraphEdge defines model for model.unified-graph.edge.
type ModelUnifiedGraphEdge struct {
	Kind       *string                            `json:"kind,omitempty"`
	Label      *string                            `json:"label,omitempty"`
	LastSeen   *time.Time                         `json:"lastSeen,omitempty"`
	Properties *map[string]map[string]interface{} `json:"properties,omitempty"`
	Source     *string                            `json:"source,omitempty"`
	Target     *string                            `json:"target,omitempty"`
}

// ModelUnifiedGraphGraph defines model for model.unified-graph.graph.
type ModelUnifiedGraphGraph struct {
	Edges *[]ModelUnifiedGraphEdge          `json:"edges,omitempty"`
	Nodes *map[string]ModelUnifiedGraphNode `json:"nodes,omitempty"`
}

// ModelUnifiedGraphNode defines model for model.unified-graph.node.
type ModelUnifiedGraphNode struct {
	IsTierZero *string                            `json:"isTierZero,omitempty"`
	Kind       *string                            `json:"kind,omitempty"`
	Label      *string                            `json:"label,omitempty"`
	LastSeen   *time.Time                         `json:"lastSeen,omitempty"`
	ObjectId   *string                            `json:"objectId,omitempty"`
	Properties *map[string]map[string]interface{} `json:"properties,omitempty"`
}

// ModelUser defines model for model.user.
type ModelUser struct {
	AuthSecret   *ModelAuthSecret `json:"AuthSecret,omitempty"`
	CreatedAt    *time.Time       `json:"created_at,omitempty"`
	DeletedAt    *NullTime        `json:"deleted_at,omitempty"`
	EmailAddress *NullString      `json:"email_address,omitempty"`
	EulaAccepted *bool            `json:"eula_accepted,omitempty"`
	FirstName    *NullString      `json:"first_name,omitempty"`

	// Id This is the unique identifier for this object.
	Id             *openapi_types.UUID `json:"id,omitempty"`
	IsDisabled     *bool               `json:"is_disabled,omitempty"`
	LastLogin      *time.Time   `json:"last_login,omitempty"`
	LastName       *NullString  `json:"last_name,omitempty"`
	PrincipalName  *string      `json:"principal_name,omitempty"`
	Roles          *[]ModelRole `json:"roles,omitempty"`
	SamlProviderId *NullInt32   `json:"saml_provider_id,omitempty"`
	UpdatedAt      *time.Time   `json:"updated_at,omitempty"`
}

// NullInt32 defines model for null.int32.
type NullInt32 struct {
	Int32 *int32 `json:"int32,omitempty"`

	// Valid Valid is true if `int32` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullInt64 defines model for null.int64.
type NullInt64 struct {
	Int64 *int64 `json:"int64,omitempty"`

	// Valid Valid is true if `int64` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullString defines model for null.string.
type NullString struct {
	String *string `json:"string,omitempty"`

	// Valid Valid is true if `string`` is not `null`
	Valid *bool `json:"valid,omitempty"`
}

// NullTime defines model for null.time.
type NullTime struct {
	// Time An RFC-3339 formatted string
	Time *time.Time `json:"time,omitempty"`

	// Valid Valid is true if `time` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullUuid defines model for null.uuid.
type NullUuid struct {
	Uuid *openapi_types.UUID `json:"uuid,omitempty"`

	// Valid Valid is true if `uuid` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// HeaderPrefer defines model for header.prefer.
type HeaderPrefer = int

// PathObjectId The unique object identifier
type PathObjectId = string

// QueryClientsHydrateDomains defines model for query.clients.hydrate-domains.
type QueryClientsHydrateDomains = bool

// QueryClientsHydrateOus defines model for query.clients.hydrate-ous.
type QueryClientsHydrateOus = bool

// QueryClientsJobAdStructureCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobAdStructureCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobCaRegistryCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobCaRegistryCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobCertServicesCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobCertServicesCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobClientId Filter results by column string-formatted uuid value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobClientId = ApiParamsPredicateFilterUuid

// QueryClientsJobDcRegistryCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobDcRegistryCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobDomainController Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobDomainController = ApiParamsPredicateFilterString

// QueryClientsJobEndTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobEndTime = ApiParamsPredicateFilterTime

// QueryClientsJobEventId Filter results by column integer value. Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobEventId = ApiParamsPredicateFilterInteger

// QueryClientsJobEventTitle Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobEventTitle = ApiParamsPredicateFilterString

// QueryClientsJobExecutionTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobExecutionTime = ApiParamsPredicateFilterTime

// QueryClientsJobLastIngest Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobLastIngest = ApiParamsPredicateFilterTime

// QueryClientsJobLocalGroupCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobLocalGroupCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobLogPath Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobLogPath = ApiParamsPredicateFilterString

// QueryClientsJobSessionCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobSessionCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobStartTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobStartTime = ApiParamsPredicateFilterTime

// QueryClientsJobStatus Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobStatus = ApiParamsPredicateFilterString

// QueryCreatedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryCreatedAt = ApiParamsPredicateFilterTime

// QueryDeletedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryDeletedAt = ApiParamsPredicateFilterTime

// QueryEntityLimit defines model for query.entity.limit.
type QueryEntityLimit = int

// QueryEntitySkip defines model for query.entity.skip.
type QueryEntitySkip = int

// QueryEntitySortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order.
// See parameter description for details about which columns are sortable.
type QueryEntitySortBy = ApiParamsQuerySortBy

// QueryEntityType defines model for query.entity.type.
type QueryEntityType string

// QueryHydrateCounts defines model for query.hydrate-counts.
type QueryHydrateCounts = bool

// QueryLimit The limit of results requested by the client.
type QueryLimit = ApiParamsQueryLimit

// QuerySkip The number of items to skip in a paginated response.
type QuerySkip = ApiParamsQuerySkip

// QueryUpdatedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryUpdatedAt = ApiParamsPredicateFilterTime

// BadRequest defines model for bad-request.
type BadRequest = ApiErrorWrapper

// EntityInfoQueryResults defines model for entity-info-query-results.
type EntityInfoQueryResults struct {
	Data *struct {
		Props *map[string]map[string]interface{} `json:"props,omitempty"`
	} `json:"data,omitempty"`
}

// ErrorResponse defines model for error-response.
type ErrorResponse = ApiErrorWrapper

// Forbidden defines model for forbidden.
type Forbidden = ApiErrorWrapper

// InternalServerError defines model for internal-server-error.
type InternalServerError = ApiErrorWrapper

// NotFound defines model for not-found.
type NotFound = ApiErrorWrapper

// RelatedEntityQueryResults defines model for related-entity-query-results.
type RelatedEntityQueryResults struct {
	union json.RawMessage
}

// TooManyRequests defines model for too-many-requests.
type TooManyRequests = ApiErrorWrapper

// Unauthorized defines model for unauthorized.
type Unauthorized = ApiErrorWrapper

// AcceptEulaParams defines parameters for AcceptEula.
type AcceptEulaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAdDomainDataQualityStatsParams defines parameters for GetAdDomainDataQualityStats.
type GetAdDomainDataQualityStatsParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityParams defines parameters for GetAiaCaEntity.
type GetAiaCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityControllersParams defines parameters for GetAiaCaEntityControllers.
type GetAiaCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetAiaCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityControllersParamsType defines parameters for GetAiaCaEntityControllers.
type GetAiaCaEntityControllersParamsType string

// StartAnalysisParams defines parameters for StartAnalysis.
type StartAnalysisParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupsParams defines parameters for ListAssetGroups.
type ListAssetGroupsParams struct {
	// SortBy Sortable columns are `name`, `tag`, and `member_count`.
	SortBy      *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name        *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Tag         *ApiParamsPredicateFilterString  `form:"tag,omitempty" json:"tag,omitempty"`
	SystemGroup *ApiParamsPredicateFilterString  `form:"system_group,omitempty" json:"system_group,omitempty"`
	MemberCount *ApiParamsPredicateFilterInteger `form:"member_count,omitempty" json:"member_count,omitempty"`
	Id          *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAssetGroupParams defines parameters for CreateAssetGroup.
type CreateAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAssetGroupParams defines parameters for DeleteAssetGroup.
type DeleteAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupParams defines parameters for GetAssetGroup.
type GetAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupJSONBody defines parameters for UpdateAssetGroup.
type UpdateAssetGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
}

// UpdateAssetGroupParams defines parameters for UpdateAssetGroup.
type UpdateAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupCollectionsParams defines parameters for ListAssetGroupCollections.
type ListAssetGroupCollectionsParams struct {
	SortBy *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id     *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupComboNodeParams defines parameters for GetAssetGroupComboNode.
type GetAssetGroupComboNodeParams struct {
	// Domainsid Filter by Domain security identifier.
	Domainsid *string `form:"domainsid,omitempty" json:"domainsid,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupCustomMemberCountParams defines parameters for GetAssetGroupCustomMemberCount.
type GetAssetGroupCustomMemberCountParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupMembersParams defines parameters for ListAssetGroupMembers.
type ListAssetGroupMembersParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `object_id`, `asset_group_id`, `primary_kind`, `environment_id`, `environment_kind`, and `name`.
	SortBy          *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	ObjectId        *ApiParamsPredicateFilterString `form:"object_id,omitempty" json:"object_id,omitempty"`
	PrimaryKind     *ApiParamsPredicateFilterString `form:"primary_kind,omitempty" json:"primary_kind,omitempty"`
	EnvironmentId   *ApiParamsPredicateFilterString `form:"environment_id,omitempty" json:"environment_id,omitempty"`
	EnvironmentKind *ApiParamsPredicateFilterString `form:"environment_kind,omitempty" json:"environment_kind,omitempty"`
	Name            *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	CustomMember    *ApiParamsPredicateFilterString `form:"custom_member,omitempty" json:"custom_member,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupMemberCountByKindParams defines parameters for ListAssetGroupMemberCountByKind.
type ListAssetGroupMemberCountByKindParams struct {
	ObjectId        *ApiParamsPredicateFilterString `form:"object_id,omitempty" json:"object_id,omitempty"`
	EnvironmentId   *ApiParamsPredicateFilterString `form:"environment_id,omitempty" json:"environment_id,omitempty"`
	PrimaryKind     *ApiParamsPredicateFilterString `form:"primary_kind,omitempty" json:"primary_kind,omitempty"`
	EnvironmentKind *ApiParamsPredicateFilterString `form:"environment_kind,omitempty" json:"environment_kind,omitempty"`
	Name            *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	CustomMember    *ApiParamsPredicateFilterString `form:"custom_member,omitempty" json:"custom_member,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupSelectorsDeprecatedJSONBody defines parameters for UpdateAssetGroupSelectorsDeprecated.
type UpdateAssetGroupSelectorsDeprecatedJSONBody = []ModelAssetGroupSelectorSpec

// UpdateAssetGroupSelectorsDeprecatedParams defines parameters for UpdateAssetGroupSelectorsDeprecated.
type UpdateAssetGroupSelectorsDeprecatedParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupSelectorsJSONBody defines parameters for UpdateAssetGroupSelectors.
type UpdateAssetGroupSelectorsJSONBody = []ModelAssetGroupSelectorSpec

// UpdateAssetGroupSelectorsParams defines parameters for UpdateAssetGroupSelectors.
type UpdateAssetGroupSelectorsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAssetGroupSelectorParams defines parameters for DeleteAssetGroupSelector.
type DeleteAssetGroupSelectorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAttackPathTypesParams defines parameters for ListAttackPathTypes.
type ListAttackPathTypesParams struct {
	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy  *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding *ApiParamsPredicateFilterString `form:"finding,omitempty" json:"finding,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// StartAnalysisBheParams defines parameters for StartAnalysisBhe.
type StartAnalysisBheParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAttackPathRiskJSONBody defines parameters for UpdateAttackPathRisk.
type UpdateAttackPathRiskJSONBody struct {
	AcceptUntil *time.Time `json:"accept_until,omitempty"`
	Accepted    *bool      `json:"accepted,omitempty"`
	RiskType    *string    `json:"risk_type,omitempty"`
}

// UpdateAttackPathRiskParams defines parameters for UpdateAttackPathRisk.
type UpdateAttackPathRiskParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// SortBy Sortable columns are `id`, `actor_id`, `actor_name`, `actor_email`, `action`, `request_id`, `created_at`, `source`, and `status`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Before Return logs created before the specified time. Value should be in the RFC-3339 format. If not supplied, this will default to the current time.
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`

	// After Return logs created after the specified time. Value should be in the RFC-3339 format. If not supplied, this will default to 1 year before the current time.
	After      *time.Time                      `form:"after,omitempty" json:"after,omitempty"`
	Id         *ApiParamsPredicateFilterString `form:"id,omitempty" json:"id,omitempty"`
	ActorId    *ApiParamsPredicateFilterString `form:"actor_id,omitempty" json:"actor_id,omitempty"`
	ActorName  *ApiParamsPredicateFilterString `form:"actor_name,omitempty" json:"actor_name,omitempty"`
	ActorEmail *ApiParamsPredicateFilterString `form:"actor_email,omitempty" json:"actor_email,omitempty"`
	Action     *ApiParamsPredicateFilterString `form:"action,omitempty" json:"action,omitempty"`
	RequestId  *ApiParamsPredicateFilterString `form:"request_id,omitempty" json:"request_id,omitempty"`
	Source     *ApiParamsPredicateFilterString `form:"source,omitempty" json:"source,omitempty"`

	// Status Filter results by column value. Valid filter predicates are `eq`, `neq`. Valid values are `success` and `failure`.
	Status *ApiParamsPredicateFilterString `form:"status,omitempty" json:"status,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAvailableDomainsParams defines parameters for GetAvailableDomains.
type GetAvailableDomainsParams struct {
	// SortBy Sortable columns are objectid, name.
	SortBy    *ApiParamsPredicateFilterString `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Objectid  *ApiParamsPredicateFilterString `form:"objectid,omitempty" json:"objectid,omitempty"`
	Name      *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	Collected *ApiParamsPredicateFilterString `form:"collected,omitempty" json:"collected,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureTenantDataQualityStatsParams defines parameters for GetAzureTenantDataQualityStats.
type GetAzureTenantDataQualityStatsParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureEntityParams defines parameters for GetAzureEntity.
type GetAzureEntityParams struct {
	// ObjectId The object ID of the entity being operated on.
	ObjectId string `form:"object_id" json:"object_id"`

	// Counts Returns related entity counts. Does not work with `related_entity_type` parameter.
	Counts *bool `form:"counts,omitempty" json:"counts,omitempty"`

	// RelatedEntityType Flags the query to return related entity information based on the type passed.
	RelatedEntityType *string `form:"related_entity_type,omitempty" json:"related_entity_type,omitempty"`

	// Type The type of return data expected. Only works with `related_entity_type` parameter.
	Type *GetAzureEntityParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	// Only compatible with `related_entity_type` and `type=list`
	Skip *ApiParamsQuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	// Only compatible with `related_entity_type` and `type=list`
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureEntityParamsType defines parameters for GetAzureEntity.
type GetAzureEntityParamsType string

// GetEntityParams defines parameters for GetEntity.
type GetEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllablesParams defines parameters for GetEntityControllables.
type GetEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllablesParamsType defines parameters for GetEntityControllables.
type GetEntityControllablesParamsType string

// GetEntityControllersParams defines parameters for GetEntityControllers.
type GetEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllersParamsType defines parameters for GetEntityControllers.
type GetEntityControllersParamsType string

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// SortBy Sortable columns are first_name, last_name, email_address, principal_name, last_login, created_at, updated_at, deleted_at.
	SortBy        *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	FirstName     *ApiParamsPredicateFilterString `form:"first_name,omitempty" json:"first_name,omitempty"`
	LastName      *ApiParamsPredicateFilterString `form:"last_name,omitempty" json:"last_name,omitempty"`
	EmailAddress  *ApiParamsPredicateFilterString `form:"email_address,omitempty" json:"email_address,omitempty"`
	PrincipalName *ApiParamsPredicateFilterString `form:"principal_name,omitempty" json:"principal_name,omitempty"`
	Id            *ApiParamsPredicateFilterUuid   `form:"id,omitempty" json:"id,omitempty"`
	LastLogin     *ApiParamsPredicateFilterTime   `form:"last_login,omitempty" json:"last_login,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	EmailAddress       *openapi_types.Email `json:"email_address,omitempty"`
	FirstName          *string              `json:"first_name,omitempty"`
	IsDisabled         *bool                `json:"is_disabled,omitempty"`
	LastName           *string              `json:"last_name,omitempty"`
	NeedsPasswordReset *bool                `json:"needs_password_reset,omitempty"`
	Principal          *string              `json:"principal,omitempty"`
	Roles              *[]int32             `json:"roles,omitempty"`
	SamlProviderId     *string              `json:"saml_provider_id,omitempty"`
	Secret             *string              `json:"secret,omitempty"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateUserParams defines parameters for UpdateUser.
type UpdateUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// RemoveUserMfaJSONBody defines parameters for RemoveUserMfa.
type RemoveUserMfaJSONBody struct {
	Secret *string `json:"secret,omitempty"`
}

// RemoveUserMfaParams defines parameters for RemoveUserMfa.
type RemoveUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// AddUserMfaJSONBody defines parameters for AddUserMfa.
type AddUserMfaJSONBody struct {
	Secret *string `json:"secret,omitempty"`
}

// AddUserMfaParams defines parameters for AddUserMfa.
type AddUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetMfaActivationStatusParams defines parameters for GetMfaActivationStatus.
type GetMfaActivationStatusParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ActivateUserMfaJSONBody defines parameters for ActivateUserMfa.
type ActivateUserMfaJSONBody struct {
	Otp *string `json:"otp,omitempty"`
}

// ActivateUserMfaParams defines parameters for ActivateUserMfa.
type ActivateUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteUserSecretParams defines parameters for DeleteUserSecret.
type DeleteUserSecretParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateOrSetUserSecretParams defines parameters for CreateOrSetUserSecret.
type CreateOrSetUserSecretParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityParams defines parameters for GetCertTemplateEntity.
type GetCertTemplateEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityControllersParams defines parameters for GetCertTemplateEntityControllers.
type GetCertTemplateEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetCertTemplateEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityControllersParamsType defines parameters for GetCertTemplateEntityControllers.
type GetCertTemplateEntityControllersParamsType string

// DeleteBloodHoundDatabaseJSONBody defines parameters for DeleteBloodHoundDatabase.
type DeleteBloodHoundDatabaseJSONBody struct {
	DeleteAssetGroupSelectors *[]int `json:"deleteAssetGroupSelectors,omitempty"`
	DeleteCollectedGraphData  *bool  `json:"deleteCollectedGraphData,omitempty"`
	DeleteDataQualityHistory  *bool  `json:"deleteDataQualityHistory,omitempty"`
	DeleteFileIngestHistory   *bool  `json:"deleteFileIngestHistory,omitempty"`
}

// DeleteBloodHoundDatabaseParams defines parameters for DeleteBloodHoundDatabase.
type DeleteBloodHoundDatabaseParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientsParams defines parameters for ListClients.
type ListClientsParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `name`, `ip_address`, `hostname`, `configured_user`, `last_checkin`, `completed_job_count`, `created_at`, `updated_at`, `deleted_at`.
	SortBy            *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name              *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	IpAddress         *ApiParamsPredicateFilterString  `form:"ip_address,omitempty" json:"ip_address,omitempty"`
	Hostname          *ApiParamsPredicateFilterString  `form:"hostname,omitempty" json:"hostname,omitempty"`
	ConfiguredUser    *ApiParamsPredicateFilterString  `form:"configured_user,omitempty" json:"configured_user,omitempty"`
	Version           *ApiParamsPredicateFilterString  `form:"version,omitempty" json:"version,omitempty"`
	UserSid           *ApiParamsPredicateFilterString  `form:"user_sid,omitempty" json:"user_sid,omitempty"`
	LastCheckin       *ApiParamsPredicateFilterString  `form:"last_checkin,omitempty" json:"last_checkin,omitempty"`
	CurrentJobId      *ApiParamsPredicateFilterInteger `form:"current_job_id,omitempty" json:"current_job_id,omitempty"`
	CompletedJobCount *ApiParamsPredicateFilterInteger `form:"completed_job_count,omitempty" json:"completed_job_count,omitempty"`
	DomainController  *ApiParamsPredicateFilterString  `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Id                *ApiParamsPredicateFilterUuid    `form:"id,omitempty" json:"id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientJSONBody defines parameters for CreateClient.
type CreateClientJSONBody struct {
	DomainController *string                `json:"domain_controller,omitempty"`
	Events           *[]ModelClientSchedule `json:"events,omitempty"`
	Name             *string                `json:"name,omitempty"`

	// Type This enum describes the collector client type.
	Type *EnumClientType `json:"type,omitempty"`
}

// CreateClientParams defines parameters for CreateClient.
type CreateClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LogClientErrorJSONBody defines parameters for LogClientError.
type LogClientErrorJSONBody struct {
	Additional *map[string]string `json:"additional,omitempty"`
	TaskError  *string            `json:"task_error,omitempty"`
}

// LogClientErrorParams defines parameters for LogClientError.
type LogClientErrorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientInfoJSONBody defines parameters for UpdateClientInfo.
type UpdateClientInfoJSONBody struct {
	Address  *string `json:"address,omitempty"`
	Hostname *string `json:"hostname,omitempty"`
	Username *string `json:"username,omitempty"`
	Usersid  *string `json:"usersid,omitempty"`
	Version  *string `json:"version,omitempty"`
}

// UpdateClientInfoParams defines parameters for UpdateClientInfo.
type UpdateClientInfoParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteClientParams defines parameters for DeleteClient.
type DeleteClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientParams defines parameters for GetClient.
type GetClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientJSONBody defines parameters for UpdateClient.
type UpdateClientJSONBody struct {
	DomainController *string `json:"domain_controller,omitempty"`
	Name             *string `json:"name,omitempty"`
}

// UpdateClientParams defines parameters for UpdateClient.
type UpdateClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientCompletedJobsParams defines parameters for ListClientCompletedJobs.
type ListClientCompletedJobsParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientCompletedTasksParams defines parameters for ListClientCompletedTasks.
type ListClientCompletedTasksParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduledJobParams defines parameters for CreateClientScheduledJob.
type CreateClientScheduledJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduledTaskParams defines parameters for CreateClientScheduledTask.
type CreateClientScheduledTaskParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ReplaceClientTokenParams defines parameters for ReplaceClientToken.
type ReplaceClientTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCollectorManifestParams defines parameters for GetCollectorManifest.
type GetCollectorManifestParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DownloadCollectorParams defines parameters for DownloadCollector.
type DownloadCollectorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCollectorChecksumParams defines parameters for GetCollectorChecksum.
type GetCollectorChecksumParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCompletenessStatsParams defines parameters for GetCompletenessStats.
type GetCompletenessStatsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityParams defines parameters for GetComputerEntity.
type GetComputerEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminRightsParams defines parameters for GetComputerEntityAdminRights.
type GetComputerEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminRightsParamsType defines parameters for GetComputerEntityAdminRights.
type GetComputerEntityAdminRightsParamsType string

// GetComputerEntityAdminsParams defines parameters for GetComputerEntityAdmins.
type GetComputerEntityAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminsParamsType defines parameters for GetComputerEntityAdmins.
type GetComputerEntityAdminsParamsType string

// GetComputerEntityConstrainedDelegationRightsParams defines parameters for GetComputerEntityConstrainedDelegationRights.
type GetComputerEntityConstrainedDelegationRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityConstrainedDelegationRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityConstrainedDelegationRightsParamsType defines parameters for GetComputerEntityConstrainedDelegationRights.
type GetComputerEntityConstrainedDelegationRightsParamsType string

// GetComputerEntityConstrainedUsersParams defines parameters for GetComputerEntityConstrainedUsers.
type GetComputerEntityConstrainedUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityConstrainedUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityConstrainedUsersParamsType defines parameters for GetComputerEntityConstrainedUsers.
type GetComputerEntityConstrainedUsersParamsType string

// GetComputerEntityControllablesParams defines parameters for GetComputerEntityControllables.
type GetComputerEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityControllablesParamsType defines parameters for GetComputerEntityControllables.
type GetComputerEntityControllablesParamsType string

// GetComputerEntityControllersParams defines parameters for GetComputerEntityControllers.
type GetComputerEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityControllersParamsType defines parameters for GetComputerEntityControllers.
type GetComputerEntityControllersParamsType string

// GetComputerEntityDcomRightsParams defines parameters for GetComputerEntityDcomRights.
type GetComputerEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityDcomRightsParamsType defines parameters for GetComputerEntityDcomRights.
type GetComputerEntityDcomRightsParamsType string

// GetComputerEntityDcomUsersParams defines parameters for GetComputerEntityDcomUsers.
type GetComputerEntityDcomUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityDcomUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityDcomUsersParamsType defines parameters for GetComputerEntityDcomUsers.
type GetComputerEntityDcomUsersParamsType string

// GetComputerEntityGroupMembershipParams defines parameters for GetComputerEntityGroupMembership.
type GetComputerEntityGroupMembershipParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityGroupMembershipParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityGroupMembershipParamsType defines parameters for GetComputerEntityGroupMembership.
type GetComputerEntityGroupMembershipParamsType string

// GetComputerEntityPsRemoteRightsParams defines parameters for GetComputerEntityPsRemoteRights.
type GetComputerEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityPsRemoteRightsParamsType defines parameters for GetComputerEntityPsRemoteRights.
type GetComputerEntityPsRemoteRightsParamsType string

// GetComputerEntityPsRemoteUsersParams defines parameters for GetComputerEntityPsRemoteUsers.
type GetComputerEntityPsRemoteUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityPsRemoteUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityPsRemoteUsersParamsType defines parameters for GetComputerEntityPsRemoteUsers.
type GetComputerEntityPsRemoteUsersParamsType string

// GetComputerEntityRdpRightsParams defines parameters for GetComputerEntityRdpRights.
type GetComputerEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityRdpRightsParamsType defines parameters for GetComputerEntityRdpRights.
type GetComputerEntityRdpRightsParamsType string

// GetComputerEntityRdpUsersParams defines parameters for GetComputerEntityRdpUsers.
type GetComputerEntityRdpUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityRdpUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityRdpUsersParamsType defines parameters for GetComputerEntityRdpUsers.
type GetComputerEntityRdpUsersParamsType string

// GetComputerEntitySessionsParams defines parameters for GetComputerEntitySessions.
type GetComputerEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntitySessionsParamsType defines parameters for GetComputerEntitySessions.
type GetComputerEntitySessionsParamsType string

// GetComputerEntitySqlAdminsParams defines parameters for GetComputerEntitySqlAdmins.
type GetComputerEntitySqlAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntitySqlAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntitySqlAdminsParamsType defines parameters for GetComputerEntitySqlAdmins.
type GetComputerEntitySqlAdminsParamsType string

// ListAppConfigParamsParams defines parameters for ListAppConfigParams.
type ListAppConfigParamsParams struct {
	// Parameter Parameter filter. Must follow the convention: parameter=eq:value
	Parameter *string `form:"parameter,omitempty" json:"parameter,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// SetAppConfigParamParams defines parameters for SetAppConfigParam.
type SetAppConfigParamParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityParams defines parameters for GetContainerEntity.
type GetContainerEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityControllersParams defines parameters for GetContainerEntityControllers.
type GetContainerEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetContainerEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityControllersParamsType defines parameters for GetContainerEntityControllers.
type GetContainerEntityControllersParamsType string

// GetDatapipeStatusParams defines parameters for GetDatapipeStatus.
type GetDatapipeStatusParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ExportAttackPathFindingsParams defines parameters for ExportAttackPathFindings.
type ExportAttackPathFindingsParams struct {
	// Finding Finding Type
	Finding string `form:"finding" json:"finding"`

	// FilterAccepted Risk acceptance filter
	FilterAccepted *EnumRiskAcceptance `form:"filterAccepted,omitempty" json:"filterAccepted,omitempty"`

	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAvailableAttackPathTypesForDomainParams defines parameters for ListAvailableAttackPathTypesForDomain.
type ListAvailableAttackPathTypesForDomainParams struct {
	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy  *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding *ApiParamsPredicateFilterString `form:"finding,omitempty" json:"finding,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListDomainAttackPathsDetailsParams defines parameters for ListDomainAttackPathsDetails.
type ListDomainAttackPathsDetailsParams struct {

	// SortBy Sortable columns are `domain_sid`, `index`, `AcceptedUntil`, `id`, `created_at`, `updated_at`, `deleted_at`. Relationship risks can be sorted on `FromPrincipal` and `ToPrincipal` in addition to the sortable columns for List Risks.
	SortBy         *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	FromPrincipal  *ApiParamsPredicateFilterString  `form:"from_principal,omitempty" json:"from_principal,omitempty"`
	ToPrincipal    *ApiParamsPredicateFilterString  `form:"to_principal,omitempty" json:"to_principal,omitempty"`
	PrincipalsHash *ApiParamsPredicateFilterString  `form:"principals_hash,omitempty" json:"principals_hash,omitempty"`
	Accepted       *ApiParamsPredicateFilterString  `form:"Accepted,omitempty" json:"Accepted,omitempty"`
	AcceptedUntil  *ApiParamsPredicateFilterTime    `form:"accepted_until,omitempty" json:"accepted_until,omitempty"`
	Principal      *ApiParamsPredicateFilterString  `form:"Principal,omitempty" json:"Principal,omitempty"`
	Finding        *ApiParamsPredicateFilterString  `form:"Finding,omitempty" json:"Finding,omitempty"`
	DomainSid      *ApiParamsPredicateFilterString  `form:"domain_sid,omitempty" json:"domain_sid,omitempty"`
	Id             *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAttackPathSparklineValuesParams defines parameters for ListAttackPathSparklineValues.
type ListAttackPathSparklineValuesParams struct {
	// SortBy Sortable columns are `CompositeRisk`, `FindingCount`, `ImpactedAssetCount`, `domain_sid`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy  *ApiParamsQuerySortBy          `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding ApiParamsPredicateFilterString `form:"finding" json:"finding"`

	// From Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	From *ApiParamsPredicateFilterTime `form:"from,omitempty" json:"from,omitempty"`

	// To Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	To *ApiParamsPredicateFilterTime `form:"to,omitempty" json:"to,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityParams defines parameters for GetDomainEntity.
type GetDomainEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateDomainEntityJSONBody defines parameters for UpdateDomainEntity.
type UpdateDomainEntityJSONBody struct {
	Collected *bool `json:"collected,omitempty"`
}

// UpdateDomainEntityParams defines parameters for UpdateDomainEntity.
type UpdateDomainEntityParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityComputersParams defines parameters for GetDomainEntityComputers.
type GetDomainEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityComputersParamsType defines parameters for GetDomainEntityComputers.
type GetDomainEntityComputersParamsType string

// GetDomainEntityControllersParams defines parameters for GetDomainEntityControllers.
type GetDomainEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityControllersParamsType defines parameters for GetDomainEntityControllers.
type GetDomainEntityControllersParamsType string

// GetDomainEntityDcSyncersParams defines parameters for GetDomainEntityDcSyncers.
type GetDomainEntityDcSyncersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityDcSyncersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityDcSyncersParamsType defines parameters for GetDomainEntityDcSyncers.
type GetDomainEntityDcSyncersParamsType string

// GetDomainEntityForeignAdminsParams defines parameters for GetDomainEntityForeignAdmins.
type GetDomainEntityForeignAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignAdminsParamsType defines parameters for GetDomainEntityForeignAdmins.
type GetDomainEntityForeignAdminsParamsType string

// GetDomainEntityForeignGpoControllersParams defines parameters for GetDomainEntityForeignGpoControllers.
type GetDomainEntityForeignGpoControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignGpoControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignGpoControllersParamsType defines parameters for GetDomainEntityForeignGpoControllers.
type GetDomainEntityForeignGpoControllersParamsType string

// GetDomainEntityForeignGroupsParams defines parameters for GetDomainEntityForeignGroups.
type GetDomainEntityForeignGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignGroupsParamsType defines parameters for GetDomainEntityForeignGroups.
type GetDomainEntityForeignGroupsParamsType string

// GetDomainEntityForeignUsersParams defines parameters for GetDomainEntityForeignUsers.
type GetDomainEntityForeignUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignUsersParamsType defines parameters for GetDomainEntityForeignUsers.
type GetDomainEntityForeignUsersParamsType string

// GetDomainEntityGposParams defines parameters for GetDomainEntityGpos.
type GetDomainEntityGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityGposParamsType defines parameters for GetDomainEntityGpos.
type GetDomainEntityGposParamsType string

// GetDomainEntityGroupsParams defines parameters for GetDomainEntityGroups.
type GetDomainEntityGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityGroupsParamsType defines parameters for GetDomainEntityGroups.
type GetDomainEntityGroupsParamsType string

// GetDomainEntityInboundTrustsParams defines parameters for GetDomainEntityInboundTrusts.
type GetDomainEntityInboundTrustsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityInboundTrustsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityInboundTrustsParamsType defines parameters for GetDomainEntityInboundTrusts.
type GetDomainEntityInboundTrustsParamsType string

// GetDomainEntityLinkedGposParams defines parameters for GetDomainEntityLinkedGpos.
type GetDomainEntityLinkedGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityLinkedGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityLinkedGposParamsType defines parameters for GetDomainEntityLinkedGpos.
type GetDomainEntityLinkedGposParamsType string

// GetDomainEntityOusParams defines parameters for GetDomainEntityOus.
type GetDomainEntityOusParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityOusParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityOusParamsType defines parameters for GetDomainEntityOus.
type GetDomainEntityOusParamsType string

// GetDomainEntityOutboundTrustsParams defines parameters for GetDomainEntityOutboundTrusts.
type GetDomainEntityOutboundTrustsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityOutboundTrustsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityOutboundTrustsParamsType defines parameters for GetDomainEntityOutboundTrusts.
type GetDomainEntityOutboundTrustsParamsType string

// GetDomainEntityUsersParams defines parameters for GetDomainEntityUsers.
type GetDomainEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityUsersParamsType defines parameters for GetDomainEntityUsers.
type GetDomainEntityUsersParamsType string

// GetEnterpriseCaEntityParams defines parameters for GetEnterpriseCaEntity.
type GetEnterpriseCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEnterpriseCaEntityControllersParams defines parameters for GetEnterpriseCaEntityControllers.
type GetEnterpriseCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEnterpriseCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEnterpriseCaEntityControllersParamsType defines parameters for GetEnterpriseCaEntityControllers.
type GetEnterpriseCaEntityControllersParamsType string

// ListClientSchedulesParams defines parameters for ListClientSchedules.
type ListClientSchedulesParams struct {
	// SortBy Sortable columns are `next_scheduled_at`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	Rrule                  *ApiParamsPredicateFilterString        `form:"rrule,omitempty" json:"rrule,omitempty"`
	NextScheduledAt        *ApiParamsPredicateFilterTime          `form:"next_scheduled_at,omitempty" json:"next_scheduled_at,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduleParams defines parameters for CreateClientSchedule.
type CreateClientScheduleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteClientEventParams defines parameters for DeleteClientEvent.
type DeleteClientEventParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientScheduleParams defines parameters for GetClientSchedule.
type GetClientScheduleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientEventParams defines parameters for UpdateClientEvent.
type UpdateClientEventParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListFeatureFlagsParams defines parameters for ListFeatureFlags.
type ListFeatureFlagsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ToggleFeatureFlagParams defines parameters for ToggleFeatureFlag.
type ToggleFeatureFlagParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListFileUploadJobsParams defines parameters for ListFileUploadJobs.
type ListFileUploadJobsParams struct {
	// SortBy Sortable columns are `user_email_address`, `status`, `status_message`, `start_time`, `end_time`, `last_ingest`, `id`, `created_at`, `updated_at`, and `deleted_at`.
	SortBy           *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	UserId           *ApiParamsPredicateFilterString  `form:"user_id,omitempty" json:"user_id,omitempty"`
	UserEmailAddress *ApiParamsPredicateFilterString  `form:"user_email_address,omitempty" json:"user_email_address,omitempty"`
	Status           *ApiParamsPredicateFilterInteger `form:"status,omitempty" json:"status,omitempty"`
	StatusMessage    *ApiParamsPredicateFilterString  `form:"status_message,omitempty" json:"status_message,omitempty"`
	StartTime        *ApiParamsPredicateFilterTime    `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime          *ApiParamsPredicateFilterTime    `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest       *ApiParamsPredicateFilterTime    `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`
	Id               *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAcceptedFileUploadTypesParams defines parameters for ListAcceptedFileUploadTypes.
type ListAcceptedFileUploadTypesParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateFileUploadJobParams defines parameters for CreateFileUploadJob.
type CreateFileUploadJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UploadFileToJobJSONBody defines parameters for UploadFileToJob.
type UploadFileToJobJSONBody = map[string]interface{}

// UploadFileToJobParams defines parameters for UploadFileToJob.
type UploadFileToJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`

	// ContentType Content type header, used to specify the type of content being sent by the client.
	ContentType string `json:"Content-Type"`
}

// EndFileUploadJobParams defines parameters for EndFileUploadJob.
type EndFileUploadJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityParams defines parameters for GetGpoEntity.
type GetGpoEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityComputersParams defines parameters for GetGpoEntityComputers.
type GetGpoEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityComputersParamsType defines parameters for GetGpoEntityComputers.
type GetGpoEntityComputersParamsType string

// GetGpoEntityControllersParams defines parameters for GetGpoEntityControllers.
type GetGpoEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityControllersParamsType defines parameters for GetGpoEntityControllers.
type GetGpoEntityControllersParamsType string

// GetGpoEntityOusParams defines parameters for GetGpoEntityOus.
type GetGpoEntityOusParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityOusParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityOusParamsType defines parameters for GetGpoEntityOus.
type GetGpoEntityOusParamsType string

// GetGpoEntityTierZeroParams defines parameters for GetGpoEntityTierZero.
type GetGpoEntityTierZeroParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityTierZeroParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityTierZeroParamsType defines parameters for GetGpoEntityTierZero.
type GetGpoEntityTierZeroParamsType string

// GetGpoEntityUsersParams defines parameters for GetGpoEntityUsers.
type GetGpoEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityUsersParamsType defines parameters for GetGpoEntityUsers.
type GetGpoEntityUsersParamsType string

// GetSearchResultParams defines parameters for GetSearchResult.
type GetSearchResultParams struct {
	// SearchQuery Search query
	SearchQuery string `form:"search_query" json:"search_query"`

	// Type The type of search strategy to use. Default is `fuzzy`.
	Type *GetSearchResultParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSearchResultParamsType defines parameters for GetSearchResult.
type GetSearchResultParamsType string

// RunCypherQueryJSONBody defines parameters for RunCypherQuery.
type RunCypherQueryJSONBody struct {
	IncludeProperties *bool   `json:"include_properties,omitempty"`
	Query             *string `json:"query,omitempty"`
}

// RunCypherQueryParams defines parameters for RunCypherQuery.
type RunCypherQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPathCompositionParams defines parameters for GetPathComposition.
type GetPathCompositionParams struct {
	// SourceNode The ID of the starting node.
	SourceNode int32 `form:"source_node" json:"source_node"`

	// TargetNode The ID of the ending node.
	TargetNode int32 `form:"target_node" json:"target_node"`

	// EdgeType The type of edge to show the composition for.
	EdgeType string `form:"edge_type" json:"edge_type"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetShortestPathParams defines parameters for GetShortestPath.
type GetShortestPathParams struct {
	// StartNode The start node objectId
	StartNode int32 `form:"start_node" json:"start_node"`

	// EndNode The end node objectId
	EndNode           int32                             `form:"end_node" json:"end_node"`
	RelationshipKinds *ApiParamsPredicateFilterContains `form:"relationship_kinds,omitempty" json:"relationship_kinds,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityParams defines parameters for GetGroupEntity.
type GetGroupEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityAdminRightsParams defines parameters for GetGroupEntityAdminRights.
type GetGroupEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityAdminRightsParamsType defines parameters for GetGroupEntityAdminRights.
type GetGroupEntityAdminRightsParamsType string

// GetGroupEntityControllablesParams defines parameters for GetGroupEntityControllables.
type GetGroupEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityControllablesParamsType defines parameters for GetGroupEntityControllables.
type GetGroupEntityControllablesParamsType string

// GetGroupEntityControllersParams defines parameters for GetGroupEntityControllers.
type GetGroupEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityControllersParamsType defines parameters for GetGroupEntityControllers.
type GetGroupEntityControllersParamsType string

// GetGroupEntityDcomRightsParams defines parameters for GetGroupEntityDcomRights.
type GetGroupEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityDcomRightsParamsType defines parameters for GetGroupEntityDcomRights.
type GetGroupEntityDcomRightsParamsType string

// GetGroupEntityMembersParams defines parameters for GetGroupEntityMembers.
type GetGroupEntityMembersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityMembersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityMembersParamsType defines parameters for GetGroupEntityMembers.
type GetGroupEntityMembersParamsType string

// GetGroupEntityMembershipsParams defines parameters for GetGroupEntityMemberships.
type GetGroupEntityMembershipsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityMembershipsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityMembershipsParamsType defines parameters for GetGroupEntityMemberships.
type GetGroupEntityMembershipsParamsType string

// GetGroupEntityPsRemoteRightsParams defines parameters for GetGroupEntityPsRemoteRights.
type GetGroupEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityPsRemoteRightsParamsType defines parameters for GetGroupEntityPsRemoteRights.
type GetGroupEntityPsRemoteRightsParamsType string

// GetGroupEntityRdpRightsParams defines parameters for GetGroupEntityRdpRights.
type GetGroupEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityRdpRightsParamsType defines parameters for GetGroupEntityRdpRights.
type GetGroupEntityRdpRightsParamsType string

// GetGroupEntitySessionsParams defines parameters for GetGroupEntitySessions.
type GetGroupEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntitySessionsParamsType defines parameters for GetGroupEntitySessions.
type GetGroupEntitySessionsParamsType string

// IngestDataParams defines parameters for IngestData.
type IngestDataParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobsParams defines parameters for GetClientJobs.
type GetClientJobsParams struct {
	// SortBy Sortable columns are `client_name`, `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAvailableClientJobsParams defines parameters for ListAvailableClientJobs.
type ListAvailableClientJobsParams struct {
	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, and `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientCurrentJobParams defines parameters for GetClientCurrentJob.
type GetClientCurrentJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// EndClientJobParams defines parameters for EndClientJob.
type EndClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientFinishedJobsParams defines parameters for ListClientFinishedJobs.
type ListClientFinishedJobsParams struct {
	// SortBy Sortable columns are `client_name`, `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// StartClientJobJSONBody defines parameters for StartClientJob.
type StartClientJobJSONBody struct {
	Id *int64 `json:"id,omitempty"`
}

// StartClientJobParams defines parameters for StartClientJob.
type StartClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobParams defines parameters for GetClientJob.
type GetClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CancelClientJobParams defines parameters for CancelClientJob.
type CancelClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobLogParams defines parameters for GetClientJobLog.
type GetClientJobLogParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	// LoginMethod The type of login. Currently only `secret` is supported.
	LoginMethod LoginJSONBodyLoginMethod `json:"login_method"`

	// Otp The One Time Password for a single login. This field can be used instead of `secret`
	Otp *string `json:"otp,omitempty"`

	// Secret The password for the user. This field can be used instead of `otp`.
	Secret   *string `json:"secret,omitempty"`
	Username string  `json:"username"`
}

// LoginParams defines parameters for Login.
type LoginParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LoginJSONBodyLoginMethod defines parameters for Login.
type LoginJSONBodyLoginMethod string

// LogoutParams defines parameters for Logout.
type LogoutParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetLatestTierZeroComboNodeParams defines parameters for GetLatestTierZeroComboNode.
type GetLatestTierZeroComboNodeParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComboTreeGraphParams defines parameters for GetComboTreeGraph.
type GetComboTreeGraphParams struct {
	// NodeId Node ID
	NodeId *int64 `form:"node_id,omitempty" json:"node_id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetMetaEntityParams defines parameters for GetMetaEntity.
type GetMetaEntityParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityParams defines parameters for GetNtAuthStoreEntity.
type GetNtAuthStoreEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityControllersParams defines parameters for GetNtAuthStoreEntityControllers.
type GetNtAuthStoreEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetNtAuthStoreEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityControllersParamsType defines parameters for GetNtAuthStoreEntityControllers.
type GetNtAuthStoreEntityControllersParamsType string

// GetOuEntityParams defines parameters for GetOuEntity.
type GetOuEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityComputersParams defines parameters for GetOuEntityComputers.
type GetOuEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityComputersParamsType defines parameters for GetOuEntityComputers.
type GetOuEntityComputersParamsType string

// GetOuEntityGposParams defines parameters for GetOuEntityGpos.
type GetOuEntityGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityGposParamsType defines parameters for GetOuEntityGpos.
type GetOuEntityGposParamsType string

// GetOuEntityGroupsParams defines parameters for GetOuEntityGroups.
type GetOuEntityGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityGroupsParamsType defines parameters for GetOuEntityGroups.
type GetOuEntityGroupsParamsType string

// GetOuEntityUsersParams defines parameters for GetOuEntityUsers.
type GetOuEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityUsersParamsType defines parameters for GetOuEntityUsers.
type GetOuEntityUsersParamsType string

// PathfindingParams defines parameters for Pathfinding.
type PathfindingParams struct {
	// StartNode Start Node
	StartNode string `form:"start_node" json:"start_node"`

	// EndNode End Node
	EndNode string `form:"end_node" json:"end_node"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListPermissionsParams defines parameters for ListPermissions.
type ListPermissionsParams struct {
	// SortBy Sortable columns are `authority`, `name`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy    *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Authority *ApiParamsPredicateFilterString  `form:"authority,omitempty" json:"authority,omitempty"`
	Name      *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Id        *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPermissionParams defines parameters for GetPermission.
type GetPermissionParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPlatformDataQualityAggregateParams defines parameters for GetPlatformDataQualityAggregate.
type GetPlatformDataQualityAggregateParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPostureStatsParams defines parameters for GetPostureStats.
type GetPostureStatsParams struct {
	// SortBy Sortable columns are `domain_sid`, `exposure_index`, `tier_zero_count`, `critical_risk_count`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// From Lower bound for created_at; to return posture stats starting at a specific date/time
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To Upper bound for created_at; to return posture stats upto a specific date/time
	To                *time.Time                       `form:"to,omitempty" json:"to,omitempty"`
	DomainSid         *ApiParamsPredicateFilterString  `form:"domain_sid,omitempty" json:"domain_sid,omitempty"`
	ExposureIndex     *ApiParamsPredicateFilterInteger `form:"exposure_index,omitempty" json:"exposure_index,omitempty"`
	TierZeroCount     *ApiParamsPredicateFilterInteger `form:"tier_zero_count,omitempty" json:"tier_zero_count,omitempty"`
	CriticalRiskCount *ApiParamsPredicateFilterInteger `form:"critical_risk_count,omitempty" json:"critical_risk_count,omitempty"`
	Id                *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {
	// SortBy Sortable columns are `name`, `description`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name   *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Id     *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRoleParams defines parameters for GetRole.
type GetRoleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityParams defines parameters for GetRootCaEntity.
type GetRootCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityControllersParams defines parameters for GetRootCaEntityControllers.
type GetRootCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetRootCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityControllersParamsType defines parameters for GetRootCaEntityControllers.
type GetRootCaEntityControllersParamsType string

// ListSamlProvidersParams defines parameters for ListSamlProviders.
type ListSamlProvidersParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateSamlProviderMultipartBody defines parameters for CreateSamlProvider.
type CreateSamlProviderMultipartBody struct {
	// Metadata Metadata XML file.
	Metadata *openapi_types.File `json:"metadata,omitempty"`

	// Name Name of the new SAML provider.
	Name *string `json:"name,omitempty"`
}

// DeleteSamlProviderParams defines parameters for DeleteSamlProvider.
type DeleteSamlProviderParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSamlProviderParams defines parameters for GetSamlProvider.
type GetSamlProviderParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSamlSignSignOnEndpointsParams defines parameters for GetSamlSignSignOnEndpoints.
type GetSamlSignSignOnEndpointsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListSavedQueriesParams defines parameters for ListSavedQueries.
type ListSavedQueriesParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are user_id, name, query, id, created_at, updated_at, deleted_at.
	SortBy *ApiParamsQuerySortBy             `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name   *ApiParamsPredicateFilterString   `form:"name,omitempty" json:"name,omitempty"`
	Query  *ApiParamsPredicateFilterString   `form:"query,omitempty" json:"query,omitempty"`
	UserId *ApiParamsPredicateFilterString   `form:"user_id,omitempty" json:"user_id,omitempty"`
	Scope  *ApiParamsPredicateFilterContains `form:"scope,omitempty" json:"scope,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateSavedQueryParams defines parameters for CreateSavedQuery.
type CreateSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteSavedQueryParams defines parameters for DeleteSavedQuery.
type DeleteSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateSavedQueryParams defines parameters for UpdateSavedQuery.
type UpdateSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteSavedQueryPermissionsJSONBody defines parameters for DeleteSavedQueryPermissions.
type DeleteSavedQueryPermissionsJSONBody struct {
	// UserIds A list of user ids that will have their permission revoked from the given saved query
	UserIds *[]openapi_types.UUID `json:"user_ids,omitempty"`
}

// DeleteSavedQueryPermissionsParams defines parameters for DeleteSavedQueryPermissions.
type DeleteSavedQueryPermissionsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Q Search parameter for the name or object ID of a node.
	Q string `form:"q" json:"q"`

	// Type Node type.
	// Some AD examples: `Base`, `User`, `Computer`, `Group`, `Container`.
	// Some Azure examples: `AZBase`, `AZApp`, `AZDevice`.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSelfParams defines parameters for GetSelf.
type GetSelfParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetApiSpecParams defines parameters for GetApiSpec.
type GetApiSpecParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAuthTokensParams defines parameters for ListAuthTokens.
type ListAuthTokensParams struct {
	// UserId Provide a user id to filter tokens by. This filter is only honored for Admin users.
	UserId *ApiParamsPredicateFilterUuid `form:"user_id,omitempty" json:"user_id,omitempty"`

	// SortBy Sortable columns are `user_id`, `client_id`, `name`, `last_access`, `created_at`, `updated_at`, `deleted_at`.
	SortBy     *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name       *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	Key        *ApiParamsPredicateFilterString `form:"key,omitempty" json:"key,omitempty"`
	HmacMethod *ApiParamsPredicateFilterString `form:"hmac_method,omitempty" json:"hmac_method,omitempty"`
	LastAccess *ApiParamsPredicateFilterTime   `form:"last_access,omitempty" json:"last_access,omitempty"`
	Id         *ApiParamsPredicateFilterUuid   `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAuthTokenJSONBody defines parameters for CreateAuthToken.
type CreateAuthTokenJSONBody struct {
	TokenName *string             `json:"token_name,omitempty"`
	UserId    *openapi_types.UUID `json:"user_id,omitempty"`
}

// CreateAuthTokenParams defines parameters for CreateAuthToken.
type CreateAuthTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAuthTokenParams defines parameters for DeleteAuthToken.
type DeleteAuthTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityParams defines parameters for GetUserEntity.
type GetUserEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityAdminRightsParams defines parameters for GetUserEntityAdminRights.
type GetUserEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityAdminRightsParamsType defines parameters for GetUserEntityAdminRights.
type GetUserEntityAdminRightsParamsType string

// GetUserEntityConstrainedDelegationRightsParams defines parameters for GetUserEntityConstrainedDelegationRights.
type GetUserEntityConstrainedDelegationRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityConstrainedDelegationRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityConstrainedDelegationRightsParamsType defines parameters for GetUserEntityConstrainedDelegationRights.
type GetUserEntityConstrainedDelegationRightsParamsType string

// GetUserEntityControllablesParams defines parameters for GetUserEntityControllables.
type GetUserEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityControllablesParamsType defines parameters for GetUserEntityControllables.
type GetUserEntityControllablesParamsType string

// GetUserEntityControllersParams defines parameters for GetUserEntityControllers.
type GetUserEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityControllersParamsType defines parameters for GetUserEntityControllers.
type GetUserEntityControllersParamsType string

// GetUserEntityDcomRightsParams defines parameters for GetUserEntityDcomRights.
type GetUserEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityDcomRightsParamsType defines parameters for GetUserEntityDcomRights.
type GetUserEntityDcomRightsParamsType string

// GetUserEntityMembershipParams defines parameters for GetUserEntityMembership.
type GetUserEntityMembershipParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityMembershipParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityMembershipParamsType defines parameters for GetUserEntityMembership.
type GetUserEntityMembershipParamsType string

// GetUserEntityPsRemoteRightsParams defines parameters for GetUserEntityPsRemoteRights.
type GetUserEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityPsRemoteRightsParamsType defines parameters for GetUserEntityPsRemoteRights.
type GetUserEntityPsRemoteRightsParamsType string

// GetUserEntityRdpRightsParams defines parameters for GetUserEntityRdpRights.
type GetUserEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityRdpRightsParamsType defines parameters for GetUserEntityRdpRights.
type GetUserEntityRdpRightsParamsType string

// GetUserEntitySessionsParams defines parameters for GetUserEntitySessions.
type GetUserEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntitySessionsParamsType defines parameters for GetUserEntitySessions.
type GetUserEntitySessionsParamsType string

// GetUserEntitySqlAdminRightsParams defines parameters for GetUserEntitySqlAdminRights.
type GetUserEntitySqlAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntitySqlAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntitySqlAdminRightsParamsType defines parameters for GetUserEntitySqlAdminRights.
type GetUserEntitySqlAdminRightsParamsType string

// GetApiVersionParams defines parameters for GetApiVersion.
type GetApiVersionParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAssetGroupJSONRequestBody defines body for CreateAssetGroup for application/json ContentType.
type CreateAssetGroupJSONRequestBody = ModelAssetGroup

// UpdateAssetGroupJSONRequestBody defines body for UpdateAssetGroup for application/json ContentType.
type UpdateAssetGroupJSONRequestBody UpdateAssetGroupJSONBody

// UpdateAssetGroupSelectorsDeprecatedJSONRequestBody defines body for UpdateAssetGroupSelectorsDeprecated for application/json ContentType.
type UpdateAssetGroupSelectorsDeprecatedJSONRequestBody = UpdateAssetGroupSelectorsDeprecatedJSONBody

// UpdateAssetGroupSelectorsJSONRequestBody defines body for UpdateAssetGroupSelectors for application/json ContentType.
type UpdateAssetGroupSelectorsJSONRequestBody = UpdateAssetGroupSelectorsJSONBody

// UpdateAttackPathRiskJSONRequestBody defines body for UpdateAttackPathRisk for application/json ContentType.
type UpdateAttackPathRiskJSONRequestBody UpdateAttackPathRiskJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = ApiRequestsUserUpdate

// RemoveUserMfaJSONRequestBody defines body for RemoveUserMfa for application/json ContentType.
type RemoveUserMfaJSONRequestBody RemoveUserMfaJSONBody

// AddUserMfaJSONRequestBody defines body for AddUserMfa for application/json ContentType.
type AddUserMfaJSONRequestBody AddUserMfaJSONBody

// ActivateUserMfaJSONRequestBody defines body for ActivateUserMfa for application/json ContentType.
type ActivateUserMfaJSONRequestBody ActivateUserMfaJSONBody

// CreateOrSetUserSecretJSONRequestBody defines body for CreateOrSetUserSecret for application/json ContentType.
type CreateOrSetUserSecretJSONRequestBody = ApiRequestsUserSetSecret

// DeleteBloodHoundDatabaseJSONRequestBody defines body for DeleteBloodHoundDatabase for application/json ContentType.
type DeleteBloodHoundDatabaseJSONRequestBody DeleteBloodHoundDatabaseJSONBody

// CreateClientJSONRequestBody defines body for CreateClient for application/json ContentType.
type CreateClientJSONRequestBody CreateClientJSONBody

// LogClientErrorJSONRequestBody defines body for LogClientError for application/json ContentType.
type LogClientErrorJSONRequestBody LogClientErrorJSONBody

// UpdateClientInfoJSONRequestBody defines body for UpdateClientInfo for application/json ContentType.
type UpdateClientInfoJSONRequestBody UpdateClientInfoJSONBody

// UpdateClientJSONRequestBody defines body for UpdateClient for application/json ContentType.
type UpdateClientJSONRequestBody UpdateClientJSONBody

// CreateClientScheduledJobJSONRequestBody defines body for CreateClientScheduledJob for application/json ContentType.
type CreateClientScheduledJobJSONRequestBody = ModelClientScheduledJob

// CreateClientScheduledTaskJSONRequestBody defines body for CreateClientScheduledTask for application/json ContentType.
type CreateClientScheduledTaskJSONRequestBody = ModelClientScheduledJob

// SetAppConfigParamJSONRequestBody defines body for SetAppConfigParam for application/json ContentType.
type SetAppConfigParamJSONRequestBody = ModelAppConfigParam

// UpdateDomainEntityJSONRequestBody defines body for UpdateDomainEntity for application/json ContentType.
type UpdateDomainEntityJSONRequestBody UpdateDomainEntityJSONBody

// CreateClientScheduleJSONRequestBody defines body for CreateClientSchedule for application/json ContentType.
type CreateClientScheduleJSONRequestBody = ModelClientSchedule

// UpdateClientEventJSONRequestBody defines body for UpdateClientEvent for application/json ContentType.
type UpdateClientEventJSONRequestBody = ModelClientSchedule

// UploadFileToJobJSONRequestBody defines body for UploadFileToJob for application/json ContentType.
type UploadFileToJobJSONRequestBody = UploadFileToJobJSONBody

// RunCypherQueryJSONRequestBody defines body for RunCypherQuery for application/json ContentType.
type RunCypherQueryJSONRequestBody RunCypherQueryJSONBody

// StartClientJobJSONRequestBody defines body for StartClientJob for application/json ContentType.
type StartClientJobJSONRequestBody StartClientJobJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreateSamlProviderMultipartRequestBody defines body for CreateSamlProvider for multipart/form-data ContentType.
type CreateSamlProviderMultipartRequestBody CreateSamlProviderMultipartBody

// CreateSavedQueryJSONRequestBody defines body for CreateSavedQuery for application/json ContentType.
type CreateSavedQueryJSONRequestBody = ModelSavedQuery

// UpdateSavedQueryJSONRequestBody defines body for UpdateSavedQuery for application/json ContentType.
type UpdateSavedQueryJSONRequestBody = ModelSavedQuery

// DeleteSavedQueryPermissionsJSONRequestBody defines body for DeleteSavedQueryPermissions for application/json ContentType.
type DeleteSavedQueryPermissionsJSONRequestBody DeleteSavedQueryPermissionsJSONBody

// CreateAuthTokenJSONRequestBody defines body for CreateAuthToken for application/json ContentType.
type CreateAuthTokenJSONRequestBody CreateAuthTokenJSONBody

// AsModelUser returns the union data inside the ApiResponseAuthenticatedRequester_Data as a ModelUser
func (t ApiResponseAuthenticatedRequester_Data) AsModelUser() (ModelUser, error) {
	var body ModelUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelUser overwrites any union data inside the ApiResponseAuthenticatedRequester_Data as the provided ModelUser
func (t *ApiResponseAuthenticatedRequester_Data) FromModelUser(v ModelUser) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelUser performs a merge with any union data inside the ApiResponseAuthenticatedRequester_Data, using the provided ModelUser
func (t *ApiResponseAuthenticatedRequester_Data) MergeModelUser(v ModelUser) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelClient returns the union data inside the ApiResponseAuthenticatedRequester_Data as a ModelClient
func (t ApiResponseAuthenticatedRequester_Data) AsModelClient() (ModelClient, error) {
	var body ModelClient
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelClient overwrites any union data inside the ApiResponseAuthenticatedRequester_Data as the provided ModelClient
func (t *ApiResponseAuthenticatedRequester_Data) FromModelClient(v ModelClient) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelClient performs a merge with any union data inside the ApiResponseAuthenticatedRequester_Data, using the provided ModelClient
func (t *ApiResponseAuthenticatedRequester_Data) MergeModelClient(v ModelClient) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseAuthenticatedRequester_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseAuthenticatedRequester_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelAdDataQualityAggregation returns the union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item as a ModelAdDataQualityAggregation
func (t ApiResponseDataQualityPlatformAggregate_Data_Data_Item) AsModelAdDataQualityAggregation() (ModelAdDataQualityAggregation, error) {
	var body ModelAdDataQualityAggregation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelAdDataQualityAggregation overwrites any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item as the provided ModelAdDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) FromModelAdDataQualityAggregation(v ModelAdDataQualityAggregation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelAdDataQualityAggregation performs a merge with any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item, using the provided ModelAdDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) MergeModelAdDataQualityAggregation(v ModelAdDataQualityAggregation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelAzureDataQualityAggregation returns the union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item as a ModelAzureDataQualityAggregation
func (t ApiResponseDataQualityPlatformAggregate_Data_Data_Item) AsModelAzureDataQualityAggregation() (ModelAzureDataQualityAggregation, error) {
	var body ModelAzureDataQualityAggregation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelAzureDataQualityAggregation overwrites any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item as the provided ModelAzureDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) FromModelAzureDataQualityAggregation(v ModelAzureDataQualityAggregation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelAzureDataQualityAggregation performs a merge with any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item, using the provided ModelAzureDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) MergeModelAzureDataQualityAggregation(v ModelAzureDataQualityAggregation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseDataQualityPlatformAggregate_Data_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelListFinding returns the union data inside the ApiResponseFinding_Data as a ModelListFinding
func (t ApiResponseFinding_Data) AsModelListFinding() (ModelListFinding, error) {
	var body ModelListFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelListFinding overwrites any union data inside the ApiResponseFinding_Data as the provided ModelListFinding
func (t *ApiResponseFinding_Data) FromModelListFinding(v ModelListFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelListFinding performs a merge with any union data inside the ApiResponseFinding_Data, using the provided ModelListFinding
func (t *ApiResponseFinding_Data) MergeModelListFinding(v ModelListFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelRelationshipFinding returns the union data inside the ApiResponseFinding_Data as a ModelRelationshipFinding
func (t ApiResponseFinding_Data) AsModelRelationshipFinding() (ModelRelationshipFinding, error) {
	var body ModelRelationshipFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelRelationshipFinding overwrites any union data inside the ApiResponseFinding_Data as the provided ModelRelationshipFinding
func (t *ApiResponseFinding_Data) FromModelRelationshipFinding(v ModelRelationshipFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelRelationshipFinding performs a merge with any union data inside the ApiResponseFinding_Data, using the provided ModelRelationshipFinding
func (t *ApiResponseFinding_Data) MergeModelRelationshipFinding(v ModelRelationshipFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseFinding_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseFinding_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelBhGraphNode returns the union data inside the ModelBhGraphGraph_AdditionalProperties as a ModelBhGraphNode
func (t ModelBhGraphGraph_AdditionalProperties) AsModelBhGraphNode() (ModelBhGraphNode, error) {
	var body ModelBhGraphNode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelBhGraphNode overwrites any union data inside the ModelBhGraphGraph_AdditionalProperties as the provided ModelBhGraphNode
func (t *ModelBhGraphGraph_AdditionalProperties) FromModelBhGraphNode(v ModelBhGraphNode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelBhGraphNode performs a merge with any union data inside the ModelBhGraphGraph_AdditionalProperties, using the provided ModelBhGraphNode
func (t *ModelBhGraphGraph_AdditionalProperties) MergeModelBhGraphNode(v ModelBhGraphNode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelBhGraphEdge returns the union data inside the ModelBhGraphGraph_AdditionalProperties as a ModelBhGraphEdge
func (t ModelBhGraphGraph_AdditionalProperties) AsModelBhGraphEdge() (ModelBhGraphEdge, error) {
	var body ModelBhGraphEdge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelBhGraphEdge overwrites any union data inside the ModelBhGraphGraph_AdditionalProperties as the provided ModelBhGraphEdge
func (t *ModelBhGraphGraph_AdditionalProperties) FromModelBhGraphEdge(v ModelBhGraphEdge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelBhGraphEdge performs a merge with any union data inside the ModelBhGraphGraph_AdditionalProperties, using the provided ModelBhGraphEdge
func (t *ModelBhGraphGraph_AdditionalProperties) MergeModelBhGraphEdge(v ModelBhGraphEdge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModelBhGraphGraph_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModelBhGraphGraph_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelatedEntityQueryResults returns the union data inside the RelatedEntityQueryResults as a RelatedEntityQueryResults
func (t RelatedEntityQueryResults) AsRelatedEntityQueryResults() (RelatedEntityQueryResults, error) {
	var body RelatedEntityQueryResults
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelatedEntityQueryResults overwrites any union data inside the RelatedEntityQueryResults as the provided RelatedEntityQueryResults
func (t *RelatedEntityQueryResults) FromRelatedEntityQueryResults(v RelatedEntityQueryResults) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelatedEntityQueryResults performs a merge with any union data inside the RelatedEntityQueryResults, using the provided RelatedEntityQueryResults
func (t *RelatedEntityQueryResults) MergeRelatedEntityQueryResults(v RelatedEntityQueryResults) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelatedEntityQueryResults) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelatedEntityQueryResults) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AcceptEula request
	AcceptEula(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdDomainDataQualityStats request
	GetAdDomainDataQualityStats(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiaCaEntity request
	GetAiaCaEntity(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiaCaEntityControllers request
	GetAiaCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartAnalysis request
	StartAnalysis(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroups request
	ListAssetGroups(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssetGroupWithBody request with any body
	CreateAssetGroupWithBody(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAssetGroup(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetGroup request
	DeleteAssetGroup(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroup request
	GetAssetGroup(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupWithBody request with any body
	UpdateAssetGroupWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroup(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupCollections request
	ListAssetGroupCollections(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroupComboNode request
	GetAssetGroupComboNode(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroupCustomMemberCount request
	GetAssetGroupCustomMemberCount(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupMembers request
	ListAssetGroupMembers(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupMemberCountByKind request
	ListAssetGroupMemberCountByKind(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupSelectorsDeprecatedWithBody request with any body
	UpdateAssetGroupSelectorsDeprecatedWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroupSelectorsDeprecated(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupSelectorsWithBody request with any body
	UpdateAssetGroupSelectorsWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroupSelectors(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetGroupSelector request
	DeleteAssetGroupSelector(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttackPathTypes request
	ListAttackPathTypes(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartAnalysisBhe request
	StartAnalysisBhe(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttackPathRiskWithBody request with any body
	UpdateAttackPathRiskWithBody(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttackPathRisk(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableDomains request
	GetAvailableDomains(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAzureTenantDataQualityStats request
	GetAzureTenantDataQualityStats(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAzureEntity request
	GetAzureEntity(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntity request
	GetEntity(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntityControllables request
	GetEntityControllables(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntityControllers request
	GetEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserMfaWithBody request with any body
	RemoveUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveUserMfa(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserMfaWithBody request with any body
	AddUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserMfa(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMfaActivationStatus request
	GetMfaActivationStatus(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateUserMfaWithBody request with any body
	ActivateUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateUserMfa(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserSecret request
	DeleteUserSecret(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrSetUserSecretWithBody request with any body
	CreateOrSetUserSecretWithBody(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrSetUserSecret(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertTemplateEntity request
	GetCertTemplateEntity(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertTemplateEntityControllers request
	GetCertTemplateEntityControllers(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBloodHoundDatabaseWithBody request with any body
	DeleteBloodHoundDatabaseWithBody(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteBloodHoundDatabase(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClients request
	ListClients(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientWithBody request with any body
	CreateClientWithBody(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClient(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogClientErrorWithBody request with any body
	LogClientErrorWithBody(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogClientError(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientInfoWithBody request with any body
	UpdateClientInfoWithBody(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClientInfo(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClient request
	DeleteClient(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClient request
	GetClient(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientWithBody request with any body
	UpdateClientWithBody(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClient(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientCompletedJobs request
	ListClientCompletedJobs(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientCompletedTasks request
	ListClientCompletedTasks(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduledJobWithBody request with any body
	CreateClientScheduledJobWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientScheduledJob(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduledTaskWithBody request with any body
	CreateClientScheduledTaskWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientScheduledTask(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceClientToken request
	ReplaceClientToken(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorManifest request
	GetCollectorManifest(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadCollector request
	DownloadCollector(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorChecksum request
	GetCollectorChecksum(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletenessStats request
	GetCompletenessStats(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntity request
	GetComputerEntity(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityAdminRights request
	GetComputerEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityAdmins request
	GetComputerEntityAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityConstrainedDelegationRights request
	GetComputerEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityConstrainedUsers request
	GetComputerEntityConstrainedUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityControllables request
	GetComputerEntityControllables(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityControllers request
	GetComputerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityDcomRights request
	GetComputerEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityDcomUsers request
	GetComputerEntityDcomUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityGroupMembership request
	GetComputerEntityGroupMembership(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityPsRemoteRights request
	GetComputerEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityPsRemoteUsers request
	GetComputerEntityPsRemoteUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityRdpRights request
	GetComputerEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityRdpUsers request
	GetComputerEntityRdpUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntitySessions request
	GetComputerEntitySessions(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntitySqlAdmins request
	GetComputerEntitySqlAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppConfigParams request
	ListAppConfigParams(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAppConfigParamWithBody request with any body
	SetAppConfigParamWithBody(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAppConfigParam(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerEntity request
	GetContainerEntity(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerEntityControllers request
	GetContainerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatapipeStatus request
	GetDatapipeStatus(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportAttackPathFindings request
	ExportAttackPathFindings(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableAttackPathTypesForDomain request
	ListAvailableAttackPathTypesForDomain(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDomainAttackPathsDetails request
	ListDomainAttackPathsDetails(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttackPathSparklineValues request
	ListAttackPathSparklineValues(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntity request
	GetDomainEntity(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDomainEntityWithBody request with any body
	UpdateDomainEntityWithBody(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDomainEntity(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityComputers request
	GetDomainEntityComputers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityControllers request
	GetDomainEntityControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityDcSyncers request
	GetDomainEntityDcSyncers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignAdmins request
	GetDomainEntityForeignAdmins(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignGpoControllers request
	GetDomainEntityForeignGpoControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignGroups request
	GetDomainEntityForeignGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignUsers request
	GetDomainEntityForeignUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityGpos request
	GetDomainEntityGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityGroups request
	GetDomainEntityGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityInboundTrusts request
	GetDomainEntityInboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityLinkedGpos request
	GetDomainEntityLinkedGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityOus request
	GetDomainEntityOus(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityOutboundTrusts request
	GetDomainEntityOutboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityUsers request
	GetDomainEntityUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnterpriseCaEntity request
	GetEnterpriseCaEntity(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnterpriseCaEntityControllers request
	GetEnterpriseCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientSchedules request
	ListClientSchedules(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduleWithBody request with any body
	CreateClientScheduleWithBody(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientSchedule(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientEvent request
	DeleteClientEvent(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientSchedule request
	GetClientSchedule(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientEventWithBody request with any body
	UpdateClientEventWithBody(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClientEvent(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFeatureFlags request
	ListFeatureFlags(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleFeatureFlag request
	ToggleFeatureFlag(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFileUploadJobs request
	ListFileUploadJobs(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAcceptedFileUploadTypes request
	ListAcceptedFileUploadTypes(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFileUploadJob request
	CreateFileUploadJob(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFileToJobWithBody request with any body
	UploadFileToJobWithBody(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadFileToJob(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndFileUploadJob request
	EndFileUploadJob(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntity request
	GetGpoEntity(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityComputers request
	GetGpoEntityComputers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityControllers request
	GetGpoEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityOus request
	GetGpoEntityOus(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityTierZero request
	GetGpoEntityTierZero(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityUsers request
	GetGpoEntityUsers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResult request
	GetSearchResult(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunCypherQueryWithBody request with any body
	RunCypherQueryWithBody(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunCypherQuery(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPathComposition request
	GetPathComposition(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShortestPath request
	GetShortestPath(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntity request
	GetGroupEntity(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityAdminRights request
	GetGroupEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityControllables request
	GetGroupEntityControllables(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityControllers request
	GetGroupEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityDcomRights request
	GetGroupEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityMembers request
	GetGroupEntityMembers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityMemberships request
	GetGroupEntityMemberships(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityPsRemoteRights request
	GetGroupEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityRdpRights request
	GetGroupEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntitySessions request
	GetGroupEntitySessions(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IngestData request
	IngestData(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJobs request
	GetClientJobs(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableClientJobs request
	ListAvailableClientJobs(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientCurrentJob request
	GetClientCurrentJob(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndClientJob request
	EndClientJob(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientFinishedJobs request
	ListClientFinishedJobs(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartClientJobWithBody request with any body
	StartClientJobWithBody(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartClientJob(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJob request
	GetClientJob(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelClientJob request
	CancelClientJob(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJobLog request
	GetClientJobLog(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestTierZeroComboNode request
	GetLatestTierZeroComboNode(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComboTreeGraph request
	GetComboTreeGraph(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetaEntity request
	GetMetaEntity(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNtAuthStoreEntity request
	GetNtAuthStoreEntity(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNtAuthStoreEntityControllers request
	GetNtAuthStoreEntityControllers(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntity request
	GetOuEntity(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityComputers request
	GetOuEntityComputers(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityGpos request
	GetOuEntityGpos(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityGroups request
	GetOuEntityGroups(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityUsers request
	GetOuEntityUsers(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pathfinding request
	Pathfinding(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissions request
	ListPermissions(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermission request
	GetPermission(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformDataQualityAggregate request
	GetPlatformDataQualityAggregate(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostureStats request
	GetPostureStats(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootCaEntity request
	GetRootCaEntity(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootCaEntityControllers request
	GetRootCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSamlProviders request
	ListSamlProviders(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSamlProviderWithBody request with any body
	CreateSamlProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSamlProvider request
	DeleteSamlProvider(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlProvider request
	GetSamlProvider(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlSignSignOnEndpoints request
	GetSamlSignSignOnEndpoints(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSavedQueries request
	ListSavedQueries(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSavedQueryWithBody request with any body
	CreateSavedQueryWithBody(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSavedQuery(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSavedQuery request
	DeleteSavedQuery(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSavedQueryWithBody request with any body
	UpdateSavedQueryWithBody(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSavedQuery(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSavedQueryPermissionsWithBody request with any body
	DeleteSavedQueryPermissionsWithBody(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSavedQueryPermissions(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelf request
	GetSelf(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiSpec request
	GetApiSpec(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuthTokens request
	ListAuthTokens(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthTokenWithBody request with any body
	CreateAuthTokenWithBody(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuthToken(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthToken request
	DeleteAuthToken(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntity request
	GetUserEntity(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityAdminRights request
	GetUserEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityConstrainedDelegationRights request
	GetUserEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityControllables request
	GetUserEntityControllables(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityControllers request
	GetUserEntityControllers(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityDcomRights request
	GetUserEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityMembership request
	GetUserEntityMembership(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityPsRemoteRights request
	GetUserEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityRdpRights request
	GetUserEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntitySessions request
	GetUserEntitySessions(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntitySqlAdminRights request
	GetUserEntitySqlAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiVersion request
	GetApiVersion(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AcceptEula(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEulaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdDomainDataQualityStats(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdDomainDataQualityStatsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiaCaEntity(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiaCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiaCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiaCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartAnalysis(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartAnalysisRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroups(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssetGroupWithBody(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssetGroup(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetGroup(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetGroupRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroup(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroup(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupCollections(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupCollectionsRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroupComboNode(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupComboNodeRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroupCustomMemberCount(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupCustomMemberCountRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupMembers(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupMembersRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupMemberCountByKind(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupMemberCountByKindRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsDeprecatedWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsDeprecated(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsDeprecatedRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectors(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetGroupSelector(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetGroupSelectorRequest(c.Server, assetGroupId, assetGroupSelectorId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttackPathTypes(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttackPathTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartAnalysisBhe(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartAnalysisBheRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttackPathRiskWithBody(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttackPathRiskRequestWithBody(c.Server, attackPathId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttackPathRisk(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttackPathRiskRequest(c.Server, attackPathId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableDomains(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAzureTenantDataQualityStats(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAzureTenantDataQualityStatsRequest(c.Server, tenantId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAzureEntity(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAzureEntityRequest(c.Server, entityType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntity(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntityControllables(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserMfa(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserMfa(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMfaActivationStatus(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMfaActivationStatusRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateUserMfa(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserSecret(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserSecretRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrSetUserSecretWithBody(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrSetUserSecretRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrSetUserSecret(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrSetUserSecretRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertTemplateEntity(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertTemplateEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertTemplateEntityControllers(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertTemplateEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBloodHoundDatabaseWithBody(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBloodHoundDatabaseRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBloodHoundDatabase(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBloodHoundDatabaseRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClients(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientWithBody(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClient(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogClientErrorWithBody(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogClientErrorRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogClientError(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogClientErrorRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientInfoWithBody(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientInfoRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientInfo(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientInfoRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClient(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClient(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientWithBody(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClient(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientCompletedJobs(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientCompletedJobsRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientCompletedTasks(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientCompletedTasksRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledJobWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledJobRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledJob(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledJobRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledTaskWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledTaskRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledTask(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledTaskRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceClientToken(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceClientTokenRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorManifest(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorManifestRequest(c.Server, collectorType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadCollector(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadCollectorRequest(c.Server, collectorType, releaseTag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorChecksum(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorChecksumRequest(c.Server, collectorType, releaseTag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletenessStats(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletenessStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntity(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityConstrainedDelegationRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityConstrainedUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityConstrainedUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityControllables(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityDcomUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityDcomUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityGroupMembership(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityGroupMembershipRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityPsRemoteUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityPsRemoteUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityRdpUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRdpUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntitySessions(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntitySqlAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntitySqlAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppConfigParams(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppConfigParamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppConfigParamWithBody(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppConfigParamRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppConfigParam(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppConfigParamRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerEntity(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatapipeStatus(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatapipeStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAttackPathFindings(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAttackPathFindingsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableAttackPathTypesForDomain(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableAttackPathTypesForDomainRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDomainAttackPathsDetails(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDomainAttackPathsDetailsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttackPathSparklineValues(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttackPathSparklineValuesRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntity(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainEntityWithBody(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainEntityRequestWithBody(c.Server, objectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainEntity(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainEntityRequest(c.Server, objectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityComputers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityDcSyncers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityDcSyncersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignAdmins(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignGpoControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignGpoControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityInboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityInboundTrustsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityLinkedGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityLinkedGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityOus(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityOusRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityOutboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityOutboundTrustsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnterpriseCaEntity(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnterpriseCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnterpriseCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnterpriseCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientSchedules(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduleWithBody(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientSchedule(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientEvent(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientEventRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientSchedule(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientScheduleRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientEventWithBody(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientEventRequestWithBody(c.Server, eventId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientEvent(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientEventRequest(c.Server, eventId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFeatureFlags(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFeatureFlagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleFeatureFlag(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleFeatureFlagRequest(c.Server, featureId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFileUploadJobs(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFileUploadJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAcceptedFileUploadTypes(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAcceptedFileUploadTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFileUploadJob(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFileUploadJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileToJobWithBody(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileToJobRequestWithBody(c.Server, fileUploadJobId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileToJob(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileToJobRequest(c.Server, fileUploadJobId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndFileUploadJob(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndFileUploadJobRequest(c.Server, fileUploadJobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntity(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityComputers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityOus(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityOusRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityTierZero(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityTierZeroRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityUsers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResult(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunCypherQueryWithBody(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunCypherQueryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunCypherQuery(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunCypherQueryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPathComposition(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPathCompositionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShortestPath(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShortestPathRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntity(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityControllables(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityMembers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityMembersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityMemberships(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityMembershipsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntitySessions(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestData(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJobs(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableClientJobs(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableClientJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientCurrentJob(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientCurrentJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndClientJob(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndClientJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientFinishedJobs(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientFinishedJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartClientJobWithBody(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartClientJobRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartClientJob(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartClientJobRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJob(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelClientJob(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelClientJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJobLog(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobLogRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestTierZeroComboNode(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestTierZeroComboNodeRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComboTreeGraph(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComboTreeGraphRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetaEntity(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNtAuthStoreEntity(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNtAuthStoreEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNtAuthStoreEntityControllers(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNtAuthStoreEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntity(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityComputers(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityGpos(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityGroups(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityUsers(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pathfinding(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPathfindingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissions(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermission(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionRequest(c.Server, permissionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformDataQualityAggregate(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformDataQualityAggregateRequest(c.Server, platformId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostureStats(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostureStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, roleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootCaEntity(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSamlProviders(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSamlProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSamlProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSamlProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSamlProvider(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSamlProviderRequest(c.Server, samlProviderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlProvider(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlProviderRequest(c.Server, samlProviderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlSignSignOnEndpoints(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlSignSignOnEndpointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSavedQueries(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSavedQueriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSavedQueryWithBody(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSavedQueryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSavedQuery(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSavedQueryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQuery(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryRequest(c.Server, savedQueryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSavedQueryWithBody(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSavedQueryRequestWithBody(c.Server, savedQueryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSavedQuery(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSavedQueryRequest(c.Server, savedQueryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQueryPermissionsWithBody(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryPermissionsRequestWithBody(c.Server, savedQueryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQueryPermissions(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryPermissionsRequest(c.Server, savedQueryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelf(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiSpec(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiSpecRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuthTokens(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuthTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthTokenWithBody(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthToken(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthToken(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthTokenRequest(c.Server, tokenId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntity(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityConstrainedDelegationRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityControllables(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityControllers(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityMembership(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityMembershipRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntitySessions(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntitySqlAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntitySqlAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiVersion(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAcceptEulaRequest generates requests for AcceptEula
func NewAcceptEulaRequest(server string, params *AcceptEulaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accept-eula")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAdDomainDataQualityStatsRequest generates requests for GetAdDomainDataQualityStats
func NewGetAdDomainDataQualityStatsRequest(server string, domainId string, params *GetAdDomainDataQualityStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ad-domains/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAiaCaEntityRequest generates requests for GetAiaCaEntity
func NewGetAiaCaEntityRequest(server string, objectId PathObjectId, params *GetAiaCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/aiacas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAiaCaEntityControllersRequest generates requests for GetAiaCaEntityControllers
func NewGetAiaCaEntityControllersRequest(server string, objectId PathObjectId, params *GetAiaCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/aiacas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartAnalysisRequest generates requests for StartAnalysis
func NewStartAnalysisRequest(server string, params *StartAnalysisParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/analysis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupsRequest generates requests for ListAssetGroups
func NewListAssetGroupsRequest(server string, params *ListAssetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SystemGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "system_group", runtime.ParamLocationQuery, *params.SystemGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "member_count", runtime.ParamLocationQuery, *params.MemberCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAssetGroupRequest calls the generic CreateAssetGroup builder with application/json body
func NewCreateAssetGroupRequest(server string, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAssetGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAssetGroupRequestWithBody generates requests for CreateAssetGroup with any type of body
func NewCreateAssetGroupRequestWithBody(server string, params *CreateAssetGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAssetGroupRequest generates requests for DeleteAssetGroup
func NewDeleteAssetGroupRequest(server string, assetGroupId int32, params *DeleteAssetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupRequest generates requests for GetAssetGroup
func NewGetAssetGroupRequest(server string, assetGroupId int32, params *GetAssetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupRequest calls the generic UpdateAssetGroup builder with application/json body
func NewUpdateAssetGroupRequest(server string, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupRequestWithBody generates requests for UpdateAssetGroup with any type of body
func NewUpdateAssetGroupRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupCollectionsRequest generates requests for ListAssetGroupCollections
func NewListAssetGroupCollectionsRequest(server string, assetGroupId int32, params *ListAssetGroupCollectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/collections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupComboNodeRequest generates requests for GetAssetGroupComboNode
func NewGetAssetGroupComboNodeRequest(server string, assetGroupId int32, params *GetAssetGroupComboNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/combo-node", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Domainsid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainsid", runtime.ParamLocationQuery, *params.Domainsid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupCustomMemberCountRequest generates requests for GetAssetGroupCustomMemberCount
func NewGetAssetGroupCustomMemberCountRequest(server string, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/custom-selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupMembersRequest generates requests for ListAssetGroupMembers
func NewListAssetGroupMembersRequest(server string, assetGroupId int32, params *ListAssetGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, *params.ObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_kind", runtime.ParamLocationQuery, *params.PrimaryKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_id", runtime.ParamLocationQuery, *params.EnvironmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_kind", runtime.ParamLocationQuery, *params.EnvironmentKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_member", runtime.ParamLocationQuery, *params.CustomMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupMemberCountByKindRequest generates requests for ListAssetGroupMemberCountByKind
func NewListAssetGroupMemberCountByKindRequest(server string, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/members/counts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, *params.ObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_id", runtime.ParamLocationQuery, *params.EnvironmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_kind", runtime.ParamLocationQuery, *params.PrimaryKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_kind", runtime.ParamLocationQuery, *params.EnvironmentKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_member", runtime.ParamLocationQuery, *params.CustomMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupSelectorsDeprecatedRequest calls the generic UpdateAssetGroupSelectorsDeprecated builder with application/json body
func NewUpdateAssetGroupSelectorsDeprecatedRequest(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody generates requests for UpdateAssetGroupSelectorsDeprecated with any type of body
func NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupSelectorsRequest calls the generic UpdateAssetGroupSelectors builder with application/json body
func NewUpdateAssetGroupSelectorsRequest(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupSelectorsRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupSelectorsRequestWithBody generates requests for UpdateAssetGroupSelectors with any type of body
func NewUpdateAssetGroupSelectorsRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAssetGroupSelectorRequest generates requests for DeleteAssetGroupSelector
func NewDeleteAssetGroupSelectorRequest(server string, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "asset_group_selector_id", runtime.ParamLocationPath, assetGroupSelectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAttackPathTypesRequest generates requests for ListAttackPathTypes
func NewListAttackPathTypesRequest(server string, params *ListAttackPathTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-path-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartAnalysisBheRequest generates requests for StartAnalysisBhe
func NewStartAnalysisBheRequest(server string, params *StartAnalysisBheParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-paths")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAttackPathRiskRequest calls the generic UpdateAttackPathRisk builder with application/json body
func NewUpdateAttackPathRiskRequest(server string, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAttackPathRiskRequestWithBody(server, attackPathId, params, "application/json", bodyReader)
}

// NewUpdateAttackPathRiskRequestWithBody generates requests for UpdateAttackPathRisk with any type of body
func NewUpdateAttackPathRiskRequestWithBody(server string, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attack_path_id", runtime.ParamLocationPath, attackPathId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-paths/%s/acceptance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/audit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_id", runtime.ParamLocationQuery, *params.ActorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_name", runtime.ParamLocationQuery, *params.ActorName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_email", runtime.ParamLocationQuery, *params.ActorEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "request_id", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAvailableDomainsRequest generates requests for GetAvailableDomains
func NewGetAvailableDomainsRequest(server string, params *GetAvailableDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/available-domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Objectid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objectid", runtime.ParamLocationQuery, *params.Objectid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Collected != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collected", runtime.ParamLocationQuery, *params.Collected); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAzureTenantDataQualityStatsRequest generates requests for GetAzureTenantDataQualityStats
func NewGetAzureTenantDataQualityStatsRequest(server string, tenantId string, params *GetAzureTenantDataQualityStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant_id", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/azure-tenants/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAzureEntityRequest generates requests for GetAzureEntity
func NewGetAzureEntityRequest(server string, entityType string, params *GetAzureEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity_type", runtime.ParamLocationPath, entityType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/azure/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, params.ObjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelatedEntityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "related_entity_type", runtime.ParamLocationQuery, *params.RelatedEntityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityRequest generates requests for GetEntity
func NewGetEntityRequest(server string, objectId PathObjectId, params *GetEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityControllablesRequest generates requests for GetEntityControllables
func NewGetEntityControllablesRequest(server string, objectId PathObjectId, params *GetEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityControllersRequest generates requests for GetEntityControllers
func NewGetEntityControllersRequest(server string, objectId PathObjectId, params *GetEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_name", runtime.ParamLocationQuery, *params.FirstName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_name", runtime.ParamLocationQuery, *params.LastName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_address", runtime.ParamLocationQuery, *params.EmailAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrincipalName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principal_name", runtime.ParamLocationQuery, *params.PrincipalName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastLogin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_login", runtime.ParamLocationQuery, *params.LastLogin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId openapi_types.UUID, params *DeleteUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId openapi_types.UUID, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewRemoveUserMfaRequest calls the generic RemoveUserMfa builder with application/json body
func NewRemoveUserMfaRequest(server string, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewRemoveUserMfaRequestWithBody generates requests for RemoveUserMfa with any type of body
func NewRemoveUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewAddUserMfaRequest calls the generic AddUserMfa builder with application/json body
func NewAddUserMfaRequest(server string, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewAddUserMfaRequestWithBody generates requests for AddUserMfa with any type of body
func NewAddUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetMfaActivationStatusRequest generates requests for GetMfaActivationStatus
func NewGetMfaActivationStatusRequest(server string, userId openapi_types.UUID, params *GetMfaActivationStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa-activation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewActivateUserMfaRequest calls the generic ActivateUserMfa builder with application/json body
func NewActivateUserMfaRequest(server string, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewActivateUserMfaRequestWithBody generates requests for ActivateUserMfa with any type of body
func NewActivateUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa-activation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUserSecretRequest generates requests for DeleteUserSecret
func NewDeleteUserSecretRequest(server string, userId openapi_types.UUID, params *DeleteUserSecretParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateOrSetUserSecretRequest calls the generic CreateOrSetUserSecret builder with application/json body
func NewCreateOrSetUserSecretRequest(server string, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrSetUserSecretRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewCreateOrSetUserSecretRequestWithBody generates requests for CreateOrSetUserSecret with any type of body
func NewCreateOrSetUserSecretRequestWithBody(server string, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCertTemplateEntityRequest generates requests for GetCertTemplateEntity
func NewGetCertTemplateEntityRequest(server string, objectId PathObjectId, params *GetCertTemplateEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/certtemplates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCertTemplateEntityControllersRequest generates requests for GetCertTemplateEntityControllers
func NewGetCertTemplateEntityControllersRequest(server string, objectId PathObjectId, params *GetCertTemplateEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/certtemplates/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteBloodHoundDatabaseRequest calls the generic DeleteBloodHoundDatabase builder with application/json body
func NewDeleteBloodHoundDatabaseRequest(server string, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteBloodHoundDatabaseRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteBloodHoundDatabaseRequestWithBody generates requests for DeleteBloodHoundDatabase with any type of body
func NewDeleteBloodHoundDatabaseRequestWithBody(server string, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clear-database")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientsRequest generates requests for ListClients
func NewListClientsRequest(server string, params *ListClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip_address", runtime.ParamLocationQuery, *params.IpAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostname", runtime.ParamLocationQuery, *params.Hostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConfiguredUser != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configured_user", runtime.ParamLocationQuery, *params.ConfiguredUser); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_sid", runtime.ParamLocationQuery, *params.UserSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastCheckin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_checkin", runtime.ParamLocationQuery, *params.LastCheckin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentJobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current_job_id", runtime.ParamLocationQuery, *params.CurrentJobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedJobCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_job_count", runtime.ParamLocationQuery, *params.CompletedJobCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientRequest calls the generic CreateClient builder with application/json body
func NewCreateClientRequest(server string, params *CreateClientParams, body CreateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateClientRequestWithBody generates requests for CreateClient with any type of body
func NewCreateClientRequestWithBody(server string, params *CreateClientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLogClientErrorRequest calls the generic LogClientError builder with application/json body
func NewLogClientErrorRequest(server string, params *LogClientErrorParams, body LogClientErrorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLogClientErrorRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLogClientErrorRequestWithBody generates requests for LogClientError with any type of body
func NewLogClientErrorRequestWithBody(server string, params *LogClientErrorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/error")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientInfoRequest calls the generic UpdateClientInfo builder with application/json body
func NewUpdateClientInfoRequest(server string, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientInfoRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateClientInfoRequestWithBody generates requests for UpdateClientInfo with any type of body
func NewUpdateClientInfoRequestWithBody(server string, params *UpdateClientInfoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteClientRequest generates requests for DeleteClient
func NewDeleteClientRequest(server string, clientId openapi_types.UUID, params *DeleteClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientRequest generates requests for GetClient
func NewGetClientRequest(server string, clientId openapi_types.UUID, params *GetClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientRequest calls the generic UpdateClient builder with application/json body
func NewUpdateClientRequest(server string, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewUpdateClientRequestWithBody generates requests for UpdateClient with any type of body
func NewUpdateClientRequestWithBody(server string, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientCompletedJobsRequest generates requests for ListClientCompletedJobs
func NewListClientCompletedJobsRequest(server string, clientId openapi_types.UUID, params *ListClientCompletedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/completed-jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientCompletedTasksRequest generates requests for ListClientCompletedTasks
func NewListClientCompletedTasksRequest(server string, clientId openapi_types.UUID, params *ListClientCompletedTasksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/completed-tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduledJobRequest calls the generic CreateClientScheduledJob builder with application/json body
func NewCreateClientScheduledJobRequest(server string, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduledJobRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewCreateClientScheduledJobRequestWithBody generates requests for CreateClientScheduledJob with any type of body
func NewCreateClientScheduledJobRequestWithBody(server string, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduledTaskRequest calls the generic CreateClientScheduledTask builder with application/json body
func NewCreateClientScheduledTaskRequest(server string, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduledTaskRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewCreateClientScheduledTaskRequestWithBody generates requests for CreateClientScheduledTask with any type of body
func NewCreateClientScheduledTaskRequestWithBody(server string, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewReplaceClientTokenRequest generates requests for ReplaceClientToken
func NewReplaceClientTokenRequest(server string, clientId openapi_types.UUID, params *ReplaceClientTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCollectorManifestRequest generates requests for GetCollectorManifest
func NewGetCollectorManifestRequest(server string, collectorType EnumClientType, params *GetCollectorManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDownloadCollectorRequest generates requests for DownloadCollector
func NewDownloadCollectorRequest(server string, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "release_tag", runtime.ParamLocationPath, releaseTag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCollectorChecksumRequest generates requests for GetCollectorChecksum
func NewGetCollectorChecksumRequest(server string, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "release_tag", runtime.ParamLocationPath, releaseTag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s/%s/checksum", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCompletenessStatsRequest generates requests for GetCompletenessStats
func NewGetCompletenessStatsRequest(server string, params *GetCompletenessStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/completeness")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRequest generates requests for GetComputerEntity
func NewGetComputerEntityRequest(server string, objectId PathObjectId, params *GetComputerEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityAdminRightsRequest generates requests for GetComputerEntityAdminRights
func NewGetComputerEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityAdminsRequest generates requests for GetComputerEntityAdmins
func NewGetComputerEntityAdminsRequest(server string, objectId PathObjectId, params *GetComputerEntityAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/admin-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityConstrainedDelegationRightsRequest generates requests for GetComputerEntityConstrainedDelegationRights
func NewGetComputerEntityConstrainedDelegationRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/constrained-delegation-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityConstrainedUsersRequest generates requests for GetComputerEntityConstrainedUsers
func NewGetComputerEntityConstrainedUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/constrained-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityControllablesRequest generates requests for GetComputerEntityControllables
func NewGetComputerEntityControllablesRequest(server string, objectId PathObjectId, params *GetComputerEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityControllersRequest generates requests for GetComputerEntityControllers
func NewGetComputerEntityControllersRequest(server string, objectId PathObjectId, params *GetComputerEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityDcomRightsRequest generates requests for GetComputerEntityDcomRights
func NewGetComputerEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityDcomUsersRequest generates requests for GetComputerEntityDcomUsers
func NewGetComputerEntityDcomUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityDcomUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/dcom-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityGroupMembershipRequest generates requests for GetComputerEntityGroupMembership
func NewGetComputerEntityGroupMembershipRequest(server string, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/group-membership", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityPsRemoteRightsRequest generates requests for GetComputerEntityPsRemoteRights
func NewGetComputerEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityPsRemoteUsersRequest generates requests for GetComputerEntityPsRemoteUsers
func NewGetComputerEntityPsRemoteUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/ps-remote-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRdpRightsRequest generates requests for GetComputerEntityRdpRights
func NewGetComputerEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRdpUsersRequest generates requests for GetComputerEntityRdpUsers
func NewGetComputerEntityRdpUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityRdpUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/rdp-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntitySessionsRequest generates requests for GetComputerEntitySessions
func NewGetComputerEntitySessionsRequest(server string, objectId PathObjectId, params *GetComputerEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntitySqlAdminsRequest generates requests for GetComputerEntitySqlAdmins
func NewGetComputerEntitySqlAdminsRequest(server string, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/sql-admins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAppConfigParamsRequest generates requests for ListAppConfigParams
func NewListAppConfigParamsRequest(server string, params *ListAppConfigParamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Parameter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parameter", runtime.ParamLocationQuery, *params.Parameter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewSetAppConfigParamRequest calls the generic SetAppConfigParam builder with application/json body
func NewSetAppConfigParamRequest(server string, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAppConfigParamRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSetAppConfigParamRequestWithBody generates requests for SetAppConfigParam with any type of body
func NewSetAppConfigParamRequestWithBody(server string, params *SetAppConfigParamParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetContainerEntityRequest generates requests for GetContainerEntity
func NewGetContainerEntityRequest(server string, objectId PathObjectId, params *GetContainerEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetContainerEntityControllersRequest generates requests for GetContainerEntityControllers
func NewGetContainerEntityControllersRequest(server string, objectId PathObjectId, params *GetContainerEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/containers/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDatapipeStatusRequest generates requests for GetDatapipeStatus
func NewGetDatapipeStatusRequest(server string, params *GetDatapipeStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/datapipe/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewExportAttackPathFindingsRequest generates requests for ExportAttackPathFindings
func NewExportAttackPathFindingsRequest(server string, domainId string, params *ExportAttackPathFindingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/attack-path-findings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FilterAccepted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterAccepted", runtime.ParamLocationQuery, *params.FilterAccepted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAvailableAttackPathTypesForDomainRequest generates requests for ListAvailableAttackPathTypesForDomain
func NewListAvailableAttackPathTypesForDomainRequest(server string, domainId string, params *ListAvailableAttackPathTypesForDomainParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/available-types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListDomainAttackPathsDetailsRequest generates requests for ListDomainAttackPathsDetails
func NewListDomainAttackPathsDetailsRequest(server string, domainId string, params *ListDomainAttackPathsDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/details", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromPrincipal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "FromPrincipal", runtime.ParamLocationQuery, *params.FromPrincipal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToPrincipal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ToPrincipal", runtime.ParamLocationQuery, *params.ToPrincipal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromPrincipal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_principal", runtime.ParamLocationQuery, *params.FromPrincipal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToPrincipal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_principal", runtime.ParamLocationQuery, *params.ToPrincipal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrincipalsHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principals_hash", runtime.ParamLocationQuery, *params.PrincipalsHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accepted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Accepted", runtime.ParamLocationQuery, *params.Accepted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AcceptedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "AcceptedUntil", runtime.ParamLocationQuery, *params.AcceptedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AcceptedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepted_until", runtime.ParamLocationQuery, *params.AcceptedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Principal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Principal", runtime.ParamLocationQuery, *params.Principal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_sid", runtime.ParamLocationQuery, *params.DomainSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAttackPathSparklineValuesRequest generates requests for ListAttackPathSparklineValues
func NewListAttackPathSparklineValuesRequest(server string, domainId string, params *ListAttackPathSparklineValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/sparkline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityRequest generates requests for GetDomainEntity
func NewGetDomainEntityRequest(server string, objectId PathObjectId, params *GetDomainEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateDomainEntityRequest calls the generic UpdateDomainEntity builder with application/json body
func NewUpdateDomainEntityRequest(server string, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDomainEntityRequestWithBody(server, objectId, params, "application/json", bodyReader)
}

// NewUpdateDomainEntityRequestWithBody generates requests for UpdateDomainEntity with any type of body
func NewUpdateDomainEntityRequestWithBody(server string, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityComputersRequest generates requests for GetDomainEntityComputers
func NewGetDomainEntityComputersRequest(server string, objectId PathObjectId, params *GetDomainEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityControllersRequest generates requests for GetDomainEntityControllers
func NewGetDomainEntityControllersRequest(server string, objectId PathObjectId, params *GetDomainEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityDcSyncersRequest generates requests for GetDomainEntityDcSyncers
func NewGetDomainEntityDcSyncersRequest(server string, objectId PathObjectId, params *GetDomainEntityDcSyncersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/dc-syncers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignAdminsRequest generates requests for GetDomainEntityForeignAdmins
func NewGetDomainEntityForeignAdminsRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-admins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignGpoControllersRequest generates requests for GetDomainEntityForeignGpoControllers
func NewGetDomainEntityForeignGpoControllersRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-gpo-controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignGroupsRequest generates requests for GetDomainEntityForeignGroups
func NewGetDomainEntityForeignGroupsRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignUsersRequest generates requests for GetDomainEntityForeignUsers
func NewGetDomainEntityForeignUsersRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityGposRequest generates requests for GetDomainEntityGpos
func NewGetDomainEntityGposRequest(server string, objectId PathObjectId, params *GetDomainEntityGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityGroupsRequest generates requests for GetDomainEntityGroups
func NewGetDomainEntityGroupsRequest(server string, objectId PathObjectId, params *GetDomainEntityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityInboundTrustsRequest generates requests for GetDomainEntityInboundTrusts
func NewGetDomainEntityInboundTrustsRequest(server string, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/inbound-trusts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityLinkedGposRequest generates requests for GetDomainEntityLinkedGpos
func NewGetDomainEntityLinkedGposRequest(server string, objectId PathObjectId, params *GetDomainEntityLinkedGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/linked-gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityOusRequest generates requests for GetDomainEntityOus
func NewGetDomainEntityOusRequest(server string, objectId PathObjectId, params *GetDomainEntityOusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/ous", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityOutboundTrustsRequest generates requests for GetDomainEntityOutboundTrusts
func NewGetDomainEntityOutboundTrustsRequest(server string, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/outbound-trusts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityUsersRequest generates requests for GetDomainEntityUsers
func NewGetDomainEntityUsersRequest(server string, objectId PathObjectId, params *GetDomainEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEnterpriseCaEntityRequest generates requests for GetEnterpriseCaEntity
func NewGetEnterpriseCaEntityRequest(server string, objectId PathObjectId, params *GetEnterpriseCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/enterprisecas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEnterpriseCaEntityControllersRequest generates requests for GetEnterpriseCaEntityControllers
func NewGetEnterpriseCaEntityControllersRequest(server string, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/enterprisecas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientSchedulesRequest generates requests for ListClientSchedules
func NewListClientSchedulesRequest(server string, params *ListClientSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rrule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rrule", runtime.ParamLocationQuery, *params.Rrule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextScheduledAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_scheduled_at", runtime.ParamLocationQuery, *params.NextScheduledAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduleRequest calls the generic CreateClientSchedule builder with application/json body
func NewCreateClientScheduleRequest(server string, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateClientScheduleRequestWithBody generates requests for CreateClientSchedule with any type of body
func NewCreateClientScheduleRequestWithBody(server string, params *CreateClientScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteClientEventRequest generates requests for DeleteClientEvent
func NewDeleteClientEventRequest(server string, eventId int32, params *DeleteClientEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientScheduleRequest generates requests for GetClientSchedule
func NewGetClientScheduleRequest(server string, eventId int32, params *GetClientScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientEventRequest calls the generic UpdateClientEvent builder with application/json body
func NewUpdateClientEventRequest(server string, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientEventRequestWithBody(server, eventId, params, "application/json", bodyReader)
}

// NewUpdateClientEventRequestWithBody generates requests for UpdateClientEvent with any type of body
func NewUpdateClientEventRequestWithBody(server string, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListFeatureFlagsRequest generates requests for ListFeatureFlags
func NewListFeatureFlagsRequest(server string, params *ListFeatureFlagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewToggleFeatureFlagRequest generates requests for ToggleFeatureFlag
func NewToggleFeatureFlagRequest(server string, featureId int32, params *ToggleFeatureFlagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "feature_id", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/features/%s/toggle", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListFileUploadJobsRequest generates requests for ListFileUploadJobs
func NewListFileUploadJobsRequest(server string, params *ListFileUploadJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserEmailAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_email_address", runtime.ParamLocationQuery, *params.UserEmailAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusMessage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status_message", runtime.ParamLocationQuery, *params.StatusMessage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAcceptedFileUploadTypesRequest generates requests for ListAcceptedFileUploadTypes
func NewListAcceptedFileUploadTypesRequest(server string, params *ListAcceptedFileUploadTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/accepted-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateFileUploadJobRequest generates requests for CreateFileUploadJob
func NewCreateFileUploadJobRequest(server string, params *CreateFileUploadJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUploadFileToJobRequest calls the generic UploadFileToJob builder with application/json body
func NewUploadFileToJobRequest(server string, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadFileToJobRequestWithBody(server, fileUploadJobId, params, "application/json", bodyReader)
}

// NewUploadFileToJobRequestWithBody generates requests for UploadFileToJob with any type of body
func NewUploadFileToJobRequestWithBody(server string, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_upload_job_id", runtime.ParamLocationPath, fileUploadJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam1)

	}

	return req, nil
}

// NewEndFileUploadJobRequest generates requests for EndFileUploadJob
func NewEndFileUploadJobRequest(server string, fileUploadJobId int64, params *EndFileUploadJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_upload_job_id", runtime.ParamLocationPath, fileUploadJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/%s/end", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityRequest generates requests for GetGpoEntity
func NewGetGpoEntityRequest(server string, objectId PathObjectId, params *GetGpoEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityComputersRequest generates requests for GetGpoEntityComputers
func NewGetGpoEntityComputersRequest(server string, objectId PathObjectId, params *GetGpoEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityControllersRequest generates requests for GetGpoEntityControllers
func NewGetGpoEntityControllersRequest(server string, objectId PathObjectId, params *GetGpoEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityOusRequest generates requests for GetGpoEntityOus
func NewGetGpoEntityOusRequest(server string, objectId PathObjectId, params *GetGpoEntityOusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/ous", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityTierZeroRequest generates requests for GetGpoEntityTierZero
func NewGetGpoEntityTierZeroRequest(server string, objectId PathObjectId, params *GetGpoEntityTierZeroParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/tier-zero", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityUsersRequest generates requests for GetGpoEntityUsers
func NewGetGpoEntityUsersRequest(server string, objectId PathObjectId, params *GetGpoEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSearchResultRequest generates requests for GetSearchResult
func NewGetSearchResultRequest(server string, params *GetSearchResultParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graph-search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_query", runtime.ParamLocationQuery, params.SearchQuery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewRunCypherQueryRequest calls the generic RunCypherQuery builder with application/json body
func NewRunCypherQueryRequest(server string, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunCypherQueryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRunCypherQueryRequestWithBody generates requests for RunCypherQuery with any type of body
func NewRunCypherQueryRequestWithBody(server string, params *RunCypherQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/cypher")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPathCompositionRequest generates requests for GetPathComposition
func NewGetPathCompositionRequest(server string, params *GetPathCompositionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/edge-composition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_node", runtime.ParamLocationQuery, params.SourceNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_node", runtime.ParamLocationQuery, params.TargetNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "edge_type", runtime.ParamLocationQuery, params.EdgeType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetShortestPathRequest generates requests for GetShortestPath
func NewGetShortestPathRequest(server string, params *GetShortestPathParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/shortest-path")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_node", runtime.ParamLocationQuery, params.StartNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_node", runtime.ParamLocationQuery, params.EndNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RelationshipKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship_kinds", runtime.ParamLocationQuery, *params.RelationshipKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityRequest generates requests for GetGroupEntity
func NewGetGroupEntityRequest(server string, objectId PathObjectId, params *GetGroupEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityAdminRightsRequest generates requests for GetGroupEntityAdminRights
func NewGetGroupEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityControllablesRequest generates requests for GetGroupEntityControllables
func NewGetGroupEntityControllablesRequest(server string, objectId PathObjectId, params *GetGroupEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityControllersRequest generates requests for GetGroupEntityControllers
func NewGetGroupEntityControllersRequest(server string, objectId PathObjectId, params *GetGroupEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityDcomRightsRequest generates requests for GetGroupEntityDcomRights
func NewGetGroupEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityMembersRequest generates requests for GetGroupEntityMembers
func NewGetGroupEntityMembersRequest(server string, objectId PathObjectId, params *GetGroupEntityMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityMembershipsRequest generates requests for GetGroupEntityMemberships
func NewGetGroupEntityMembershipsRequest(server string, objectId PathObjectId, params *GetGroupEntityMembershipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityPsRemoteRightsRequest generates requests for GetGroupEntityPsRemoteRights
func NewGetGroupEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityRdpRightsRequest generates requests for GetGroupEntityRdpRights
func NewGetGroupEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntitySessionsRequest generates requests for GetGroupEntitySessions
func NewGetGroupEntitySessionsRequest(server string, objectId PathObjectId, params *GetGroupEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewIngestDataRequest generates requests for IngestData
func NewIngestDataRequest(server string, params *IngestDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ingest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobsRequest generates requests for GetClientJobs
func NewGetClientJobsRequest(server string, params *GetClientJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAvailableClientJobsRequest generates requests for ListAvailableClientJobs
func NewListAvailableClientJobsRequest(server string, params *ListAvailableClientJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/available")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientCurrentJobRequest generates requests for GetClientCurrentJob
func NewGetClientCurrentJobRequest(server string, params *GetClientCurrentJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewEndClientJobRequest generates requests for EndClientJob
func NewEndClientJobRequest(server string, params *EndClientJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/end")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientFinishedJobsRequest generates requests for ListClientFinishedJobs
func NewListClientFinishedJobsRequest(server string, params *ListClientFinishedJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/finished")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartClientJobRequest calls the generic StartClientJob builder with application/json body
func NewStartClientJobRequest(server string, params *StartClientJobParams, body StartClientJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartClientJobRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStartClientJobRequestWithBody generates requests for StartClientJob with any type of body
func NewStartClientJobRequestWithBody(server string, params *StartClientJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobRequest generates requests for GetClientJob
func NewGetClientJobRequest(server string, jobId int64, params *GetClientJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCancelClientJobRequest generates requests for CancelClientJob
func NewCancelClientJobRequest(server string, jobId int64, params *CancelClientJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobLogRequest generates requests for GetClientJobLog
func NewGetClientJobLogRequest(server string, jobId int64, params *GetClientJobLogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s/log", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, params *LoginParams, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, params *LoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string, params *LogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetLatestTierZeroComboNodeRequest generates requests for GetLatestTierZeroComboNode
func NewGetLatestTierZeroComboNodeRequest(server string, domainId string, params *GetLatestTierZeroComboNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta-nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComboTreeGraphRequest generates requests for GetComboTreeGraph
func NewGetComboTreeGraphRequest(server string, domainId string, params *GetComboTreeGraphParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta-trees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NodeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "node_id", runtime.ParamLocationQuery, *params.NodeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetMetaEntityRequest generates requests for GetMetaEntity
func NewGetMetaEntityRequest(server string, objectId PathObjectId, params *GetMetaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetNtAuthStoreEntityRequest generates requests for GetNtAuthStoreEntity
func NewGetNtAuthStoreEntityRequest(server string, objectId PathObjectId, params *GetNtAuthStoreEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ntauthstores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetNtAuthStoreEntityControllersRequest generates requests for GetNtAuthStoreEntityControllers
func NewGetNtAuthStoreEntityControllersRequest(server string, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ntauthstores/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityRequest generates requests for GetOuEntity
func NewGetOuEntityRequest(server string, objectId PathObjectId, params *GetOuEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityComputersRequest generates requests for GetOuEntityComputers
func NewGetOuEntityComputersRequest(server string, objectId PathObjectId, params *GetOuEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityGposRequest generates requests for GetOuEntityGpos
func NewGetOuEntityGposRequest(server string, objectId PathObjectId, params *GetOuEntityGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityGroupsRequest generates requests for GetOuEntityGroups
func NewGetOuEntityGroupsRequest(server string, objectId PathObjectId, params *GetOuEntityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityUsersRequest generates requests for GetOuEntityUsers
func NewGetOuEntityUsersRequest(server string, objectId PathObjectId, params *GetOuEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewPathfindingRequest generates requests for Pathfinding
func NewPathfindingRequest(server string, params *PathfindingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/pathfinding")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_node", runtime.ParamLocationQuery, params.StartNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_node", runtime.ParamLocationQuery, params.EndNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListPermissionsRequest generates requests for ListPermissions
func NewListPermissionsRequest(server string, params *ListPermissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authority", runtime.ParamLocationQuery, *params.Authority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPermissionRequest generates requests for GetPermission
func NewGetPermissionRequest(server string, permissionId int32, params *GetPermissionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPlatformDataQualityAggregateRequest generates requests for GetPlatformDataQualityAggregate
func NewGetPlatformDataQualityAggregateRequest(server string, platformId string, params *GetPlatformDataQualityAggregateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform_id", runtime.ParamLocationPath, platformId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/platform/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPostureStatsRequest generates requests for GetPostureStats
func NewGetPostureStatsRequest(server string, params *GetPostureStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/posture-stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_sid", runtime.ParamLocationQuery, *params.DomainSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExposureIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exposure_index", runtime.ParamLocationQuery, *params.ExposureIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TierZeroCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tier_zero_count", runtime.ParamLocationQuery, *params.TierZeroCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CriticalRiskCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "critical_risk_count", runtime.ParamLocationQuery, *params.CriticalRiskCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string, params *ListRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, roleId int32, params *GetRoleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRootCaEntityRequest generates requests for GetRootCaEntity
func NewGetRootCaEntityRequest(server string, objectId PathObjectId, params *GetRootCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/rootcas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRootCaEntityControllersRequest generates requests for GetRootCaEntityControllers
func NewGetRootCaEntityControllersRequest(server string, objectId PathObjectId, params *GetRootCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/rootcas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListSamlProvidersRequest generates requests for ListSamlProviders
func NewListSamlProvidersRequest(server string, params *ListSamlProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSamlProviderRequestWithBody generates requests for CreateSamlProvider with any type of body
func NewCreateSamlProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSamlProviderRequest generates requests for DeleteSamlProvider
func NewDeleteSamlProviderRequest(server string, samlProviderId int32, params *DeleteSamlProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saml_provider_id", runtime.ParamLocationPath, samlProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSamlProviderRequest generates requests for GetSamlProvider
func NewGetSamlProviderRequest(server string, samlProviderId int32, params *GetSamlProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saml_provider_id", runtime.ParamLocationPath, samlProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSamlSignSignOnEndpointsRequest generates requests for GetSamlSignSignOnEndpoints
func NewGetSamlSignSignOnEndpointsRequest(server string, params *GetSamlSignSignOnEndpointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/sso")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListSavedQueriesRequest generates requests for ListSavedQueries
func NewListSavedQueriesRequest(server string, params *ListSavedQueriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSavedQueryRequest calls the generic CreateSavedQuery builder with application/json body
func NewCreateSavedQueryRequest(server string, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSavedQueryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSavedQueryRequestWithBody generates requests for CreateSavedQuery with any type of body
func NewCreateSavedQueryRequestWithBody(server string, params *CreateSavedQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSavedQueryRequest generates requests for DeleteSavedQuery
func NewDeleteSavedQueryRequest(server string, savedQueryId int32, params *DeleteSavedQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSavedQueryRequest calls the generic UpdateSavedQuery builder with application/json body
func NewUpdateSavedQueryRequest(server string, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSavedQueryRequestWithBody(server, savedQueryId, params, "application/json", bodyReader)
}

// NewUpdateSavedQueryRequestWithBody generates requests for UpdateSavedQuery with any type of body
func NewUpdateSavedQueryRequestWithBody(server string, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSavedQueryPermissionsRequest calls the generic DeleteSavedQueryPermissions builder with application/json body
func NewDeleteSavedQueryPermissionsRequest(server string, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSavedQueryPermissionsRequestWithBody(server, savedQueryId, params, "application/json", bodyReader)
}

// NewDeleteSavedQueryPermissionsRequestWithBody generates requests for DeleteSavedQueryPermissions with any type of body
func NewDeleteSavedQueryPermissionsRequestWithBody(server string, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSelfRequest generates requests for GetSelf
func NewGetSelfRequest(server string, params *GetSelfParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiSpecRequest generates requests for GetApiSpec
func NewGetApiSpecRequest(server string, params *GetApiSpecParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/spec/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAuthTokensRequest generates requests for ListAuthTokens
func NewListAuthTokensRequest(server string, params *ListAuthTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HmacMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hmac_method", runtime.ParamLocationQuery, *params.HmacMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastAccess != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_access", runtime.ParamLocationQuery, *params.LastAccess); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAuthTokenRequest calls the generic CreateAuthToken builder with application/json body
func NewCreateAuthTokenRequest(server string, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuthTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAuthTokenRequestWithBody generates requests for CreateAuthToken with any type of body
func NewCreateAuthTokenRequestWithBody(server string, params *CreateAuthTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAuthTokenRequest generates requests for DeleteAuthToken
func NewDeleteAuthTokenRequest(server string, tokenId openapi_types.UUID, params *DeleteAuthTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityRequest generates requests for GetUserEntity
func NewGetUserEntityRequest(server string, objectId PathObjectId, params *GetUserEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityAdminRightsRequest generates requests for GetUserEntityAdminRights
func NewGetUserEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetUserEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityConstrainedDelegationRightsRequest generates requests for GetUserEntityConstrainedDelegationRights
func NewGetUserEntityConstrainedDelegationRightsRequest(server string, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/constrained-delegation-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityControllablesRequest generates requests for GetUserEntityControllables
func NewGetUserEntityControllablesRequest(server string, objectId PathObjectId, params *GetUserEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityControllersRequest generates requests for GetUserEntityControllers
func NewGetUserEntityControllersRequest(server string, objectId PathObjectId, params *GetUserEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityDcomRightsRequest generates requests for GetUserEntityDcomRights
func NewGetUserEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetUserEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityMembershipRequest generates requests for GetUserEntityMembership
func NewGetUserEntityMembershipRequest(server string, objectId PathObjectId, params *GetUserEntityMembershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityPsRemoteRightsRequest generates requests for GetUserEntityPsRemoteRights
func NewGetUserEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityRdpRightsRequest generates requests for GetUserEntityRdpRights
func NewGetUserEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetUserEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntitySessionsRequest generates requests for GetUserEntitySessions
func NewGetUserEntitySessionsRequest(server string, objectId PathObjectId, params *GetUserEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntitySqlAdminRightsRequest generates requests for GetUserEntitySqlAdminRights
func NewGetUserEntitySqlAdminRightsRequest(server string, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/sql-admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiVersionRequest generates requests for GetApiVersion
func NewGetApiVersionRequest(server string, params *GetApiVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AcceptEulaWithResponse request
	AcceptEulaWithResponse(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*AcceptEulaResponse, error)

	// GetAdDomainDataQualityStatsWithResponse request
	GetAdDomainDataQualityStatsWithResponse(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAdDomainDataQualityStatsResponse, error)

	// GetAiaCaEntityWithResponse request
	GetAiaCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityResponse, error)

	// GetAiaCaEntityControllersWithResponse request
	GetAiaCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityControllersResponse, error)

	// StartAnalysisWithResponse request
	StartAnalysisWithResponse(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*StartAnalysisResponse, error)

	// ListAssetGroupsWithResponse request
	ListAssetGroupsWithResponse(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupsResponse, error)

	// CreateAssetGroupWithBodyWithResponse request with any body
	CreateAssetGroupWithBodyWithResponse(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error)

	CreateAssetGroupWithResponse(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error)

	// DeleteAssetGroupWithResponse request
	DeleteAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupResponse, error)

	// GetAssetGroupWithResponse request
	GetAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*GetAssetGroupResponse, error)

	// UpdateAssetGroupWithBodyWithResponse request with any body
	UpdateAssetGroupWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error)

	UpdateAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error)

	// ListAssetGroupCollectionsWithResponse request
	ListAssetGroupCollectionsWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupCollectionsResponse, error)

	// GetAssetGroupComboNodeWithResponse request
	GetAssetGroupComboNodeWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*GetAssetGroupComboNodeResponse, error)

	// GetAssetGroupCustomMemberCountWithResponse request
	GetAssetGroupCustomMemberCountWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*GetAssetGroupCustomMemberCountResponse, error)

	// ListAssetGroupMembersWithResponse request
	ListAssetGroupMembersWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMembersResponse, error)

	// ListAssetGroupMemberCountByKindWithResponse request
	ListAssetGroupMemberCountByKindWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMemberCountByKindResponse, error)

	// UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse request with any body
	UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error)

	UpdateAssetGroupSelectorsDeprecatedWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error)

	// UpdateAssetGroupSelectorsWithBodyWithResponse request with any body
	UpdateAssetGroupSelectorsWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error)

	UpdateAssetGroupSelectorsWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error)

	// DeleteAssetGroupSelectorWithResponse request
	DeleteAssetGroupSelectorWithResponse(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupSelectorResponse, error)

	// ListAttackPathTypesWithResponse request
	ListAttackPathTypesWithResponse(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*ListAttackPathTypesResponse, error)

	// StartAnalysisBheWithResponse request
	StartAnalysisBheWithResponse(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*StartAnalysisBheResponse, error)

	// UpdateAttackPathRiskWithBodyWithResponse request with any body
	UpdateAttackPathRiskWithBodyWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error)

	UpdateAttackPathRiskWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error)

	// ListAuditLogsWithResponse request
	ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)

	// GetAvailableDomainsWithResponse request
	GetAvailableDomainsWithResponse(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*GetAvailableDomainsResponse, error)

	// GetAzureTenantDataQualityStatsWithResponse request
	GetAzureTenantDataQualityStatsWithResponse(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAzureTenantDataQualityStatsResponse, error)

	// GetAzureEntityWithResponse request
	GetAzureEntityWithResponse(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*GetAzureEntityResponse, error)

	// GetEntityWithResponse request
	GetEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*GetEntityResponse, error)

	// GetEntityControllablesWithResponse request
	GetEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetEntityControllablesResponse, error)

	// GetEntityControllersWithResponse request
	GetEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEntityControllersResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// RemoveUserMfaWithBodyWithResponse request with any body
	RemoveUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error)

	RemoveUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error)

	// AddUserMfaWithBodyWithResponse request with any body
	AddUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error)

	AddUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error)

	// GetMfaActivationStatusWithResponse request
	GetMfaActivationStatusWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*GetMfaActivationStatusResponse, error)

	// ActivateUserMfaWithBodyWithResponse request with any body
	ActivateUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error)

	ActivateUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error)

	// DeleteUserSecretWithResponse request
	DeleteUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*DeleteUserSecretResponse, error)

	// CreateOrSetUserSecretWithBodyWithResponse request with any body
	CreateOrSetUserSecretWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error)

	CreateOrSetUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error)

	// GetCertTemplateEntityWithResponse request
	GetCertTemplateEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityResponse, error)

	// GetCertTemplateEntityControllersWithResponse request
	GetCertTemplateEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityControllersResponse, error)

	// DeleteBloodHoundDatabaseWithBodyWithResponse request with any body
	DeleteBloodHoundDatabaseWithBodyWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error)

	DeleteBloodHoundDatabaseWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error)

	// ListClientsWithResponse request
	ListClientsWithResponse(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*ListClientsResponse, error)

	// CreateClientWithBodyWithResponse request with any body
	CreateClientWithBodyWithResponse(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	CreateClientWithResponse(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	// LogClientErrorWithBodyWithResponse request with any body
	LogClientErrorWithBodyWithResponse(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error)

	LogClientErrorWithResponse(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error)

	// UpdateClientInfoWithBodyWithResponse request with any body
	UpdateClientInfoWithBodyWithResponse(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error)

	UpdateClientInfoWithResponse(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error)

	// DeleteClientWithResponse request
	DeleteClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*DeleteClientResponse, error)

	// GetClientWithResponse request
	GetClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error)

	// UpdateClientWithBodyWithResponse request with any body
	UpdateClientWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error)

	UpdateClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error)

	// ListClientCompletedJobsWithResponse request
	ListClientCompletedJobsWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListClientCompletedJobsResponse, error)

	// ListClientCompletedTasksWithResponse request
	ListClientCompletedTasksWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*ListClientCompletedTasksResponse, error)

	// CreateClientScheduledJobWithBodyWithResponse request with any body
	CreateClientScheduledJobWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error)

	CreateClientScheduledJobWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error)

	// CreateClientScheduledTaskWithBodyWithResponse request with any body
	CreateClientScheduledTaskWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error)

	CreateClientScheduledTaskWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error)

	// ReplaceClientTokenWithResponse request
	ReplaceClientTokenWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*ReplaceClientTokenResponse, error)

	// GetCollectorManifestWithResponse request
	GetCollectorManifestWithResponse(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*GetCollectorManifestResponse, error)

	// DownloadCollectorWithResponse request
	DownloadCollectorWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*DownloadCollectorResponse, error)

	// GetCollectorChecksumWithResponse request
	GetCollectorChecksumWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*GetCollectorChecksumResponse, error)

	// GetCompletenessStatsWithResponse request
	GetCompletenessStatsWithResponse(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*GetCompletenessStatsResponse, error)

	// GetComputerEntityWithResponse request
	GetComputerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*GetComputerEntityResponse, error)

	// GetComputerEntityAdminRightsWithResponse request
	GetComputerEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminRightsResponse, error)

	// GetComputerEntityAdminsWithResponse request
	GetComputerEntityAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminsResponse, error)

	// GetComputerEntityConstrainedDelegationRightsWithResponse request
	GetComputerEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedDelegationRightsResponse, error)

	// GetComputerEntityConstrainedUsersWithResponse request
	GetComputerEntityConstrainedUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedUsersResponse, error)

	// GetComputerEntityControllablesWithResponse request
	GetComputerEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllablesResponse, error)

	// GetComputerEntityControllersWithResponse request
	GetComputerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllersResponse, error)

	// GetComputerEntityDcomRightsWithResponse request
	GetComputerEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomRightsResponse, error)

	// GetComputerEntityDcomUsersWithResponse request
	GetComputerEntityDcomUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomUsersResponse, error)

	// GetComputerEntityGroupMembershipWithResponse request
	GetComputerEntityGroupMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*GetComputerEntityGroupMembershipResponse, error)

	// GetComputerEntityPsRemoteRightsWithResponse request
	GetComputerEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteRightsResponse, error)

	// GetComputerEntityPsRemoteUsersWithResponse request
	GetComputerEntityPsRemoteUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteUsersResponse, error)

	// GetComputerEntityRdpRightsWithResponse request
	GetComputerEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpRightsResponse, error)

	// GetComputerEntityRdpUsersWithResponse request
	GetComputerEntityRdpUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpUsersResponse, error)

	// GetComputerEntitySessionsWithResponse request
	GetComputerEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySessionsResponse, error)

	// GetComputerEntitySqlAdminsWithResponse request
	GetComputerEntitySqlAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySqlAdminsResponse, error)

	// ListAppConfigParamsWithResponse request
	ListAppConfigParamsWithResponse(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*ListAppConfigParamsResponse, error)

	// SetAppConfigParamWithBodyWithResponse request with any body
	SetAppConfigParamWithBodyWithResponse(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error)

	SetAppConfigParamWithResponse(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error)

	// GetContainerEntityWithResponse request
	GetContainerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*GetContainerEntityResponse, error)

	// GetContainerEntityControllersWithResponse request
	GetContainerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetContainerEntityControllersResponse, error)

	// GetDatapipeStatusWithResponse request
	GetDatapipeStatusWithResponse(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*GetDatapipeStatusResponse, error)

	// ExportAttackPathFindingsWithResponse request
	ExportAttackPathFindingsWithResponse(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*ExportAttackPathFindingsResponse, error)

	// ListAvailableAttackPathTypesForDomainWithResponse request
	ListAvailableAttackPathTypesForDomainWithResponse(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*ListAvailableAttackPathTypesForDomainResponse, error)

	// ListDomainAttackPathsDetailsWithResponse request
	ListDomainAttackPathsDetailsWithResponse(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*ListDomainAttackPathsDetailsResponse, error)

	// ListAttackPathSparklineValuesWithResponse request
	ListAttackPathSparklineValuesWithResponse(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*ListAttackPathSparklineValuesResponse, error)

	// GetDomainEntityWithResponse request
	GetDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*GetDomainEntityResponse, error)

	// UpdateDomainEntityWithBodyWithResponse request with any body
	UpdateDomainEntityWithBodyWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error)

	UpdateDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error)

	// GetDomainEntityComputersWithResponse request
	GetDomainEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityComputersResponse, error)

	// GetDomainEntityControllersWithResponse request
	GetDomainEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityControllersResponse, error)

	// GetDomainEntityDcSyncersWithResponse request
	GetDomainEntityDcSyncersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityDcSyncersResponse, error)

	// GetDomainEntityForeignAdminsWithResponse request
	GetDomainEntityForeignAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignAdminsResponse, error)

	// GetDomainEntityForeignGpoControllersWithResponse request
	GetDomainEntityForeignGpoControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGpoControllersResponse, error)

	// GetDomainEntityForeignGroupsWithResponse request
	GetDomainEntityForeignGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGroupsResponse, error)

	// GetDomainEntityForeignUsersWithResponse request
	GetDomainEntityForeignUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignUsersResponse, error)

	// GetDomainEntityGposWithResponse request
	GetDomainEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGposResponse, error)

	// GetDomainEntityGroupsWithResponse request
	GetDomainEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGroupsResponse, error)

	// GetDomainEntityInboundTrustsWithResponse request
	GetDomainEntityInboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityInboundTrustsResponse, error)

	// GetDomainEntityLinkedGposWithResponse request
	GetDomainEntityLinkedGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityLinkedGposResponse, error)

	// GetDomainEntityOusWithResponse request
	GetDomainEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOusResponse, error)

	// GetDomainEntityOutboundTrustsWithResponse request
	GetDomainEntityOutboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOutboundTrustsResponse, error)

	// GetDomainEntityUsersWithResponse request
	GetDomainEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityUsersResponse, error)

	// GetEnterpriseCaEntityWithResponse request
	GetEnterpriseCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityResponse, error)

	// GetEnterpriseCaEntityControllersWithResponse request
	GetEnterpriseCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityControllersResponse, error)

	// ListClientSchedulesWithResponse request
	ListClientSchedulesWithResponse(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*ListClientSchedulesResponse, error)

	// CreateClientScheduleWithBodyWithResponse request with any body
	CreateClientScheduleWithBodyWithResponse(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error)

	CreateClientScheduleWithResponse(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error)

	// DeleteClientEventWithResponse request
	DeleteClientEventWithResponse(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*DeleteClientEventResponse, error)

	// GetClientScheduleWithResponse request
	GetClientScheduleWithResponse(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*GetClientScheduleResponse, error)

	// UpdateClientEventWithBodyWithResponse request with any body
	UpdateClientEventWithBodyWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error)

	UpdateClientEventWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error)

	// ListFeatureFlagsWithResponse request
	ListFeatureFlagsWithResponse(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*ListFeatureFlagsResponse, error)

	// ToggleFeatureFlagWithResponse request
	ToggleFeatureFlagWithResponse(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*ToggleFeatureFlagResponse, error)

	// ListFileUploadJobsWithResponse request
	ListFileUploadJobsWithResponse(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*ListFileUploadJobsResponse, error)

	// ListAcceptedFileUploadTypesWithResponse request
	ListAcceptedFileUploadTypesWithResponse(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*ListAcceptedFileUploadTypesResponse, error)

	// CreateFileUploadJobWithResponse request
	CreateFileUploadJobWithResponse(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*CreateFileUploadJobResponse, error)

	// UploadFileToJobWithBodyWithResponse request with any body
	UploadFileToJobWithBodyWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error)

	UploadFileToJobWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error)

	// EndFileUploadJobWithResponse request
	EndFileUploadJobWithResponse(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*EndFileUploadJobResponse, error)

	// GetGpoEntityWithResponse request
	GetGpoEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*GetGpoEntityResponse, error)

	// GetGpoEntityComputersWithResponse request
	GetGpoEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityComputersResponse, error)

	// GetGpoEntityControllersWithResponse request
	GetGpoEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityControllersResponse, error)

	// GetGpoEntityOusWithResponse request
	GetGpoEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*GetGpoEntityOusResponse, error)

	// GetGpoEntityTierZeroWithResponse request
	GetGpoEntityTierZeroWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*GetGpoEntityTierZeroResponse, error)

	// GetGpoEntityUsersWithResponse request
	GetGpoEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityUsersResponse, error)

	// GetSearchResultWithResponse request
	GetSearchResultWithResponse(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*GetSearchResultResponse, error)

	// RunCypherQueryWithBodyWithResponse request with any body
	RunCypherQueryWithBodyWithResponse(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error)

	RunCypherQueryWithResponse(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error)

	// GetPathCompositionWithResponse request
	GetPathCompositionWithResponse(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*GetPathCompositionResponse, error)

	// GetShortestPathWithResponse request
	GetShortestPathWithResponse(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*GetShortestPathResponse, error)

	// GetGroupEntityWithResponse request
	GetGroupEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*GetGroupEntityResponse, error)

	// GetGroupEntityAdminRightsWithResponse request
	GetGroupEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityAdminRightsResponse, error)

	// GetGroupEntityControllablesWithResponse request
	GetGroupEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllablesResponse, error)

	// GetGroupEntityControllersWithResponse request
	GetGroupEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllersResponse, error)

	// GetGroupEntityDcomRightsWithResponse request
	GetGroupEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityDcomRightsResponse, error)

	// GetGroupEntityMembersWithResponse request
	GetGroupEntityMembersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembersResponse, error)

	// GetGroupEntityMembershipsWithResponse request
	GetGroupEntityMembershipsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembershipsResponse, error)

	// GetGroupEntityPsRemoteRightsWithResponse request
	GetGroupEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityPsRemoteRightsResponse, error)

	// GetGroupEntityRdpRightsWithResponse request
	GetGroupEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityRdpRightsResponse, error)

	// GetGroupEntitySessionsWithResponse request
	GetGroupEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetGroupEntitySessionsResponse, error)

	// IngestDataWithResponse request
	IngestDataWithResponse(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*IngestDataResponse, error)

	// GetClientJobsWithResponse request
	GetClientJobsWithResponse(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*GetClientJobsResponse, error)

	// ListAvailableClientJobsWithResponse request
	ListAvailableClientJobsWithResponse(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*ListAvailableClientJobsResponse, error)

	// GetClientCurrentJobWithResponse request
	GetClientCurrentJobWithResponse(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*GetClientCurrentJobResponse, error)

	// EndClientJobWithResponse request
	EndClientJobWithResponse(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*EndClientJobResponse, error)

	// ListClientFinishedJobsWithResponse request
	ListClientFinishedJobsWithResponse(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*ListClientFinishedJobsResponse, error)

	// StartClientJobWithBodyWithResponse request with any body
	StartClientJobWithBodyWithResponse(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error)

	StartClientJobWithResponse(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error)

	// GetClientJobWithResponse request
	GetClientJobWithResponse(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*GetClientJobResponse, error)

	// CancelClientJobWithResponse request
	CancelClientJobWithResponse(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*CancelClientJobResponse, error)

	// GetClientJobLogWithResponse request
	GetClientJobLogWithResponse(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*GetClientJobLogResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// GetLatestTierZeroComboNodeWithResponse request
	GetLatestTierZeroComboNodeWithResponse(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*GetLatestTierZeroComboNodeResponse, error)

	// GetComboTreeGraphWithResponse request
	GetComboTreeGraphWithResponse(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*GetComboTreeGraphResponse, error)

	// GetMetaEntityWithResponse request
	GetMetaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*GetMetaEntityResponse, error)

	// GetNtAuthStoreEntityWithResponse request
	GetNtAuthStoreEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityResponse, error)

	// GetNtAuthStoreEntityControllersWithResponse request
	GetNtAuthStoreEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityControllersResponse, error)

	// GetOuEntityWithResponse request
	GetOuEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*GetOuEntityResponse, error)

	// GetOuEntityComputersWithResponse request
	GetOuEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*GetOuEntityComputersResponse, error)

	// GetOuEntityGposWithResponse request
	GetOuEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*GetOuEntityGposResponse, error)

	// GetOuEntityGroupsWithResponse request
	GetOuEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetOuEntityGroupsResponse, error)

	// GetOuEntityUsersWithResponse request
	GetOuEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*GetOuEntityUsersResponse, error)

	// PathfindingWithResponse request
	PathfindingWithResponse(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*PathfindingResponse, error)

	// ListPermissionsWithResponse request
	ListPermissionsWithResponse(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*ListPermissionsResponse, error)

	// GetPermissionWithResponse request
	GetPermissionWithResponse(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*GetPermissionResponse, error)

	// GetPlatformDataQualityAggregateWithResponse request
	GetPlatformDataQualityAggregateWithResponse(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*GetPlatformDataQualityAggregateResponse, error)

	// GetPostureStatsWithResponse request
	GetPostureStatsWithResponse(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*GetPostureStatsResponse, error)

	// ListRolesWithResponse request
	ListRolesWithResponse(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// GetRootCaEntityWithResponse request
	GetRootCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityResponse, error)

	// GetRootCaEntityControllersWithResponse request
	GetRootCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityControllersResponse, error)

	// ListSamlProvidersWithResponse request
	ListSamlProvidersWithResponse(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*ListSamlProvidersResponse, error)

	// CreateSamlProviderWithBodyWithResponse request with any body
	CreateSamlProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSamlProviderResponse, error)

	// DeleteSamlProviderWithResponse request
	DeleteSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*DeleteSamlProviderResponse, error)

	// GetSamlProviderWithResponse request
	GetSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*GetSamlProviderResponse, error)

	// GetSamlSignSignOnEndpointsWithResponse request
	GetSamlSignSignOnEndpointsWithResponse(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*GetSamlSignSignOnEndpointsResponse, error)

	// ListSavedQueriesWithResponse request
	ListSavedQueriesWithResponse(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*ListSavedQueriesResponse, error)

	// CreateSavedQueryWithBodyWithResponse request with any body
	CreateSavedQueryWithBodyWithResponse(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error)

	CreateSavedQueryWithResponse(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error)

	// DeleteSavedQueryWithResponse request
	DeleteSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*DeleteSavedQueryResponse, error)

	// UpdateSavedQueryWithBodyWithResponse request with any body
	UpdateSavedQueryWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error)

	UpdateSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error)

	// DeleteSavedQueryPermissionsWithBodyWithResponse request with any body
	DeleteSavedQueryPermissionsWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error)

	DeleteSavedQueryPermissionsWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// GetSelfWithResponse request
	GetSelfWithResponse(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*GetSelfResponse, error)

	// GetApiSpecWithResponse request
	GetApiSpecWithResponse(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*GetApiSpecResponse, error)

	// ListAuthTokensWithResponse request
	ListAuthTokensWithResponse(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*ListAuthTokensResponse, error)

	// CreateAuthTokenWithBodyWithResponse request with any body
	CreateAuthTokenWithBodyWithResponse(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error)

	CreateAuthTokenWithResponse(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error)

	// DeleteAuthTokenWithResponse request
	DeleteAuthTokenWithResponse(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*DeleteAuthTokenResponse, error)

	// GetUserEntityWithResponse request
	GetUserEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*GetUserEntityResponse, error)

	// GetUserEntityAdminRightsWithResponse request
	GetUserEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityAdminRightsResponse, error)

	// GetUserEntityConstrainedDelegationRightsWithResponse request
	GetUserEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityConstrainedDelegationRightsResponse, error)

	// GetUserEntityControllablesWithResponse request
	GetUserEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllablesResponse, error)

	// GetUserEntityControllersWithResponse request
	GetUserEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllersResponse, error)

	// GetUserEntityDcomRightsWithResponse request
	GetUserEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityDcomRightsResponse, error)

	// GetUserEntityMembershipWithResponse request
	GetUserEntityMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*GetUserEntityMembershipResponse, error)

	// GetUserEntityPsRemoteRightsWithResponse request
	GetUserEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityPsRemoteRightsResponse, error)

	// GetUserEntityRdpRightsWithResponse request
	GetUserEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityRdpRightsResponse, error)

	// GetUserEntitySessionsWithResponse request
	GetUserEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySessionsResponse, error)

	// GetUserEntitySqlAdminRightsWithResponse request
	GetUserEntitySqlAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySqlAdminRightsResponse, error)

	// GetApiVersionWithResponse request
	GetApiVersionWithResponse(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*GetApiVersionResponse, error)
}

type AcceptEulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AcceptEulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptEulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdDomainDataQualityStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                      `json:"count,omitempty"`
		Data  *[]ModelAdDataQualityStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAdDomainDataQualityStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdDomainDataQualityStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiaCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiaCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiaCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiaCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiaCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiaCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartAnalysisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r StartAnalysisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartAnalysisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AssetGroups *[]ModelAssetGroup `json:"asset_groups,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *ApiErrorWrapper
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelAssetGroupCollection `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupComboNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupComboNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupComboNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupCustomMemberCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CustomMemberCount *int `json:"custom_member_count,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupCustomMemberCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupCustomMemberCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int `json:"count,omitempty"`
		Data  *struct {
			Members *[]ModelAssetGroupMember `json:"members,omitempty"`
		} `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupMemberCountByKindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Counts     *map[string]int `json:"counts,omitempty"`
			TotalCount *int            `json:"total_count,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupMemberCountByKindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupMemberCountByKindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupSelectorsDeprecatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
			RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupSelectorsDeprecatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupSelectorsDeprecatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupSelectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
			RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupSelectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupSelectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetGroupSelectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *ApiErrorWrapper
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAssetGroupSelectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetGroupSelectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttackPathTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAttackPathTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttackPathTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartAnalysisBheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartAnalysisBheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartAnalysisBheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttackPathRiskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseFinding
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAttackPathRiskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttackPathRiskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Logs *[]ModelAuditLog `json:"logs,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelDomainSelector `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAvailableDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAzureTenantDataQualityStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                         `json:"count,omitempty"`
		Data  *[]ModelAzureDataQualityStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAzureTenantDataQualityStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAzureTenantDataQualityStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAzureEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAzureEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAzureEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Users *[]ModelUser `json:"users,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUser `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUser `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RemoveUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			QrCode     *string `json:"qr_code,omitempty"`
			TotpSecret *string `json:"totp_secret,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMfaActivationStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMfaActivationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMfaActivationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ActivateUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrSetUserSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateOrSetUserSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrSetUserSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertTemplateEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertTemplateEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertTemplateEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertTemplateEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertTemplateEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertTemplateEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBloodHoundDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBloodHoundDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBloodHoundDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                  `json:"count,omitempty"`
		Data  *[]ModelClientDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogClientErrorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LogClientErrorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogClientErrorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientCompletedTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientCompletedTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientCompletedTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduledJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduledJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduledJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduledTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduledTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduledTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceClientTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAuthToken `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ReplaceClientTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceClientTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelCollectorManifest `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCollectorManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadCollectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DownloadCollectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadCollectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorChecksumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCollectorChecksumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorChecksumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletenessStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]float64 `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCompletenessStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletenessStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityConstrainedDelegationRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityConstrainedDelegationRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityConstrainedDelegationRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityConstrainedUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityConstrainedUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityConstrainedUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityDcomUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityDcomUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityDcomUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityPsRemoteUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityPsRemoteUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityPsRemoteUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityRdpUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityRdpUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityRdpUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntitySqlAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntitySqlAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntitySqlAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppConfigParamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelAppConfigParam `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAppConfigParamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppConfigParamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAppConfigParamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Key   *string                 `json:"key,omitempty"`
			Value *map[string]interface{} `json:"value,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SetAppConfigParamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAppConfigParamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetContainerEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetContainerEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatapipeStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			LastCompleteAnalysisAt *time.Time          `json:"last_complete_analysis_at,omitempty"`
			Status                 *EnumDatapipeStatus `json:"status,omitempty"`
			UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetDatapipeStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatapipeStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportAttackPathFindingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportAttackPathFindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportAttackPathFindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableAttackPathTypesForDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAvailableAttackPathTypesForDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableAttackPathTypesForDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDomainAttackPathsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListDomainAttackPathsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDomainAttackPathsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttackPathSparklineValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelRiskCounts `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAttackPathSparklineValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttackPathSparklineValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDomainEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Collected *bool `json:"collected,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateDomainEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDomainEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityDcSyncersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityDcSyncersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityDcSyncersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignGpoControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignGpoControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignGpoControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityInboundTrustsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityInboundTrustsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityInboundTrustsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityLinkedGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityLinkedGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityLinkedGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityOusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityOusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityOusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityOutboundTrustsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityOutboundTrustsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityOutboundTrustsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnterpriseCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEnterpriseCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnterpriseCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnterpriseCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEnterpriseCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnterpriseCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                          `json:"count,omitempty"`
		Data  *[]ModelClientScheduleDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteClientEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFeatureFlagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelFeatureFlag `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFeatureFlagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFeatureFlagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleFeatureFlagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ToggleFeatureFlagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleFeatureFlagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFileUploadJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                  `json:"count,omitempty"`
		Data  *[]ModelFileUploadJob `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFileUploadJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFileUploadJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAcceptedFileUploadTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r ListAcceptedFileUploadTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAcceptedFileUploadTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFileUploadJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *ModelFileUploadJob `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateFileUploadJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFileUploadJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFileToJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UploadFileToJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFileToJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndFileUploadJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EndFileUploadJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndFileUploadJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityOusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityOusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityOusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityTierZeroResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityTierZeroResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityTierZeroResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSearchResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunCypherQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RunCypherQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunCypherQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPathCompositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPathCompositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPathCompositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShortestPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetShortestPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShortestPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IngestDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r IngestDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IngestDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableClientJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAvailableClientJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableClientJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientCurrentJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientCurrentJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientCurrentJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EndClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientFinishedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientFinishedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientFinishedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CancelClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Log *string `json:"log,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AuthExpired  *bool               `json:"auth_expired,omitempty"`
			SessionToken *string             `json:"session_token,omitempty"`
			UserId       *openapi_types.UUID `json:"user_id,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestTierZeroComboNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetLatestTierZeroComboNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestTierZeroComboNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComboTreeGraphResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComboTreeGraphResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComboTreeGraphResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Props *map[string]map[string]interface{} `json:"props,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMetaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNtAuthStoreEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNtAuthStoreEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNtAuthStoreEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNtAuthStoreEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNtAuthStoreEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNtAuthStoreEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PathfindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PathfindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PathfindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Permissions *[]ModelPermission `json:"permissions,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelPermission `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformDataQualityAggregateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseDataQualityPlatformAggregate
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPlatformDataQualityAggregateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformDataQualityAggregateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostureStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                    `json:"count,omitempty"`
		Data  *[]ModelRiskPostureStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPostureStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostureStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Roles *[]ModelRole `json:"roles,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelRole `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRootCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRootCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSamlProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			SamlProviders *[]ModelSamlProvider `json:"saml_providers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSamlProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSamlProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSamlProvider `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AffectedUser *[]ModelUser `json:"affected_user,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON409 *ApiErrorWrapper
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSamlProvider `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlSignSignOnEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Endpoints *[]ModelSamlSignOnEndpoint `json:"endpoints,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSamlSignSignOnEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlSignSignOnEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSavedQueriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int               `json:"count,omitempty"`
		Data  *[]ModelSavedQuery `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSavedQueriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSavedQueriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *ModelSavedQuery `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSavedQuery `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSavedQueryPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSavedQueryPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSavedQueryPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelSearchResult `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseAuthenticatedRequester
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetSelfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML200      *openapi_types.File
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetApiSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuthTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Tokens *[]ModelAuthToken `json:"tokens,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAuthTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuthTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAuthToken `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityConstrainedDelegationRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityConstrainedDelegationRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityConstrainedDelegationRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntitySqlAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntitySqlAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntitySqlAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			API *struct {
				CurrentVersion    *string `json:"current_version,omitempty"`
				DeprecatedVersion *string `json:"deprecated_version,omitempty"`
			} `json:"API,omitempty"`
			ServerVersion *string `json:"server_version,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetApiVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AcceptEulaWithResponse request returning *AcceptEulaResponse
func (c *ClientWithResponses) AcceptEulaWithResponse(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*AcceptEulaResponse, error) {
	rsp, err := c.AcceptEula(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEulaResponse(rsp)
}

// GetAdDomainDataQualityStatsWithResponse request returning *GetAdDomainDataQualityStatsResponse
func (c *ClientWithResponses) GetAdDomainDataQualityStatsWithResponse(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAdDomainDataQualityStatsResponse, error) {
	rsp, err := c.GetAdDomainDataQualityStats(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdDomainDataQualityStatsResponse(rsp)
}

// GetAiaCaEntityWithResponse request returning *GetAiaCaEntityResponse
func (c *ClientWithResponses) GetAiaCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityResponse, error) {
	rsp, err := c.GetAiaCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiaCaEntityResponse(rsp)
}

// GetAiaCaEntityControllersWithResponse request returning *GetAiaCaEntityControllersResponse
func (c *ClientWithResponses) GetAiaCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityControllersResponse, error) {
	rsp, err := c.GetAiaCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiaCaEntityControllersResponse(rsp)
}

// StartAnalysisWithResponse request returning *StartAnalysisResponse
func (c *ClientWithResponses) StartAnalysisWithResponse(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*StartAnalysisResponse, error) {
	rsp, err := c.StartAnalysis(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartAnalysisResponse(rsp)
}

// ListAssetGroupsWithResponse request returning *ListAssetGroupsResponse
func (c *ClientWithResponses) ListAssetGroupsWithResponse(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupsResponse, error) {
	rsp, err := c.ListAssetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupsResponse(rsp)
}

// CreateAssetGroupWithBodyWithResponse request with arbitrary body returning *CreateAssetGroupResponse
func (c *ClientWithResponses) CreateAssetGroupWithBodyWithResponse(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error) {
	rsp, err := c.CreateAssetGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateAssetGroupWithResponse(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error) {
	rsp, err := c.CreateAssetGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetGroupResponse(rsp)
}

// DeleteAssetGroupWithResponse request returning *DeleteAssetGroupResponse
func (c *ClientWithResponses) DeleteAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupResponse, error) {
	rsp, err := c.DeleteAssetGroup(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetGroupResponse(rsp)
}

// GetAssetGroupWithResponse request returning *GetAssetGroupResponse
func (c *ClientWithResponses) GetAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*GetAssetGroupResponse, error) {
	rsp, err := c.GetAssetGroup(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupResponse(rsp)
}

// UpdateAssetGroupWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupResponse
func (c *ClientWithResponses) UpdateAssetGroupWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error) {
	rsp, err := c.UpdateAssetGroupWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error) {
	rsp, err := c.UpdateAssetGroup(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupResponse(rsp)
}

// ListAssetGroupCollectionsWithResponse request returning *ListAssetGroupCollectionsResponse
func (c *ClientWithResponses) ListAssetGroupCollectionsWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupCollectionsResponse, error) {
	rsp, err := c.ListAssetGroupCollections(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupCollectionsResponse(rsp)
}

// GetAssetGroupComboNodeWithResponse request returning *GetAssetGroupComboNodeResponse
func (c *ClientWithResponses) GetAssetGroupComboNodeWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*GetAssetGroupComboNodeResponse, error) {
	rsp, err := c.GetAssetGroupComboNode(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupComboNodeResponse(rsp)
}

// GetAssetGroupCustomMemberCountWithResponse request returning *GetAssetGroupCustomMemberCountResponse
func (c *ClientWithResponses) GetAssetGroupCustomMemberCountWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*GetAssetGroupCustomMemberCountResponse, error) {
	rsp, err := c.GetAssetGroupCustomMemberCount(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupCustomMemberCountResponse(rsp)
}

// ListAssetGroupMembersWithResponse request returning *ListAssetGroupMembersResponse
func (c *ClientWithResponses) ListAssetGroupMembersWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMembersResponse, error) {
	rsp, err := c.ListAssetGroupMembers(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupMembersResponse(rsp)
}

// ListAssetGroupMemberCountByKindWithResponse request returning *ListAssetGroupMemberCountByKindResponse
func (c *ClientWithResponses) ListAssetGroupMemberCountByKindWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMemberCountByKindResponse, error) {
	rsp, err := c.ListAssetGroupMemberCountByKind(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupMemberCountByKindResponse(rsp)
}

// UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupSelectorsDeprecatedResponse
func (c *ClientWithResponses) UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsDeprecatedWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupSelectorsDeprecatedWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsDeprecated(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp)
}

// UpdateAssetGroupSelectorsWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupSelectorsResponse
func (c *ClientWithResponses) UpdateAssetGroupSelectorsWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupSelectorsWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectors(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsResponse(rsp)
}

// DeleteAssetGroupSelectorWithResponse request returning *DeleteAssetGroupSelectorResponse
func (c *ClientWithResponses) DeleteAssetGroupSelectorWithResponse(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupSelectorResponse, error) {
	rsp, err := c.DeleteAssetGroupSelector(ctx, assetGroupId, assetGroupSelectorId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetGroupSelectorResponse(rsp)
}

// ListAttackPathTypesWithResponse request returning *ListAttackPathTypesResponse
func (c *ClientWithResponses) ListAttackPathTypesWithResponse(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*ListAttackPathTypesResponse, error) {
	rsp, err := c.ListAttackPathTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttackPathTypesResponse(rsp)
}

// StartAnalysisBheWithResponse request returning *StartAnalysisBheResponse
func (c *ClientWithResponses) StartAnalysisBheWithResponse(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*StartAnalysisBheResponse, error) {
	rsp, err := c.StartAnalysisBhe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartAnalysisBheResponse(rsp)
}

// UpdateAttackPathRiskWithBodyWithResponse request with arbitrary body returning *UpdateAttackPathRiskResponse
func (c *ClientWithResponses) UpdateAttackPathRiskWithBodyWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error) {
	rsp, err := c.UpdateAttackPathRiskWithBody(ctx, attackPathId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttackPathRiskResponse(rsp)
}

func (c *ClientWithResponses) UpdateAttackPathRiskWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error) {
	rsp, err := c.UpdateAttackPathRisk(ctx, attackPathId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttackPathRiskResponse(rsp)
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// GetAvailableDomainsWithResponse request returning *GetAvailableDomainsResponse
func (c *ClientWithResponses) GetAvailableDomainsWithResponse(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*GetAvailableDomainsResponse, error) {
	rsp, err := c.GetAvailableDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableDomainsResponse(rsp)
}

// GetAzureTenantDataQualityStatsWithResponse request returning *GetAzureTenantDataQualityStatsResponse
func (c *ClientWithResponses) GetAzureTenantDataQualityStatsWithResponse(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAzureTenantDataQualityStatsResponse, error) {
	rsp, err := c.GetAzureTenantDataQualityStats(ctx, tenantId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAzureTenantDataQualityStatsResponse(rsp)
}

// GetAzureEntityWithResponse request returning *GetAzureEntityResponse
func (c *ClientWithResponses) GetAzureEntityWithResponse(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*GetAzureEntityResponse, error) {
	rsp, err := c.GetAzureEntity(ctx, entityType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAzureEntityResponse(rsp)
}

// GetEntityWithResponse request returning *GetEntityResponse
func (c *ClientWithResponses) GetEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*GetEntityResponse, error) {
	rsp, err := c.GetEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityResponse(rsp)
}

// GetEntityControllablesWithResponse request returning *GetEntityControllablesResponse
func (c *ClientWithResponses) GetEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetEntityControllablesResponse, error) {
	rsp, err := c.GetEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityControllablesResponse(rsp)
}

// GetEntityControllersWithResponse request returning *GetEntityControllersResponse
func (c *ClientWithResponses) GetEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEntityControllersResponse, error) {
	rsp, err := c.GetEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityControllersResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// RemoveUserMfaWithBodyWithResponse request with arbitrary body returning *RemoveUserMfaResponse
func (c *ClientWithResponses) RemoveUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error) {
	rsp, err := c.RemoveUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserMfaResponse(rsp)
}

func (c *ClientWithResponses) RemoveUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error) {
	rsp, err := c.RemoveUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserMfaResponse(rsp)
}

// AddUserMfaWithBodyWithResponse request with arbitrary body returning *AddUserMfaResponse
func (c *ClientWithResponses) AddUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error) {
	rsp, err := c.AddUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserMfaResponse(rsp)
}

func (c *ClientWithResponses) AddUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error) {
	rsp, err := c.AddUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserMfaResponse(rsp)
}

// GetMfaActivationStatusWithResponse request returning *GetMfaActivationStatusResponse
func (c *ClientWithResponses) GetMfaActivationStatusWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*GetMfaActivationStatusResponse, error) {
	rsp, err := c.GetMfaActivationStatus(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMfaActivationStatusResponse(rsp)
}

// ActivateUserMfaWithBodyWithResponse request with arbitrary body returning *ActivateUserMfaResponse
func (c *ClientWithResponses) ActivateUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error) {
	rsp, err := c.ActivateUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateUserMfaResponse(rsp)
}

func (c *ClientWithResponses) ActivateUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error) {
	rsp, err := c.ActivateUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateUserMfaResponse(rsp)
}

// DeleteUserSecretWithResponse request returning *DeleteUserSecretResponse
func (c *ClientWithResponses) DeleteUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*DeleteUserSecretResponse, error) {
	rsp, err := c.DeleteUserSecret(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserSecretResponse(rsp)
}

// CreateOrSetUserSecretWithBodyWithResponse request with arbitrary body returning *CreateOrSetUserSecretResponse
func (c *ClientWithResponses) CreateOrSetUserSecretWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error) {
	rsp, err := c.CreateOrSetUserSecretWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrSetUserSecretResponse(rsp)
}

func (c *ClientWithResponses) CreateOrSetUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error) {
	rsp, err := c.CreateOrSetUserSecret(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrSetUserSecretResponse(rsp)
}

// GetCertTemplateEntityWithResponse request returning *GetCertTemplateEntityResponse
func (c *ClientWithResponses) GetCertTemplateEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityResponse, error) {
	rsp, err := c.GetCertTemplateEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertTemplateEntityResponse(rsp)
}

// GetCertTemplateEntityControllersWithResponse request returning *GetCertTemplateEntityControllersResponse
func (c *ClientWithResponses) GetCertTemplateEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityControllersResponse, error) {
	rsp, err := c.GetCertTemplateEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertTemplateEntityControllersResponse(rsp)
}

// DeleteBloodHoundDatabaseWithBodyWithResponse request with arbitrary body returning *DeleteBloodHoundDatabaseResponse
func (c *ClientWithResponses) DeleteBloodHoundDatabaseWithBodyWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error) {
	rsp, err := c.DeleteBloodHoundDatabaseWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBloodHoundDatabaseResponse(rsp)
}

func (c *ClientWithResponses) DeleteBloodHoundDatabaseWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error) {
	rsp, err := c.DeleteBloodHoundDatabase(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBloodHoundDatabaseResponse(rsp)
}

// ListClientsWithResponse request returning *ListClientsResponse
func (c *ClientWithResponses) ListClientsWithResponse(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*ListClientsResponse, error) {
	rsp, err := c.ListClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientsResponse(rsp)
}

// CreateClientWithBodyWithResponse request with arbitrary body returning *CreateClientResponse
func (c *ClientWithResponses) CreateClientWithBodyWithResponse(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClientWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

func (c *ClientWithResponses) CreateClientWithResponse(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClient(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

// LogClientErrorWithBodyWithResponse request with arbitrary body returning *LogClientErrorResponse
func (c *ClientWithResponses) LogClientErrorWithBodyWithResponse(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error) {
	rsp, err := c.LogClientErrorWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogClientErrorResponse(rsp)
}

func (c *ClientWithResponses) LogClientErrorWithResponse(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error) {
	rsp, err := c.LogClientError(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogClientErrorResponse(rsp)
}

// UpdateClientInfoWithBodyWithResponse request with arbitrary body returning *UpdateClientInfoResponse
func (c *ClientWithResponses) UpdateClientInfoWithBodyWithResponse(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error) {
	rsp, err := c.UpdateClientInfoWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientInfoResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientInfoWithResponse(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error) {
	rsp, err := c.UpdateClientInfo(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientInfoResponse(rsp)
}

// DeleteClientWithResponse request returning *DeleteClientResponse
func (c *ClientWithResponses) DeleteClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*DeleteClientResponse, error) {
	rsp, err := c.DeleteClient(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientResponse(rsp)
}

// GetClientWithResponse request returning *GetClientResponse
func (c *ClientWithResponses) GetClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error) {
	rsp, err := c.GetClient(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientResponse(rsp)
}

// UpdateClientWithBodyWithResponse request with arbitrary body returning *UpdateClientResponse
func (c *ClientWithResponses) UpdateClientWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error) {
	rsp, err := c.UpdateClientWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error) {
	rsp, err := c.UpdateClient(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientResponse(rsp)
}

// ListClientCompletedJobsWithResponse request returning *ListClientCompletedJobsResponse
func (c *ClientWithResponses) ListClientCompletedJobsWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListClientCompletedJobsResponse, error) {
	rsp, err := c.ListClientCompletedJobs(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientCompletedJobsResponse(rsp)
}

// ListClientCompletedTasksWithResponse request returning *ListClientCompletedTasksResponse
func (c *ClientWithResponses) ListClientCompletedTasksWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*ListClientCompletedTasksResponse, error) {
	rsp, err := c.ListClientCompletedTasks(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientCompletedTasksResponse(rsp)
}

// CreateClientScheduledJobWithBodyWithResponse request with arbitrary body returning *CreateClientScheduledJobResponse
func (c *ClientWithResponses) CreateClientScheduledJobWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error) {
	rsp, err := c.CreateClientScheduledJobWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledJobResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduledJobWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error) {
	rsp, err := c.CreateClientScheduledJob(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledJobResponse(rsp)
}

// CreateClientScheduledTaskWithBodyWithResponse request with arbitrary body returning *CreateClientScheduledTaskResponse
func (c *ClientWithResponses) CreateClientScheduledTaskWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error) {
	rsp, err := c.CreateClientScheduledTaskWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledTaskResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduledTaskWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error) {
	rsp, err := c.CreateClientScheduledTask(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledTaskResponse(rsp)
}

// ReplaceClientTokenWithResponse request returning *ReplaceClientTokenResponse
func (c *ClientWithResponses) ReplaceClientTokenWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*ReplaceClientTokenResponse, error) {
	rsp, err := c.ReplaceClientToken(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceClientTokenResponse(rsp)
}

// GetCollectorManifestWithResponse request returning *GetCollectorManifestResponse
func (c *ClientWithResponses) GetCollectorManifestWithResponse(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*GetCollectorManifestResponse, error) {
	rsp, err := c.GetCollectorManifest(ctx, collectorType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorManifestResponse(rsp)
}

// DownloadCollectorWithResponse request returning *DownloadCollectorResponse
func (c *ClientWithResponses) DownloadCollectorWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*DownloadCollectorResponse, error) {
	rsp, err := c.DownloadCollector(ctx, collectorType, releaseTag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadCollectorResponse(rsp)
}

// GetCollectorChecksumWithResponse request returning *GetCollectorChecksumResponse
func (c *ClientWithResponses) GetCollectorChecksumWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*GetCollectorChecksumResponse, error) {
	rsp, err := c.GetCollectorChecksum(ctx, collectorType, releaseTag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorChecksumResponse(rsp)
}

// GetCompletenessStatsWithResponse request returning *GetCompletenessStatsResponse
func (c *ClientWithResponses) GetCompletenessStatsWithResponse(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*GetCompletenessStatsResponse, error) {
	rsp, err := c.GetCompletenessStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletenessStatsResponse(rsp)
}

// GetComputerEntityWithResponse request returning *GetComputerEntityResponse
func (c *ClientWithResponses) GetComputerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*GetComputerEntityResponse, error) {
	rsp, err := c.GetComputerEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityResponse(rsp)
}

// GetComputerEntityAdminRightsWithResponse request returning *GetComputerEntityAdminRightsResponse
func (c *ClientWithResponses) GetComputerEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminRightsResponse, error) {
	rsp, err := c.GetComputerEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityAdminRightsResponse(rsp)
}

// GetComputerEntityAdminsWithResponse request returning *GetComputerEntityAdminsResponse
func (c *ClientWithResponses) GetComputerEntityAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminsResponse, error) {
	rsp, err := c.GetComputerEntityAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityAdminsResponse(rsp)
}

// GetComputerEntityConstrainedDelegationRightsWithResponse request returning *GetComputerEntityConstrainedDelegationRightsResponse
func (c *ClientWithResponses) GetComputerEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedDelegationRightsResponse, error) {
	rsp, err := c.GetComputerEntityConstrainedDelegationRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityConstrainedDelegationRightsResponse(rsp)
}

// GetComputerEntityConstrainedUsersWithResponse request returning *GetComputerEntityConstrainedUsersResponse
func (c *ClientWithResponses) GetComputerEntityConstrainedUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedUsersResponse, error) {
	rsp, err := c.GetComputerEntityConstrainedUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityConstrainedUsersResponse(rsp)
}

// GetComputerEntityControllablesWithResponse request returning *GetComputerEntityControllablesResponse
func (c *ClientWithResponses) GetComputerEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllablesResponse, error) {
	rsp, err := c.GetComputerEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityControllablesResponse(rsp)
}

// GetComputerEntityControllersWithResponse request returning *GetComputerEntityControllersResponse
func (c *ClientWithResponses) GetComputerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllersResponse, error) {
	rsp, err := c.GetComputerEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityControllersResponse(rsp)
}

// GetComputerEntityDcomRightsWithResponse request returning *GetComputerEntityDcomRightsResponse
func (c *ClientWithResponses) GetComputerEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomRightsResponse, error) {
	rsp, err := c.GetComputerEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityDcomRightsResponse(rsp)
}

// GetComputerEntityDcomUsersWithResponse request returning *GetComputerEntityDcomUsersResponse
func (c *ClientWithResponses) GetComputerEntityDcomUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomUsersResponse, error) {
	rsp, err := c.GetComputerEntityDcomUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityDcomUsersResponse(rsp)
}

// GetComputerEntityGroupMembershipWithResponse request returning *GetComputerEntityGroupMembershipResponse
func (c *ClientWithResponses) GetComputerEntityGroupMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*GetComputerEntityGroupMembershipResponse, error) {
	rsp, err := c.GetComputerEntityGroupMembership(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityGroupMembershipResponse(rsp)
}

// GetComputerEntityPsRemoteRightsWithResponse request returning *GetComputerEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetComputerEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetComputerEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityPsRemoteRightsResponse(rsp)
}

// GetComputerEntityPsRemoteUsersWithResponse request returning *GetComputerEntityPsRemoteUsersResponse
func (c *ClientWithResponses) GetComputerEntityPsRemoteUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteUsersResponse, error) {
	rsp, err := c.GetComputerEntityPsRemoteUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityPsRemoteUsersResponse(rsp)
}

// GetComputerEntityRdpRightsWithResponse request returning *GetComputerEntityRdpRightsResponse
func (c *ClientWithResponses) GetComputerEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpRightsResponse, error) {
	rsp, err := c.GetComputerEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityRdpRightsResponse(rsp)
}

// GetComputerEntityRdpUsersWithResponse request returning *GetComputerEntityRdpUsersResponse
func (c *ClientWithResponses) GetComputerEntityRdpUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpUsersResponse, error) {
	rsp, err := c.GetComputerEntityRdpUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityRdpUsersResponse(rsp)
}

// GetComputerEntitySessionsWithResponse request returning *GetComputerEntitySessionsResponse
func (c *ClientWithResponses) GetComputerEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySessionsResponse, error) {
	rsp, err := c.GetComputerEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntitySessionsResponse(rsp)
}

// GetComputerEntitySqlAdminsWithResponse request returning *GetComputerEntitySqlAdminsResponse
func (c *ClientWithResponses) GetComputerEntitySqlAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySqlAdminsResponse, error) {
	rsp, err := c.GetComputerEntitySqlAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntitySqlAdminsResponse(rsp)
}

// ListAppConfigParamsWithResponse request returning *ListAppConfigParamsResponse
func (c *ClientWithResponses) ListAppConfigParamsWithResponse(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*ListAppConfigParamsResponse, error) {
	rsp, err := c.ListAppConfigParams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppConfigParamsResponse(rsp)
}

// SetAppConfigParamWithBodyWithResponse request with arbitrary body returning *SetAppConfigParamResponse
func (c *ClientWithResponses) SetAppConfigParamWithBodyWithResponse(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error) {
	rsp, err := c.SetAppConfigParamWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppConfigParamResponse(rsp)
}

func (c *ClientWithResponses) SetAppConfigParamWithResponse(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error) {
	rsp, err := c.SetAppConfigParam(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppConfigParamResponse(rsp)
}

// GetContainerEntityWithResponse request returning *GetContainerEntityResponse
func (c *ClientWithResponses) GetContainerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*GetContainerEntityResponse, error) {
	rsp, err := c.GetContainerEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerEntityResponse(rsp)
}

// GetContainerEntityControllersWithResponse request returning *GetContainerEntityControllersResponse
func (c *ClientWithResponses) GetContainerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetContainerEntityControllersResponse, error) {
	rsp, err := c.GetContainerEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerEntityControllersResponse(rsp)
}

// GetDatapipeStatusWithResponse request returning *GetDatapipeStatusResponse
func (c *ClientWithResponses) GetDatapipeStatusWithResponse(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*GetDatapipeStatusResponse, error) {
	rsp, err := c.GetDatapipeStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatapipeStatusResponse(rsp)
}

// ExportAttackPathFindingsWithResponse request returning *ExportAttackPathFindingsResponse
func (c *ClientWithResponses) ExportAttackPathFindingsWithResponse(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*ExportAttackPathFindingsResponse, error) {
	rsp, err := c.ExportAttackPathFindings(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAttackPathFindingsResponse(rsp)
}

// ListAvailableAttackPathTypesForDomainWithResponse request returning *ListAvailableAttackPathTypesForDomainResponse
func (c *ClientWithResponses) ListAvailableAttackPathTypesForDomainWithResponse(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*ListAvailableAttackPathTypesForDomainResponse, error) {
	rsp, err := c.ListAvailableAttackPathTypesForDomain(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableAttackPathTypesForDomainResponse(rsp)
}

// ListDomainAttackPathsDetailsWithResponse request returning *ListDomainAttackPathsDetailsResponse
func (c *ClientWithResponses) ListDomainAttackPathsDetailsWithResponse(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*ListDomainAttackPathsDetailsResponse, error) {
	rsp, err := c.ListDomainAttackPathsDetails(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDomainAttackPathsDetailsResponse(rsp)
}

// ListAttackPathSparklineValuesWithResponse request returning *ListAttackPathSparklineValuesResponse
func (c *ClientWithResponses) ListAttackPathSparklineValuesWithResponse(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*ListAttackPathSparklineValuesResponse, error) {
	rsp, err := c.ListAttackPathSparklineValues(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttackPathSparklineValuesResponse(rsp)
}

// GetDomainEntityWithResponse request returning *GetDomainEntityResponse
func (c *ClientWithResponses) GetDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*GetDomainEntityResponse, error) {
	rsp, err := c.GetDomainEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityResponse(rsp)
}

// UpdateDomainEntityWithBodyWithResponse request with arbitrary body returning *UpdateDomainEntityResponse
func (c *ClientWithResponses) UpdateDomainEntityWithBodyWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error) {
	rsp, err := c.UpdateDomainEntityWithBody(ctx, objectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainEntityResponse(rsp)
}

func (c *ClientWithResponses) UpdateDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error) {
	rsp, err := c.UpdateDomainEntity(ctx, objectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainEntityResponse(rsp)
}

// GetDomainEntityComputersWithResponse request returning *GetDomainEntityComputersResponse
func (c *ClientWithResponses) GetDomainEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityComputersResponse, error) {
	rsp, err := c.GetDomainEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityComputersResponse(rsp)
}

// GetDomainEntityControllersWithResponse request returning *GetDomainEntityControllersResponse
func (c *ClientWithResponses) GetDomainEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityControllersResponse, error) {
	rsp, err := c.GetDomainEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityControllersResponse(rsp)
}

// GetDomainEntityDcSyncersWithResponse request returning *GetDomainEntityDcSyncersResponse
func (c *ClientWithResponses) GetDomainEntityDcSyncersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityDcSyncersResponse, error) {
	rsp, err := c.GetDomainEntityDcSyncers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityDcSyncersResponse(rsp)
}

// GetDomainEntityForeignAdminsWithResponse request returning *GetDomainEntityForeignAdminsResponse
func (c *ClientWithResponses) GetDomainEntityForeignAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignAdminsResponse, error) {
	rsp, err := c.GetDomainEntityForeignAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignAdminsResponse(rsp)
}

// GetDomainEntityForeignGpoControllersWithResponse request returning *GetDomainEntityForeignGpoControllersResponse
func (c *ClientWithResponses) GetDomainEntityForeignGpoControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGpoControllersResponse, error) {
	rsp, err := c.GetDomainEntityForeignGpoControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignGpoControllersResponse(rsp)
}

// GetDomainEntityForeignGroupsWithResponse request returning *GetDomainEntityForeignGroupsResponse
func (c *ClientWithResponses) GetDomainEntityForeignGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGroupsResponse, error) {
	rsp, err := c.GetDomainEntityForeignGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignGroupsResponse(rsp)
}

// GetDomainEntityForeignUsersWithResponse request returning *GetDomainEntityForeignUsersResponse
func (c *ClientWithResponses) GetDomainEntityForeignUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignUsersResponse, error) {
	rsp, err := c.GetDomainEntityForeignUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignUsersResponse(rsp)
}

// GetDomainEntityGposWithResponse request returning *GetDomainEntityGposResponse
func (c *ClientWithResponses) GetDomainEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGposResponse, error) {
	rsp, err := c.GetDomainEntityGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityGposResponse(rsp)
}

// GetDomainEntityGroupsWithResponse request returning *GetDomainEntityGroupsResponse
func (c *ClientWithResponses) GetDomainEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGroupsResponse, error) {
	rsp, err := c.GetDomainEntityGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityGroupsResponse(rsp)
}

// GetDomainEntityInboundTrustsWithResponse request returning *GetDomainEntityInboundTrustsResponse
func (c *ClientWithResponses) GetDomainEntityInboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityInboundTrustsResponse, error) {
	rsp, err := c.GetDomainEntityInboundTrusts(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityInboundTrustsResponse(rsp)
}

// GetDomainEntityLinkedGposWithResponse request returning *GetDomainEntityLinkedGposResponse
func (c *ClientWithResponses) GetDomainEntityLinkedGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityLinkedGposResponse, error) {
	rsp, err := c.GetDomainEntityLinkedGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityLinkedGposResponse(rsp)
}

// GetDomainEntityOusWithResponse request returning *GetDomainEntityOusResponse
func (c *ClientWithResponses) GetDomainEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOusResponse, error) {
	rsp, err := c.GetDomainEntityOus(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityOusResponse(rsp)
}

// GetDomainEntityOutboundTrustsWithResponse request returning *GetDomainEntityOutboundTrustsResponse
func (c *ClientWithResponses) GetDomainEntityOutboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOutboundTrustsResponse, error) {
	rsp, err := c.GetDomainEntityOutboundTrusts(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityOutboundTrustsResponse(rsp)
}

// GetDomainEntityUsersWithResponse request returning *GetDomainEntityUsersResponse
func (c *ClientWithResponses) GetDomainEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityUsersResponse, error) {
	rsp, err := c.GetDomainEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityUsersResponse(rsp)
}

// GetEnterpriseCaEntityWithResponse request returning *GetEnterpriseCaEntityResponse
func (c *ClientWithResponses) GetEnterpriseCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityResponse, error) {
	rsp, err := c.GetEnterpriseCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnterpriseCaEntityResponse(rsp)
}

// GetEnterpriseCaEntityControllersWithResponse request returning *GetEnterpriseCaEntityControllersResponse
func (c *ClientWithResponses) GetEnterpriseCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityControllersResponse, error) {
	rsp, err := c.GetEnterpriseCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnterpriseCaEntityControllersResponse(rsp)
}

// ListClientSchedulesWithResponse request returning *ListClientSchedulesResponse
func (c *ClientWithResponses) ListClientSchedulesWithResponse(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*ListClientSchedulesResponse, error) {
	rsp, err := c.ListClientSchedules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientSchedulesResponse(rsp)
}

// CreateClientScheduleWithBodyWithResponse request with arbitrary body returning *CreateClientScheduleResponse
func (c *ClientWithResponses) CreateClientScheduleWithBodyWithResponse(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error) {
	rsp, err := c.CreateClientScheduleWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduleResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduleWithResponse(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error) {
	rsp, err := c.CreateClientSchedule(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduleResponse(rsp)
}

// DeleteClientEventWithResponse request returning *DeleteClientEventResponse
func (c *ClientWithResponses) DeleteClientEventWithResponse(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*DeleteClientEventResponse, error) {
	rsp, err := c.DeleteClientEvent(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientEventResponse(rsp)
}

// GetClientScheduleWithResponse request returning *GetClientScheduleResponse
func (c *ClientWithResponses) GetClientScheduleWithResponse(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*GetClientScheduleResponse, error) {
	rsp, err := c.GetClientSchedule(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientScheduleResponse(rsp)
}

// UpdateClientEventWithBodyWithResponse request with arbitrary body returning *UpdateClientEventResponse
func (c *ClientWithResponses) UpdateClientEventWithBodyWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error) {
	rsp, err := c.UpdateClientEventWithBody(ctx, eventId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientEventResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientEventWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error) {
	rsp, err := c.UpdateClientEvent(ctx, eventId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientEventResponse(rsp)
}

// ListFeatureFlagsWithResponse request returning *ListFeatureFlagsResponse
func (c *ClientWithResponses) ListFeatureFlagsWithResponse(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*ListFeatureFlagsResponse, error) {
	rsp, err := c.ListFeatureFlags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFeatureFlagsResponse(rsp)
}

// ToggleFeatureFlagWithResponse request returning *ToggleFeatureFlagResponse
func (c *ClientWithResponses) ToggleFeatureFlagWithResponse(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*ToggleFeatureFlagResponse, error) {
	rsp, err := c.ToggleFeatureFlag(ctx, featureId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleFeatureFlagResponse(rsp)
}

// ListFileUploadJobsWithResponse request returning *ListFileUploadJobsResponse
func (c *ClientWithResponses) ListFileUploadJobsWithResponse(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*ListFileUploadJobsResponse, error) {
	rsp, err := c.ListFileUploadJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFileUploadJobsResponse(rsp)
}

// ListAcceptedFileUploadTypesWithResponse request returning *ListAcceptedFileUploadTypesResponse
func (c *ClientWithResponses) ListAcceptedFileUploadTypesWithResponse(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*ListAcceptedFileUploadTypesResponse, error) {
	rsp, err := c.ListAcceptedFileUploadTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAcceptedFileUploadTypesResponse(rsp)
}

// CreateFileUploadJobWithResponse request returning *CreateFileUploadJobResponse
func (c *ClientWithResponses) CreateFileUploadJobWithResponse(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*CreateFileUploadJobResponse, error) {
	rsp, err := c.CreateFileUploadJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFileUploadJobResponse(rsp)
}

// UploadFileToJobWithBodyWithResponse request with arbitrary body returning *UploadFileToJobResponse
func (c *ClientWithResponses) UploadFileToJobWithBodyWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error) {
	rsp, err := c.UploadFileToJobWithBody(ctx, fileUploadJobId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileToJobResponse(rsp)
}

func (c *ClientWithResponses) UploadFileToJobWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error) {
	rsp, err := c.UploadFileToJob(ctx, fileUploadJobId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileToJobResponse(rsp)
}

// EndFileUploadJobWithResponse request returning *EndFileUploadJobResponse
func (c *ClientWithResponses) EndFileUploadJobWithResponse(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*EndFileUploadJobResponse, error) {
	rsp, err := c.EndFileUploadJob(ctx, fileUploadJobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndFileUploadJobResponse(rsp)
}

// GetGpoEntityWithResponse request returning *GetGpoEntityResponse
func (c *ClientWithResponses) GetGpoEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*GetGpoEntityResponse, error) {
	rsp, err := c.GetGpoEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityResponse(rsp)
}

// GetGpoEntityComputersWithResponse request returning *GetGpoEntityComputersResponse
func (c *ClientWithResponses) GetGpoEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityComputersResponse, error) {
	rsp, err := c.GetGpoEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityComputersResponse(rsp)
}

// GetGpoEntityControllersWithResponse request returning *GetGpoEntityControllersResponse
func (c *ClientWithResponses) GetGpoEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityControllersResponse, error) {
	rsp, err := c.GetGpoEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityControllersResponse(rsp)
}

// GetGpoEntityOusWithResponse request returning *GetGpoEntityOusResponse
func (c *ClientWithResponses) GetGpoEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*GetGpoEntityOusResponse, error) {
	rsp, err := c.GetGpoEntityOus(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityOusResponse(rsp)
}

// GetGpoEntityTierZeroWithResponse request returning *GetGpoEntityTierZeroResponse
func (c *ClientWithResponses) GetGpoEntityTierZeroWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*GetGpoEntityTierZeroResponse, error) {
	rsp, err := c.GetGpoEntityTierZero(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityTierZeroResponse(rsp)
}

// GetGpoEntityUsersWithResponse request returning *GetGpoEntityUsersResponse
func (c *ClientWithResponses) GetGpoEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityUsersResponse, error) {
	rsp, err := c.GetGpoEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityUsersResponse(rsp)
}

// GetSearchResultWithResponse request returning *GetSearchResultResponse
func (c *ClientWithResponses) GetSearchResultWithResponse(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*GetSearchResultResponse, error) {
	rsp, err := c.GetSearchResult(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultResponse(rsp)
}

// RunCypherQueryWithBodyWithResponse request with arbitrary body returning *RunCypherQueryResponse
func (c *ClientWithResponses) RunCypherQueryWithBodyWithResponse(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error) {
	rsp, err := c.RunCypherQueryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunCypherQueryResponse(rsp)
}

func (c *ClientWithResponses) RunCypherQueryWithResponse(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error) {
	rsp, err := c.RunCypherQuery(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunCypherQueryResponse(rsp)
}

// GetPathCompositionWithResponse request returning *GetPathCompositionResponse
func (c *ClientWithResponses) GetPathCompositionWithResponse(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*GetPathCompositionResponse, error) {
	rsp, err := c.GetPathComposition(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPathCompositionResponse(rsp)
}

// GetShortestPathWithResponse request returning *GetShortestPathResponse
func (c *ClientWithResponses) GetShortestPathWithResponse(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*GetShortestPathResponse, error) {
	rsp, err := c.GetShortestPath(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShortestPathResponse(rsp)
}

// GetGroupEntityWithResponse request returning *GetGroupEntityResponse
func (c *ClientWithResponses) GetGroupEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*GetGroupEntityResponse, error) {
	rsp, err := c.GetGroupEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityResponse(rsp)
}

// GetGroupEntityAdminRightsWithResponse request returning *GetGroupEntityAdminRightsResponse
func (c *ClientWithResponses) GetGroupEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityAdminRightsResponse, error) {
	rsp, err := c.GetGroupEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityAdminRightsResponse(rsp)
}

// GetGroupEntityControllablesWithResponse request returning *GetGroupEntityControllablesResponse
func (c *ClientWithResponses) GetGroupEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllablesResponse, error) {
	rsp, err := c.GetGroupEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityControllablesResponse(rsp)
}

// GetGroupEntityControllersWithResponse request returning *GetGroupEntityControllersResponse
func (c *ClientWithResponses) GetGroupEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllersResponse, error) {
	rsp, err := c.GetGroupEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityControllersResponse(rsp)
}

// GetGroupEntityDcomRightsWithResponse request returning *GetGroupEntityDcomRightsResponse
func (c *ClientWithResponses) GetGroupEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityDcomRightsResponse, error) {
	rsp, err := c.GetGroupEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityDcomRightsResponse(rsp)
}

// GetGroupEntityMembersWithResponse request returning *GetGroupEntityMembersResponse
func (c *ClientWithResponses) GetGroupEntityMembersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembersResponse, error) {
	rsp, err := c.GetGroupEntityMembers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityMembersResponse(rsp)
}

// GetGroupEntityMembershipsWithResponse request returning *GetGroupEntityMembershipsResponse
func (c *ClientWithResponses) GetGroupEntityMembershipsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembershipsResponse, error) {
	rsp, err := c.GetGroupEntityMemberships(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityMembershipsResponse(rsp)
}

// GetGroupEntityPsRemoteRightsWithResponse request returning *GetGroupEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetGroupEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetGroupEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityPsRemoteRightsResponse(rsp)
}

// GetGroupEntityRdpRightsWithResponse request returning *GetGroupEntityRdpRightsResponse
func (c *ClientWithResponses) GetGroupEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityRdpRightsResponse, error) {
	rsp, err := c.GetGroupEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityRdpRightsResponse(rsp)
}

// GetGroupEntitySessionsWithResponse request returning *GetGroupEntitySessionsResponse
func (c *ClientWithResponses) GetGroupEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetGroupEntitySessionsResponse, error) {
	rsp, err := c.GetGroupEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntitySessionsResponse(rsp)
}

// IngestDataWithResponse request returning *IngestDataResponse
func (c *ClientWithResponses) IngestDataWithResponse(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*IngestDataResponse, error) {
	rsp, err := c.IngestData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestDataResponse(rsp)
}

// GetClientJobsWithResponse request returning *GetClientJobsResponse
func (c *ClientWithResponses) GetClientJobsWithResponse(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*GetClientJobsResponse, error) {
	rsp, err := c.GetClientJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobsResponse(rsp)
}

// ListAvailableClientJobsWithResponse request returning *ListAvailableClientJobsResponse
func (c *ClientWithResponses) ListAvailableClientJobsWithResponse(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*ListAvailableClientJobsResponse, error) {
	rsp, err := c.ListAvailableClientJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableClientJobsResponse(rsp)
}

// GetClientCurrentJobWithResponse request returning *GetClientCurrentJobResponse
func (c *ClientWithResponses) GetClientCurrentJobWithResponse(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*GetClientCurrentJobResponse, error) {
	rsp, err := c.GetClientCurrentJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientCurrentJobResponse(rsp)
}

// EndClientJobWithResponse request returning *EndClientJobResponse
func (c *ClientWithResponses) EndClientJobWithResponse(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*EndClientJobResponse, error) {
	rsp, err := c.EndClientJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndClientJobResponse(rsp)
}

// ListClientFinishedJobsWithResponse request returning *ListClientFinishedJobsResponse
func (c *ClientWithResponses) ListClientFinishedJobsWithResponse(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*ListClientFinishedJobsResponse, error) {
	rsp, err := c.ListClientFinishedJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientFinishedJobsResponse(rsp)
}

// StartClientJobWithBodyWithResponse request with arbitrary body returning *StartClientJobResponse
func (c *ClientWithResponses) StartClientJobWithBodyWithResponse(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error) {
	rsp, err := c.StartClientJobWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartClientJobResponse(rsp)
}

func (c *ClientWithResponses) StartClientJobWithResponse(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error) {
	rsp, err := c.StartClientJob(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartClientJobResponse(rsp)
}

// GetClientJobWithResponse request returning *GetClientJobResponse
func (c *ClientWithResponses) GetClientJobWithResponse(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*GetClientJobResponse, error) {
	rsp, err := c.GetClientJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobResponse(rsp)
}

// CancelClientJobWithResponse request returning *CancelClientJobResponse
func (c *ClientWithResponses) CancelClientJobWithResponse(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*CancelClientJobResponse, error) {
	rsp, err := c.CancelClientJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelClientJobResponse(rsp)
}

// GetClientJobLogWithResponse request returning *GetClientJobLogResponse
func (c *ClientWithResponses) GetClientJobLogWithResponse(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*GetClientJobLogResponse, error) {
	rsp, err := c.GetClientJobLog(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobLogResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// GetLatestTierZeroComboNodeWithResponse request returning *GetLatestTierZeroComboNodeResponse
func (c *ClientWithResponses) GetLatestTierZeroComboNodeWithResponse(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*GetLatestTierZeroComboNodeResponse, error) {
	rsp, err := c.GetLatestTierZeroComboNode(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestTierZeroComboNodeResponse(rsp)
}

// GetComboTreeGraphWithResponse request returning *GetComboTreeGraphResponse
func (c *ClientWithResponses) GetComboTreeGraphWithResponse(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*GetComboTreeGraphResponse, error) {
	rsp, err := c.GetComboTreeGraph(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComboTreeGraphResponse(rsp)
}

// GetMetaEntityWithResponse request returning *GetMetaEntityResponse
func (c *ClientWithResponses) GetMetaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*GetMetaEntityResponse, error) {
	rsp, err := c.GetMetaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetaEntityResponse(rsp)
}

// GetNtAuthStoreEntityWithResponse request returning *GetNtAuthStoreEntityResponse
func (c *ClientWithResponses) GetNtAuthStoreEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityResponse, error) {
	rsp, err := c.GetNtAuthStoreEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNtAuthStoreEntityResponse(rsp)
}

// GetNtAuthStoreEntityControllersWithResponse request returning *GetNtAuthStoreEntityControllersResponse
func (c *ClientWithResponses) GetNtAuthStoreEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityControllersResponse, error) {
	rsp, err := c.GetNtAuthStoreEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNtAuthStoreEntityControllersResponse(rsp)
}

// GetOuEntityWithResponse request returning *GetOuEntityResponse
func (c *ClientWithResponses) GetOuEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*GetOuEntityResponse, error) {
	rsp, err := c.GetOuEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityResponse(rsp)
}

// GetOuEntityComputersWithResponse request returning *GetOuEntityComputersResponse
func (c *ClientWithResponses) GetOuEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*GetOuEntityComputersResponse, error) {
	rsp, err := c.GetOuEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityComputersResponse(rsp)
}

// GetOuEntityGposWithResponse request returning *GetOuEntityGposResponse
func (c *ClientWithResponses) GetOuEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*GetOuEntityGposResponse, error) {
	rsp, err := c.GetOuEntityGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityGposResponse(rsp)
}

// GetOuEntityGroupsWithResponse request returning *GetOuEntityGroupsResponse
func (c *ClientWithResponses) GetOuEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetOuEntityGroupsResponse, error) {
	rsp, err := c.GetOuEntityGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityGroupsResponse(rsp)
}

// GetOuEntityUsersWithResponse request returning *GetOuEntityUsersResponse
func (c *ClientWithResponses) GetOuEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*GetOuEntityUsersResponse, error) {
	rsp, err := c.GetOuEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityUsersResponse(rsp)
}

// PathfindingWithResponse request returning *PathfindingResponse
func (c *ClientWithResponses) PathfindingWithResponse(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*PathfindingResponse, error) {
	rsp, err := c.Pathfinding(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePathfindingResponse(rsp)
}

// ListPermissionsWithResponse request returning *ListPermissionsResponse
func (c *ClientWithResponses) ListPermissionsWithResponse(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*ListPermissionsResponse, error) {
	rsp, err := c.ListPermissions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsResponse(rsp)
}

// GetPermissionWithResponse request returning *GetPermissionResponse
func (c *ClientWithResponses) GetPermissionWithResponse(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*GetPermissionResponse, error) {
	rsp, err := c.GetPermission(ctx, permissionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionResponse(rsp)
}

// GetPlatformDataQualityAggregateWithResponse request returning *GetPlatformDataQualityAggregateResponse
func (c *ClientWithResponses) GetPlatformDataQualityAggregateWithResponse(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*GetPlatformDataQualityAggregateResponse, error) {
	rsp, err := c.GetPlatformDataQualityAggregate(ctx, platformId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformDataQualityAggregateResponse(rsp)
}

// GetPostureStatsWithResponse request returning *GetPostureStatsResponse
func (c *ClientWithResponses) GetPostureStatsWithResponse(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*GetPostureStatsResponse, error) {
	rsp, err := c.GetPostureStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostureStatsResponse(rsp)
}

// ListRolesWithResponse request returning *ListRolesResponse
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error) {
	rsp, err := c.ListRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, roleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// GetRootCaEntityWithResponse request returning *GetRootCaEntityResponse
func (c *ClientWithResponses) GetRootCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityResponse, error) {
	rsp, err := c.GetRootCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootCaEntityResponse(rsp)
}

// GetRootCaEntityControllersWithResponse request returning *GetRootCaEntityControllersResponse
func (c *ClientWithResponses) GetRootCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityControllersResponse, error) {
	rsp, err := c.GetRootCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootCaEntityControllersResponse(rsp)
}

// ListSamlProvidersWithResponse request returning *ListSamlProvidersResponse
func (c *ClientWithResponses) ListSamlProvidersWithResponse(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*ListSamlProvidersResponse, error) {
	rsp, err := c.ListSamlProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSamlProvidersResponse(rsp)
}

// CreateSamlProviderWithBodyWithResponse request with arbitrary body returning *CreateSamlProviderResponse
func (c *ClientWithResponses) CreateSamlProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSamlProviderResponse, error) {
	rsp, err := c.CreateSamlProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSamlProviderResponse(rsp)
}

// DeleteSamlProviderWithResponse request returning *DeleteSamlProviderResponse
func (c *ClientWithResponses) DeleteSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*DeleteSamlProviderResponse, error) {
	rsp, err := c.DeleteSamlProvider(ctx, samlProviderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSamlProviderResponse(rsp)
}

// GetSamlProviderWithResponse request returning *GetSamlProviderResponse
func (c *ClientWithResponses) GetSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*GetSamlProviderResponse, error) {
	rsp, err := c.GetSamlProvider(ctx, samlProviderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlProviderResponse(rsp)
}

// GetSamlSignSignOnEndpointsWithResponse request returning *GetSamlSignSignOnEndpointsResponse
func (c *ClientWithResponses) GetSamlSignSignOnEndpointsWithResponse(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*GetSamlSignSignOnEndpointsResponse, error) {
	rsp, err := c.GetSamlSignSignOnEndpoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlSignSignOnEndpointsResponse(rsp)
}

// ListSavedQueriesWithResponse request returning *ListSavedQueriesResponse
func (c *ClientWithResponses) ListSavedQueriesWithResponse(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*ListSavedQueriesResponse, error) {
	rsp, err := c.ListSavedQueries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSavedQueriesResponse(rsp)
}

// CreateSavedQueryWithBodyWithResponse request with arbitrary body returning *CreateSavedQueryResponse
func (c *ClientWithResponses) CreateSavedQueryWithBodyWithResponse(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error) {
	rsp, err := c.CreateSavedQueryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSavedQueryResponse(rsp)
}

func (c *ClientWithResponses) CreateSavedQueryWithResponse(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error) {
	rsp, err := c.CreateSavedQuery(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSavedQueryResponse(rsp)
}

// DeleteSavedQueryWithResponse request returning *DeleteSavedQueryResponse
func (c *ClientWithResponses) DeleteSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*DeleteSavedQueryResponse, error) {
	rsp, err := c.DeleteSavedQuery(ctx, savedQueryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryResponse(rsp)
}

// UpdateSavedQueryWithBodyWithResponse request with arbitrary body returning *UpdateSavedQueryResponse
func (c *ClientWithResponses) UpdateSavedQueryWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error) {
	rsp, err := c.UpdateSavedQueryWithBody(ctx, savedQueryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSavedQueryResponse(rsp)
}

func (c *ClientWithResponses) UpdateSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error) {
	rsp, err := c.UpdateSavedQuery(ctx, savedQueryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSavedQueryResponse(rsp)
}

// DeleteSavedQueryPermissionsWithBodyWithResponse request with arbitrary body returning *DeleteSavedQueryPermissionsResponse
func (c *ClientWithResponses) DeleteSavedQueryPermissionsWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error) {
	rsp, err := c.DeleteSavedQueryPermissionsWithBody(ctx, savedQueryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryPermissionsResponse(rsp)
}

func (c *ClientWithResponses) DeleteSavedQueryPermissionsWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error) {
	rsp, err := c.DeleteSavedQueryPermissions(ctx, savedQueryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryPermissionsResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// GetSelfWithResponse request returning *GetSelfResponse
func (c *ClientWithResponses) GetSelfWithResponse(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*GetSelfResponse, error) {
	rsp, err := c.GetSelf(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfResponse(rsp)
}

// GetApiSpecWithResponse request returning *GetApiSpecResponse
func (c *ClientWithResponses) GetApiSpecWithResponse(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*GetApiSpecResponse, error) {
	rsp, err := c.GetApiSpec(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiSpecResponse(rsp)
}

// ListAuthTokensWithResponse request returning *ListAuthTokensResponse
func (c *ClientWithResponses) ListAuthTokensWithResponse(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*ListAuthTokensResponse, error) {
	rsp, err := c.ListAuthTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuthTokensResponse(rsp)
}

// CreateAuthTokenWithBodyWithResponse request with arbitrary body returning *CreateAuthTokenResponse
func (c *ClientWithResponses) CreateAuthTokenWithBodyWithResponse(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error) {
	rsp, err := c.CreateAuthTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateAuthTokenWithResponse(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error) {
	rsp, err := c.CreateAuthToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenResponse(rsp)
}

// DeleteAuthTokenWithResponse request returning *DeleteAuthTokenResponse
func (c *ClientWithResponses) DeleteAuthTokenWithResponse(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*DeleteAuthTokenResponse, error) {
	rsp, err := c.DeleteAuthToken(ctx, tokenId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthTokenResponse(rsp)
}

// GetUserEntityWithResponse request returning *GetUserEntityResponse
func (c *ClientWithResponses) GetUserEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*GetUserEntityResponse, error) {
	rsp, err := c.GetUserEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityResponse(rsp)
}

// GetUserEntityAdminRightsWithResponse request returning *GetUserEntityAdminRightsResponse
func (c *ClientWithResponses) GetUserEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityAdminRightsResponse, error) {
	rsp, err := c.GetUserEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityAdminRightsResponse(rsp)
}

// GetUserEntityConstrainedDelegationRightsWithResponse request returning *GetUserEntityConstrainedDelegationRightsResponse
func (c *ClientWithResponses) GetUserEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityConstrainedDelegationRightsResponse, error) {
	rsp, err := c.GetUserEntityConstrainedDelegationRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityConstrainedDelegationRightsResponse(rsp)
}

// GetUserEntityControllablesWithResponse request returning *GetUserEntityControllablesResponse
func (c *ClientWithResponses) GetUserEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllablesResponse, error) {
	rsp, err := c.GetUserEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityControllablesResponse(rsp)
}

// GetUserEntityControllersWithResponse request returning *GetUserEntityControllersResponse
func (c *ClientWithResponses) GetUserEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllersResponse, error) {
	rsp, err := c.GetUserEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityControllersResponse(rsp)
}

// GetUserEntityDcomRightsWithResponse request returning *GetUserEntityDcomRightsResponse
func (c *ClientWithResponses) GetUserEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityDcomRightsResponse, error) {
	rsp, err := c.GetUserEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityDcomRightsResponse(rsp)
}

// GetUserEntityMembershipWithResponse request returning *GetUserEntityMembershipResponse
func (c *ClientWithResponses) GetUserEntityMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*GetUserEntityMembershipResponse, error) {
	rsp, err := c.GetUserEntityMembership(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityMembershipResponse(rsp)
}

// GetUserEntityPsRemoteRightsWithResponse request returning *GetUserEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetUserEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetUserEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityPsRemoteRightsResponse(rsp)
}

// GetUserEntityRdpRightsWithResponse request returning *GetUserEntityRdpRightsResponse
func (c *ClientWithResponses) GetUserEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityRdpRightsResponse, error) {
	rsp, err := c.GetUserEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityRdpRightsResponse(rsp)
}

// GetUserEntitySessionsWithResponse request returning *GetUserEntitySessionsResponse
func (c *ClientWithResponses) GetUserEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySessionsResponse, error) {
	rsp, err := c.GetUserEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntitySessionsResponse(rsp)
}

// GetUserEntitySqlAdminRightsWithResponse request returning *GetUserEntitySqlAdminRightsResponse
func (c *ClientWithResponses) GetUserEntitySqlAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySqlAdminRightsResponse, error) {
	rsp, err := c.GetUserEntitySqlAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntitySqlAdminRightsResponse(rsp)
}

// GetApiVersionWithResponse request returning *GetApiVersionResponse
func (c *ClientWithResponses) GetApiVersionWithResponse(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*GetApiVersionResponse, error) {
	rsp, err := c.GetApiVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiVersionResponse(rsp)
}

// ParseAcceptEulaResponse parses an HTTP response from a AcceptEulaWithResponse call
func ParseAcceptEulaResponse(rsp *http.Response) (*AcceptEulaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptEulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAdDomainDataQualityStatsResponse parses an HTTP response from a GetAdDomainDataQualityStatsWithResponse call
func ParseGetAdDomainDataQualityStatsResponse(rsp *http.Response) (*GetAdDomainDataQualityStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdDomainDataQualityStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                      `json:"count,omitempty"`
			Data  *[]ModelAdDataQualityStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiaCaEntityResponse parses an HTTP response from a GetAiaCaEntityWithResponse call
func ParseGetAiaCaEntityResponse(rsp *http.Response) (*GetAiaCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiaCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiaCaEntityControllersResponse parses an HTTP response from a GetAiaCaEntityControllersWithResponse call
func ParseGetAiaCaEntityControllersResponse(rsp *http.Response) (*GetAiaCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiaCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartAnalysisResponse parses an HTTP response from a StartAnalysisWithResponse call
func ParseStartAnalysisResponse(rsp *http.Response) (*StartAnalysisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartAnalysisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListAssetGroupsResponse parses an HTTP response from a ListAssetGroupsWithResponse call
func ParseListAssetGroupsResponse(rsp *http.Response) (*ListAssetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AssetGroups *[]ModelAssetGroup `json:"asset_groups,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAssetGroupResponse parses an HTTP response from a CreateAssetGroupWithResponse call
func ParseCreateAssetGroupResponse(rsp *http.Response) (*CreateAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAssetGroupResponse parses an HTTP response from a DeleteAssetGroupWithResponse call
func ParseDeleteAssetGroupResponse(rsp *http.Response) (*DeleteAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupResponse parses an HTTP response from a GetAssetGroupWithResponse call
func ParseGetAssetGroupResponse(rsp *http.Response) (*GetAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupResponse parses an HTTP response from a UpdateAssetGroupWithResponse call
func ParseUpdateAssetGroupResponse(rsp *http.Response) (*UpdateAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupCollectionsResponse parses an HTTP response from a ListAssetGroupCollectionsWithResponse call
func ParseListAssetGroupCollectionsResponse(rsp *http.Response) (*ListAssetGroupCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelAssetGroupCollection `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupComboNodeResponse parses an HTTP response from a GetAssetGroupComboNodeWithResponse call
func ParseGetAssetGroupComboNodeResponse(rsp *http.Response) (*GetAssetGroupComboNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupComboNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupCustomMemberCountResponse parses an HTTP response from a GetAssetGroupCustomMemberCountWithResponse call
func ParseGetAssetGroupCustomMemberCountResponse(rsp *http.Response) (*GetAssetGroupCustomMemberCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupCustomMemberCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CustomMemberCount *int `json:"custom_member_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupMembersResponse parses an HTTP response from a ListAssetGroupMembersWithResponse call
func ParseListAssetGroupMembersResponse(rsp *http.Response) (*ListAssetGroupMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int `json:"count,omitempty"`
			Data  *struct {
				Members *[]ModelAssetGroupMember `json:"members,omitempty"`
			} `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupMemberCountByKindResponse parses an HTTP response from a ListAssetGroupMemberCountByKindWithResponse call
func ParseListAssetGroupMemberCountByKindResponse(rsp *http.Response) (*ListAssetGroupMemberCountByKindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupMemberCountByKindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Counts     *map[string]int `json:"counts,omitempty"`
				TotalCount *int            `json:"total_count,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupSelectorsDeprecatedResponse parses an HTTP response from a UpdateAssetGroupSelectorsDeprecatedWithResponse call
func ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp *http.Response) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupSelectorsDeprecatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
				RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupSelectorsResponse parses an HTTP response from a UpdateAssetGroupSelectorsWithResponse call
func ParseUpdateAssetGroupSelectorsResponse(rsp *http.Response) (*UpdateAssetGroupSelectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupSelectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
				RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAssetGroupSelectorResponse parses an HTTP response from a DeleteAssetGroupSelectorWithResponse call
func ParseDeleteAssetGroupSelectorResponse(rsp *http.Response) (*DeleteAssetGroupSelectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetGroupSelectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttackPathTypesResponse parses an HTTP response from a ListAttackPathTypesWithResponse call
func ParseListAttackPathTypesResponse(rsp *http.Response) (*ListAttackPathTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttackPathTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartAnalysisBheResponse parses an HTTP response from a StartAnalysisBheWithResponse call
func ParseStartAnalysisBheResponse(rsp *http.Response) (*StartAnalysisBheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartAnalysisBheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAttackPathRiskResponse parses an HTTP response from a UpdateAttackPathRiskWithResponse call
func ParseUpdateAttackPathRiskResponse(rsp *http.Response) (*UpdateAttackPathRiskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttackPathRiskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseFinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Logs *[]ModelAuditLog `json:"logs,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAvailableDomainsResponse parses an HTTP response from a GetAvailableDomainsWithResponse call
func ParseGetAvailableDomainsResponse(rsp *http.Response) (*GetAvailableDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelDomainSelector `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAzureTenantDataQualityStatsResponse parses an HTTP response from a GetAzureTenantDataQualityStatsWithResponse call
func ParseGetAzureTenantDataQualityStatsResponse(rsp *http.Response) (*GetAzureTenantDataQualityStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAzureTenantDataQualityStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                         `json:"count,omitempty"`
			Data  *[]ModelAzureDataQualityStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAzureEntityResponse parses an HTTP response from a GetAzureEntityWithResponse call
func ParseGetAzureEntityResponse(rsp *http.Response) (*GetAzureEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAzureEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityResponse parses an HTTP response from a GetEntityWithResponse call
func ParseGetEntityResponse(rsp *http.Response) (*GetEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityControllablesResponse parses an HTTP response from a GetEntityControllablesWithResponse call
func ParseGetEntityControllablesResponse(rsp *http.Response) (*GetEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityControllersResponse parses an HTTP response from a GetEntityControllersWithResponse call
func ParseGetEntityControllersResponse(rsp *http.Response) (*GetEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Users *[]ModelUser `json:"users,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUser `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUser `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveUserMfaResponse parses an HTTP response from a RemoveUserMfaWithResponse call
func ParseRemoveUserMfaResponse(rsp *http.Response) (*RemoveUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddUserMfaResponse parses an HTTP response from a AddUserMfaWithResponse call
func ParseAddUserMfaResponse(rsp *http.Response) (*AddUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				QrCode     *string `json:"qr_code,omitempty"`
				TotpSecret *string `json:"totp_secret,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMfaActivationStatusResponse parses an HTTP response from a GetMfaActivationStatusWithResponse call
func ParseGetMfaActivationStatusResponse(rsp *http.Response) (*GetMfaActivationStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMfaActivationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseActivateUserMfaResponse parses an HTTP response from a ActivateUserMfaWithResponse call
func ParseActivateUserMfaResponse(rsp *http.Response) (*ActivateUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserSecretResponse parses an HTTP response from a DeleteUserSecretWithResponse call
func ParseDeleteUserSecretResponse(rsp *http.Response) (*DeleteUserSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrSetUserSecretResponse parses an HTTP response from a CreateOrSetUserSecretWithResponse call
func ParseCreateOrSetUserSecretResponse(rsp *http.Response) (*CreateOrSetUserSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrSetUserSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertTemplateEntityResponse parses an HTTP response from a GetCertTemplateEntityWithResponse call
func ParseGetCertTemplateEntityResponse(rsp *http.Response) (*GetCertTemplateEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertTemplateEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertTemplateEntityControllersResponse parses an HTTP response from a GetCertTemplateEntityControllersWithResponse call
func ParseGetCertTemplateEntityControllersResponse(rsp *http.Response) (*GetCertTemplateEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertTemplateEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBloodHoundDatabaseResponse parses an HTTP response from a DeleteBloodHoundDatabaseWithResponse call
func ParseDeleteBloodHoundDatabaseResponse(rsp *http.Response) (*DeleteBloodHoundDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBloodHoundDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientsResponse parses an HTTP response from a ListClientsWithResponse call
func ParseListClientsResponse(rsp *http.Response) (*ListClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                  `json:"count,omitempty"`
			Data  *[]ModelClientDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientResponse parses an HTTP response from a CreateClientWithResponse call
func ParseCreateClientResponse(rsp *http.Response) (*CreateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogClientErrorResponse parses an HTTP response from a LogClientErrorWithResponse call
func ParseLogClientErrorResponse(rsp *http.Response) (*LogClientErrorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogClientErrorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientInfoResponse parses an HTTP response from a UpdateClientInfoWithResponse call
func ParseUpdateClientInfoResponse(rsp *http.Response) (*UpdateClientInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientResponse parses an HTTP response from a DeleteClientWithResponse call
func ParseDeleteClientResponse(rsp *http.Response) (*DeleteClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientResponse parses an HTTP response from a GetClientWithResponse call
func ParseGetClientResponse(rsp *http.Response) (*GetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientResponse parses an HTTP response from a UpdateClientWithResponse call
func ParseUpdateClientResponse(rsp *http.Response) (*UpdateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientCompletedJobsResponse parses an HTTP response from a ListClientCompletedJobsWithResponse call
func ParseListClientCompletedJobsResponse(rsp *http.Response) (*ListClientCompletedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientCompletedTasksResponse parses an HTTP response from a ListClientCompletedTasksWithResponse call
func ParseListClientCompletedTasksResponse(rsp *http.Response) (*ListClientCompletedTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientCompletedTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduledJobResponse parses an HTTP response from a CreateClientScheduledJobWithResponse call
func ParseCreateClientScheduledJobResponse(rsp *http.Response) (*CreateClientScheduledJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduledJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduledTaskResponse parses an HTTP response from a CreateClientScheduledTaskWithResponse call
func ParseCreateClientScheduledTaskResponse(rsp *http.Response) (*CreateClientScheduledTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduledTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReplaceClientTokenResponse parses an HTTP response from a ReplaceClientTokenWithResponse call
func ParseReplaceClientTokenResponse(rsp *http.Response) (*ReplaceClientTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceClientTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAuthToken `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorManifestResponse parses an HTTP response from a GetCollectorManifestWithResponse call
func ParseGetCollectorManifestResponse(rsp *http.Response) (*GetCollectorManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelCollectorManifest `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadCollectorResponse parses an HTTP response from a DownloadCollectorWithResponse call
func ParseDownloadCollectorResponse(rsp *http.Response) (*DownloadCollectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadCollectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorChecksumResponse parses an HTTP response from a GetCollectorChecksumWithResponse call
func ParseGetCollectorChecksumResponse(rsp *http.Response) (*GetCollectorChecksumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorChecksumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCompletenessStatsResponse parses an HTTP response from a GetCompletenessStatsWithResponse call
func ParseGetCompletenessStatsResponse(rsp *http.Response) (*GetCompletenessStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletenessStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]float64 `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityResponse parses an HTTP response from a GetComputerEntityWithResponse call
func ParseGetComputerEntityResponse(rsp *http.Response) (*GetComputerEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityAdminRightsResponse parses an HTTP response from a GetComputerEntityAdminRightsWithResponse call
func ParseGetComputerEntityAdminRightsResponse(rsp *http.Response) (*GetComputerEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityAdminsResponse parses an HTTP response from a GetComputerEntityAdminsWithResponse call
func ParseGetComputerEntityAdminsResponse(rsp *http.Response) (*GetComputerEntityAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityConstrainedDelegationRightsResponse parses an HTTP response from a GetComputerEntityConstrainedDelegationRightsWithResponse call
func ParseGetComputerEntityConstrainedDelegationRightsResponse(rsp *http.Response) (*GetComputerEntityConstrainedDelegationRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityConstrainedDelegationRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityConstrainedUsersResponse parses an HTTP response from a GetComputerEntityConstrainedUsersWithResponse call
func ParseGetComputerEntityConstrainedUsersResponse(rsp *http.Response) (*GetComputerEntityConstrainedUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityConstrainedUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityControllablesResponse parses an HTTP response from a GetComputerEntityControllablesWithResponse call
func ParseGetComputerEntityControllablesResponse(rsp *http.Response) (*GetComputerEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityControllersResponse parses an HTTP response from a GetComputerEntityControllersWithResponse call
func ParseGetComputerEntityControllersResponse(rsp *http.Response) (*GetComputerEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityDcomRightsResponse parses an HTTP response from a GetComputerEntityDcomRightsWithResponse call
func ParseGetComputerEntityDcomRightsResponse(rsp *http.Response) (*GetComputerEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityDcomUsersResponse parses an HTTP response from a GetComputerEntityDcomUsersWithResponse call
func ParseGetComputerEntityDcomUsersResponse(rsp *http.Response) (*GetComputerEntityDcomUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityDcomUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityGroupMembershipResponse parses an HTTP response from a GetComputerEntityGroupMembershipWithResponse call
func ParseGetComputerEntityGroupMembershipResponse(rsp *http.Response) (*GetComputerEntityGroupMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityPsRemoteRightsResponse parses an HTTP response from a GetComputerEntityPsRemoteRightsWithResponse call
func ParseGetComputerEntityPsRemoteRightsResponse(rsp *http.Response) (*GetComputerEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityPsRemoteUsersResponse parses an HTTP response from a GetComputerEntityPsRemoteUsersWithResponse call
func ParseGetComputerEntityPsRemoteUsersResponse(rsp *http.Response) (*GetComputerEntityPsRemoteUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityPsRemoteUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityRdpRightsResponse parses an HTTP response from a GetComputerEntityRdpRightsWithResponse call
func ParseGetComputerEntityRdpRightsResponse(rsp *http.Response) (*GetComputerEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityRdpUsersResponse parses an HTTP response from a GetComputerEntityRdpUsersWithResponse call
func ParseGetComputerEntityRdpUsersResponse(rsp *http.Response) (*GetComputerEntityRdpUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityRdpUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntitySessionsResponse parses an HTTP response from a GetComputerEntitySessionsWithResponse call
func ParseGetComputerEntitySessionsResponse(rsp *http.Response) (*GetComputerEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntitySqlAdminsResponse parses an HTTP response from a GetComputerEntitySqlAdminsWithResponse call
func ParseGetComputerEntitySqlAdminsResponse(rsp *http.Response) (*GetComputerEntitySqlAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntitySqlAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAppConfigParamsResponse parses an HTTP response from a ListAppConfigParamsWithResponse call
func ParseListAppConfigParamsResponse(rsp *http.Response) (*ListAppConfigParamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppConfigParamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelAppConfigParam `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetAppConfigParamResponse parses an HTTP response from a SetAppConfigParamWithResponse call
func ParseSetAppConfigParamResponse(rsp *http.Response) (*SetAppConfigParamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAppConfigParamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Key   *string                 `json:"key,omitempty"`
				Value *map[string]interface{} `json:"value,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContainerEntityResponse parses an HTTP response from a GetContainerEntityWithResponse call
func ParseGetContainerEntityResponse(rsp *http.Response) (*GetContainerEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContainerEntityControllersResponse parses an HTTP response from a GetContainerEntityControllersWithResponse call
func ParseGetContainerEntityControllersResponse(rsp *http.Response) (*GetContainerEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatapipeStatusResponse parses an HTTP response from a GetDatapipeStatusWithResponse call
func ParseGetDatapipeStatusResponse(rsp *http.Response) (*GetDatapipeStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatapipeStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				LastCompleteAnalysisAt *time.Time          `json:"last_complete_analysis_at,omitempty"`
				Status                 *EnumDatapipeStatus `json:"status,omitempty"`
				UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseExportAttackPathFindingsResponse parses an HTTP response from a ExportAttackPathFindingsWithResponse call
func ParseExportAttackPathFindingsResponse(rsp *http.Response) (*ExportAttackPathFindingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportAttackPathFindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableAttackPathTypesForDomainResponse parses an HTTP response from a ListAvailableAttackPathTypesForDomainWithResponse call
func ParseListAvailableAttackPathTypesForDomainResponse(rsp *http.Response) (*ListAvailableAttackPathTypesForDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableAttackPathTypesForDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDomainAttackPathsDetailsResponse parses an HTTP response from a ListDomainAttackPathsDetailsWithResponse call
func ParseListDomainAttackPathsDetailsResponse(rsp *http.Response) (*ListDomainAttackPathsDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDomainAttackPathsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttackPathSparklineValuesResponse parses an HTTP response from a ListAttackPathSparklineValuesWithResponse call
func ParseListAttackPathSparklineValuesResponse(rsp *http.Response) (*ListAttackPathSparklineValuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttackPathSparklineValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelRiskCounts `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityResponse parses an HTTP response from a GetDomainEntityWithResponse call
func ParseGetDomainEntityResponse(rsp *http.Response) (*GetDomainEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDomainEntityResponse parses an HTTP response from a UpdateDomainEntityWithResponse call
func ParseUpdateDomainEntityResponse(rsp *http.Response) (*UpdateDomainEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDomainEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Collected *bool `json:"collected,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityComputersResponse parses an HTTP response from a GetDomainEntityComputersWithResponse call
func ParseGetDomainEntityComputersResponse(rsp *http.Response) (*GetDomainEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityControllersResponse parses an HTTP response from a GetDomainEntityControllersWithResponse call
func ParseGetDomainEntityControllersResponse(rsp *http.Response) (*GetDomainEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityDcSyncersResponse parses an HTTP response from a GetDomainEntityDcSyncersWithResponse call
func ParseGetDomainEntityDcSyncersResponse(rsp *http.Response) (*GetDomainEntityDcSyncersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityDcSyncersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignAdminsResponse parses an HTTP response from a GetDomainEntityForeignAdminsWithResponse call
func ParseGetDomainEntityForeignAdminsResponse(rsp *http.Response) (*GetDomainEntityForeignAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignGpoControllersResponse parses an HTTP response from a GetDomainEntityForeignGpoControllersWithResponse call
func ParseGetDomainEntityForeignGpoControllersResponse(rsp *http.Response) (*GetDomainEntityForeignGpoControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignGpoControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignGroupsResponse parses an HTTP response from a GetDomainEntityForeignGroupsWithResponse call
func ParseGetDomainEntityForeignGroupsResponse(rsp *http.Response) (*GetDomainEntityForeignGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignUsersResponse parses an HTTP response from a GetDomainEntityForeignUsersWithResponse call
func ParseGetDomainEntityForeignUsersResponse(rsp *http.Response) (*GetDomainEntityForeignUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityGposResponse parses an HTTP response from a GetDomainEntityGposWithResponse call
func ParseGetDomainEntityGposResponse(rsp *http.Response) (*GetDomainEntityGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityGroupsResponse parses an HTTP response from a GetDomainEntityGroupsWithResponse call
func ParseGetDomainEntityGroupsResponse(rsp *http.Response) (*GetDomainEntityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityInboundTrustsResponse parses an HTTP response from a GetDomainEntityInboundTrustsWithResponse call
func ParseGetDomainEntityInboundTrustsResponse(rsp *http.Response) (*GetDomainEntityInboundTrustsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityInboundTrustsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityLinkedGposResponse parses an HTTP response from a GetDomainEntityLinkedGposWithResponse call
func ParseGetDomainEntityLinkedGposResponse(rsp *http.Response) (*GetDomainEntityLinkedGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityLinkedGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityOusResponse parses an HTTP response from a GetDomainEntityOusWithResponse call
func ParseGetDomainEntityOusResponse(rsp *http.Response) (*GetDomainEntityOusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityOusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityOutboundTrustsResponse parses an HTTP response from a GetDomainEntityOutboundTrustsWithResponse call
func ParseGetDomainEntityOutboundTrustsResponse(rsp *http.Response) (*GetDomainEntityOutboundTrustsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityOutboundTrustsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityUsersResponse parses an HTTP response from a GetDomainEntityUsersWithResponse call
func ParseGetDomainEntityUsersResponse(rsp *http.Response) (*GetDomainEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEnterpriseCaEntityResponse parses an HTTP response from a GetEnterpriseCaEntityWithResponse call
func ParseGetEnterpriseCaEntityResponse(rsp *http.Response) (*GetEnterpriseCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnterpriseCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEnterpriseCaEntityControllersResponse parses an HTTP response from a GetEnterpriseCaEntityControllersWithResponse call
func ParseGetEnterpriseCaEntityControllersResponse(rsp *http.Response) (*GetEnterpriseCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnterpriseCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientSchedulesResponse parses an HTTP response from a ListClientSchedulesWithResponse call
func ParseListClientSchedulesResponse(rsp *http.Response) (*ListClientSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                          `json:"count,omitempty"`
			Data  *[]ModelClientScheduleDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduleResponse parses an HTTP response from a CreateClientScheduleWithResponse call
func ParseCreateClientScheduleResponse(rsp *http.Response) (*CreateClientScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientEventResponse parses an HTTP response from a DeleteClientEventWithResponse call
func ParseDeleteClientEventResponse(rsp *http.Response) (*DeleteClientEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientScheduleResponse parses an HTTP response from a GetClientScheduleWithResponse call
func ParseGetClientScheduleResponse(rsp *http.Response) (*GetClientScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientEventResponse parses an HTTP response from a UpdateClientEventWithResponse call
func ParseUpdateClientEventResponse(rsp *http.Response) (*UpdateClientEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFeatureFlagsResponse parses an HTTP response from a ListFeatureFlagsWithResponse call
func ParseListFeatureFlagsResponse(rsp *http.Response) (*ListFeatureFlagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFeatureFlagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelFeatureFlag `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseToggleFeatureFlagResponse parses an HTTP response from a ToggleFeatureFlagWithResponse call
func ParseToggleFeatureFlagResponse(rsp *http.Response) (*ToggleFeatureFlagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleFeatureFlagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFileUploadJobsResponse parses an HTTP response from a ListFileUploadJobsWithResponse call
func ParseListFileUploadJobsResponse(rsp *http.Response) (*ListFileUploadJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFileUploadJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                  `json:"count,omitempty"`
			Data  *[]ModelFileUploadJob `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAcceptedFileUploadTypesResponse parses an HTTP response from a ListAcceptedFileUploadTypesWithResponse call
func ParseListAcceptedFileUploadTypesResponse(rsp *http.Response) (*ListAcceptedFileUploadTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAcceptedFileUploadTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateFileUploadJobResponse parses an HTTP response from a CreateFileUploadJobWithResponse call
func ParseCreateFileUploadJobResponse(rsp *http.Response) (*CreateFileUploadJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFileUploadJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *ModelFileUploadJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadFileToJobResponse parses an HTTP response from a UploadFileToJobWithResponse call
func ParseUploadFileToJobResponse(rsp *http.Response) (*UploadFileToJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFileToJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEndFileUploadJobResponse parses an HTTP response from a EndFileUploadJobWithResponse call
func ParseEndFileUploadJobResponse(rsp *http.Response) (*EndFileUploadJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndFileUploadJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityResponse parses an HTTP response from a GetGpoEntityWithResponse call
func ParseGetGpoEntityResponse(rsp *http.Response) (*GetGpoEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityComputersResponse parses an HTTP response from a GetGpoEntityComputersWithResponse call
func ParseGetGpoEntityComputersResponse(rsp *http.Response) (*GetGpoEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityControllersResponse parses an HTTP response from a GetGpoEntityControllersWithResponse call
func ParseGetGpoEntityControllersResponse(rsp *http.Response) (*GetGpoEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityOusResponse parses an HTTP response from a GetGpoEntityOusWithResponse call
func ParseGetGpoEntityOusResponse(rsp *http.Response) (*GetGpoEntityOusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityOusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityTierZeroResponse parses an HTTP response from a GetGpoEntityTierZeroWithResponse call
func ParseGetGpoEntityTierZeroResponse(rsp *http.Response) (*GetGpoEntityTierZeroResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityTierZeroResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityUsersResponse parses an HTTP response from a GetGpoEntityUsersWithResponse call
func ParseGetGpoEntityUsersResponse(rsp *http.Response) (*GetGpoEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultResponse parses an HTTP response from a GetSearchResultWithResponse call
func ParseGetSearchResultResponse(rsp *http.Response) (*GetSearchResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRunCypherQueryResponse parses an HTTP response from a RunCypherQueryWithResponse call
func ParseRunCypherQueryResponse(rsp *http.Response) (*RunCypherQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunCypherQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPathCompositionResponse parses an HTTP response from a GetPathCompositionWithResponse call
func ParseGetPathCompositionResponse(rsp *http.Response) (*GetPathCompositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPathCompositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShortestPathResponse parses an HTTP response from a GetShortestPathWithResponse call
func ParseGetShortestPathResponse(rsp *http.Response) (*GetShortestPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShortestPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityResponse parses an HTTP response from a GetGroupEntityWithResponse call
func ParseGetGroupEntityResponse(rsp *http.Response) (*GetGroupEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityAdminRightsResponse parses an HTTP response from a GetGroupEntityAdminRightsWithResponse call
func ParseGetGroupEntityAdminRightsResponse(rsp *http.Response) (*GetGroupEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityControllablesResponse parses an HTTP response from a GetGroupEntityControllablesWithResponse call
func ParseGetGroupEntityControllablesResponse(rsp *http.Response) (*GetGroupEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityControllersResponse parses an HTTP response from a GetGroupEntityControllersWithResponse call
func ParseGetGroupEntityControllersResponse(rsp *http.Response) (*GetGroupEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityDcomRightsResponse parses an HTTP response from a GetGroupEntityDcomRightsWithResponse call
func ParseGetGroupEntityDcomRightsResponse(rsp *http.Response) (*GetGroupEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityMembersResponse parses an HTTP response from a GetGroupEntityMembersWithResponse call
func ParseGetGroupEntityMembersResponse(rsp *http.Response) (*GetGroupEntityMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityMembershipsResponse parses an HTTP response from a GetGroupEntityMembershipsWithResponse call
func ParseGetGroupEntityMembershipsResponse(rsp *http.Response) (*GetGroupEntityMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityPsRemoteRightsResponse parses an HTTP response from a GetGroupEntityPsRemoteRightsWithResponse call
func ParseGetGroupEntityPsRemoteRightsResponse(rsp *http.Response) (*GetGroupEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityRdpRightsResponse parses an HTTP response from a GetGroupEntityRdpRightsWithResponse call
func ParseGetGroupEntityRdpRightsResponse(rsp *http.Response) (*GetGroupEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntitySessionsResponse parses an HTTP response from a GetGroupEntitySessionsWithResponse call
func ParseGetGroupEntitySessionsResponse(rsp *http.Response) (*GetGroupEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIngestDataResponse parses an HTTP response from a IngestDataWithResponse call
func ParseIngestDataResponse(rsp *http.Response) (*IngestDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IngestDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobsResponse parses an HTTP response from a GetClientJobsWithResponse call
func ParseGetClientJobsResponse(rsp *http.Response) (*GetClientJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableClientJobsResponse parses an HTTP response from a ListAvailableClientJobsWithResponse call
func ParseListAvailableClientJobsResponse(rsp *http.Response) (*ListAvailableClientJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableClientJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientCurrentJobResponse parses an HTTP response from a GetClientCurrentJobWithResponse call
func ParseGetClientCurrentJobResponse(rsp *http.Response) (*GetClientCurrentJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientCurrentJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEndClientJobResponse parses an HTTP response from a EndClientJobWithResponse call
func ParseEndClientJobResponse(rsp *http.Response) (*EndClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientFinishedJobsResponse parses an HTTP response from a ListClientFinishedJobsWithResponse call
func ParseListClientFinishedJobsResponse(rsp *http.Response) (*ListClientFinishedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientFinishedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartClientJobResponse parses an HTTP response from a StartClientJobWithResponse call
func ParseStartClientJobResponse(rsp *http.Response) (*StartClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobResponse parses an HTTP response from a GetClientJobWithResponse call
func ParseGetClientJobResponse(rsp *http.Response) (*GetClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelClientJobResponse parses an HTTP response from a CancelClientJobWithResponse call
func ParseCancelClientJobResponse(rsp *http.Response) (*CancelClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobLogResponse parses an HTTP response from a GetClientJobLogWithResponse call
func ParseGetClientJobLogResponse(rsp *http.Response) (*GetClientJobLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Log *string `json:"log,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AuthExpired  *bool               `json:"auth_expired,omitempty"`
				SessionToken *string             `json:"session_token,omitempty"`
				UserId       *openapi_types.UUID `json:"user_id,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetLatestTierZeroComboNodeResponse parses an HTTP response from a GetLatestTierZeroComboNodeWithResponse call
func ParseGetLatestTierZeroComboNodeResponse(rsp *http.Response) (*GetLatestTierZeroComboNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestTierZeroComboNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComboTreeGraphResponse parses an HTTP response from a GetComboTreeGraphWithResponse call
func ParseGetComboTreeGraphResponse(rsp *http.Response) (*GetComboTreeGraphResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComboTreeGraphResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMetaEntityResponse parses an HTTP response from a GetMetaEntityWithResponse call
func ParseGetMetaEntityResponse(rsp *http.Response) (*GetMetaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Props *map[string]map[string]interface{} `json:"props,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNtAuthStoreEntityResponse parses an HTTP response from a GetNtAuthStoreEntityWithResponse call
func ParseGetNtAuthStoreEntityResponse(rsp *http.Response) (*GetNtAuthStoreEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNtAuthStoreEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNtAuthStoreEntityControllersResponse parses an HTTP response from a GetNtAuthStoreEntityControllersWithResponse call
func ParseGetNtAuthStoreEntityControllersResponse(rsp *http.Response) (*GetNtAuthStoreEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNtAuthStoreEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityResponse parses an HTTP response from a GetOuEntityWithResponse call
func ParseGetOuEntityResponse(rsp *http.Response) (*GetOuEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityComputersResponse parses an HTTP response from a GetOuEntityComputersWithResponse call
func ParseGetOuEntityComputersResponse(rsp *http.Response) (*GetOuEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityGposResponse parses an HTTP response from a GetOuEntityGposWithResponse call
func ParseGetOuEntityGposResponse(rsp *http.Response) (*GetOuEntityGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityGroupsResponse parses an HTTP response from a GetOuEntityGroupsWithResponse call
func ParseGetOuEntityGroupsResponse(rsp *http.Response) (*GetOuEntityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityUsersResponse parses an HTTP response from a GetOuEntityUsersWithResponse call
func ParseGetOuEntityUsersResponse(rsp *http.Response) (*GetOuEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePathfindingResponse parses an HTTP response from a PathfindingWithResponse call
func ParsePathfindingResponse(rsp *http.Response) (*PathfindingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PathfindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsResponse parses an HTTP response from a ListPermissionsWithResponse call
func ParseListPermissionsResponse(rsp *http.Response) (*ListPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Permissions *[]ModelPermission `json:"permissions,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionResponse parses an HTTP response from a GetPermissionWithResponse call
func ParseGetPermissionResponse(rsp *http.Response) (*GetPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelPermission `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlatformDataQualityAggregateResponse parses an HTTP response from a GetPlatformDataQualityAggregateWithResponse call
func ParseGetPlatformDataQualityAggregateResponse(rsp *http.Response) (*GetPlatformDataQualityAggregateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformDataQualityAggregateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseDataQualityPlatformAggregate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPostureStatsResponse parses an HTTP response from a GetPostureStatsWithResponse call
func ParseGetPostureStatsResponse(rsp *http.Response) (*GetPostureStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostureStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                    `json:"count,omitempty"`
			Data  *[]ModelRiskPostureStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRolesResponse parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResponse(rsp *http.Response) (*ListRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Roles *[]ModelRole `json:"roles,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelRole `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRootCaEntityResponse parses an HTTP response from a GetRootCaEntityWithResponse call
func ParseGetRootCaEntityResponse(rsp *http.Response) (*GetRootCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRootCaEntityControllersResponse parses an HTTP response from a GetRootCaEntityControllersWithResponse call
func ParseGetRootCaEntityControllersResponse(rsp *http.Response) (*GetRootCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSamlProvidersResponse parses an HTTP response from a ListSamlProvidersWithResponse call
func ParseListSamlProvidersResponse(rsp *http.Response) (*ListSamlProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSamlProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				SamlProviders *[]ModelSamlProvider `json:"saml_providers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSamlProviderResponse parses an HTTP response from a CreateSamlProviderWithResponse call
func ParseCreateSamlProviderResponse(rsp *http.Response) (*CreateSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSamlProvider `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSamlProviderResponse parses an HTTP response from a DeleteSamlProviderWithResponse call
func ParseDeleteSamlProviderResponse(rsp *http.Response) (*DeleteSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AffectedUser *[]ModelUser `json:"affected_user,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSamlProviderResponse parses an HTTP response from a GetSamlProviderWithResponse call
func ParseGetSamlProviderResponse(rsp *http.Response) (*GetSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSamlProvider `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSamlSignSignOnEndpointsResponse parses an HTTP response from a GetSamlSignSignOnEndpointsWithResponse call
func ParseGetSamlSignSignOnEndpointsResponse(rsp *http.Response) (*GetSamlSignSignOnEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlSignSignOnEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Endpoints *[]ModelSamlSignOnEndpoint `json:"endpoints,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSavedQueriesResponse parses an HTTP response from a ListSavedQueriesWithResponse call
func ParseListSavedQueriesResponse(rsp *http.Response) (*ListSavedQueriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSavedQueriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int               `json:"count,omitempty"`
			Data  *[]ModelSavedQuery `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSavedQueryResponse parses an HTTP response from a CreateSavedQueryWithResponse call
func ParseCreateSavedQueryResponse(rsp *http.Response) (*CreateSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *ModelSavedQuery `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSavedQueryResponse parses an HTTP response from a DeleteSavedQueryWithResponse call
func ParseDeleteSavedQueryResponse(rsp *http.Response) (*DeleteSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSavedQueryResponse parses an HTTP response from a UpdateSavedQueryWithResponse call
func ParseUpdateSavedQueryResponse(rsp *http.Response) (*UpdateSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSavedQuery `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSavedQueryPermissionsResponse parses an HTTP response from a DeleteSavedQueryPermissionsWithResponse call
func ParseDeleteSavedQueryPermissionsResponse(rsp *http.Response) (*DeleteSavedQueryPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSavedQueryPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelSearchResult `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSelfResponse parses an HTTP response from a GetSelfWithResponse call
func ParseGetSelfResponse(rsp *http.Response) (*GetSelfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseAuthenticatedRequester
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetApiSpecResponse parses an HTTP response from a GetApiSpecWithResponse call
func ParseGetApiSpecResponse(rsp *http.Response) (*GetApiSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseListAuthTokensResponse parses an HTTP response from a ListAuthTokensWithResponse call
func ParseListAuthTokensResponse(rsp *http.Response) (*ListAuthTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuthTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Tokens *[]ModelAuthToken `json:"tokens,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAuthTokenResponse parses an HTTP response from a CreateAuthTokenWithResponse call
func ParseCreateAuthTokenResponse(rsp *http.Response) (*CreateAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAuthToken `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthTokenResponse parses an HTTP response from a DeleteAuthTokenWithResponse call
func ParseDeleteAuthTokenResponse(rsp *http.Response) (*DeleteAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityResponse parses an HTTP response from a GetUserEntityWithResponse call
func ParseGetUserEntityResponse(rsp *http.Response) (*GetUserEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityAdminRightsResponse parses an HTTP response from a GetUserEntityAdminRightsWithResponse call
func ParseGetUserEntityAdminRightsResponse(rsp *http.Response) (*GetUserEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityConstrainedDelegationRightsResponse parses an HTTP response from a GetUserEntityConstrainedDelegationRightsWithResponse call
func ParseGetUserEntityConstrainedDelegationRightsResponse(rsp *http.Response) (*GetUserEntityConstrainedDelegationRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityConstrainedDelegationRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityControllablesResponse parses an HTTP response from a GetUserEntityControllablesWithResponse call
func ParseGetUserEntityControllablesResponse(rsp *http.Response) (*GetUserEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityControllersResponse parses an HTTP response from a GetUserEntityControllersWithResponse call
func ParseGetUserEntityControllersResponse(rsp *http.Response) (*GetUserEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityDcomRightsResponse parses an HTTP response from a GetUserEntityDcomRightsWithResponse call
func ParseGetUserEntityDcomRightsResponse(rsp *http.Response) (*GetUserEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityMembershipResponse parses an HTTP response from a GetUserEntityMembershipWithResponse call
func ParseGetUserEntityMembershipResponse(rsp *http.Response) (*GetUserEntityMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityPsRemoteRightsResponse parses an HTTP response from a GetUserEntityPsRemoteRightsWithResponse call
func ParseGetUserEntityPsRemoteRightsResponse(rsp *http.Response) (*GetUserEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityRdpRightsResponse parses an HTTP response from a GetUserEntityRdpRightsWithResponse call
func ParseGetUserEntityRdpRightsResponse(rsp *http.Response) (*GetUserEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntitySessionsResponse parses an HTTP response from a GetUserEntitySessionsWithResponse call
func ParseGetUserEntitySessionsResponse(rsp *http.Response) (*GetUserEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntitySqlAdminRightsResponse parses an HTTP response from a GetUserEntitySqlAdminRightsWithResponse call
func ParseGetUserEntitySqlAdminRightsResponse(rsp *http.Response) (*GetUserEntitySqlAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntitySqlAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApiVersionResponse parses an HTTP response from a GetApiVersionWithResponse call
func ParseGetApiVersionResponse(rsp *http.Response) (*GetApiVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				API *struct {
					CurrentVersion    *string `json:"current_version,omitempty"`
					DeprecatedVersion *string `json:"deprecated_version,omitempty"`
				} `json:"API,omitempty"`
				ServerVersion *string `json:"server_version,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+z9e3MbN7I/Dr8VHJ6tyuVwKNlyvGud2qqvIsmOsrGtleTNno38kOAMSMIaAhMAI5nx",
	"k/f+KzSAuZAz5Awvo4vnj8QiiTv6091oNLq/dHw+jTgjTMnO4ZdOhAWeEkUEfJoQHBDRiwQZEaG/CIj0",
	"BY0U5axz2DmH75Ep1UWxJAFSHMmI+HQ0Qxj5sVR8ihSdEh4rRBmSxOcskCiWlI2RmhB0h6lCSbcISxQR",
	"gS5eH//1+Yv9Xqfbobor00en22F4SpKuO92O9Cdkis3YRjgOVedwv9uZUkan8RT+VrNI16BMkTERnT//",
	"7HYirCY9PvxEfOXRYHFiVxOCzM+IBoiPYKCEKapmaEj0yHlEBFYkQJwlY9StpiM09fs06HQ7gvweU0GC",
	"zqESMckPer7fmNHf40z3utsRhbnamUglKBvDRH6PiZj1/JDq/etNZoEelBfwKaZMLrb/64QwhNEtDnUP",
	"IzTQwxkgKlGEpSRBF2E2QyemOsJScp/CLO+omiA96iAOSYAwC9CIMionJECf+FCiEReIYH+CzFjQHQ1D",
	"NMG3BJHPEWYBCVAk9KIpSiSizA/jQK/jQK/WABoc6OkNemhhkCMcyvwo1YRIgiSekmSw0CFn4QwJomLB",
	"NCFhFFKpoA2znDQYyGS7YO3S/bKL13eLV0haZvvsPgw5DwlmSzaCx2tvwvsPj2QD9EC3tvh6wTZZ+E98",
	"2MOBJ5WIfRUL4vk8DHXfeuW/FHaNg35SvJ8pnh3GXwQZdQ47/72XMss986vcwxHtAfuSmk8G1MeK9EY0",
	"VET0lg/Ux54gYyqVmFUYp4/7rnTDwyRCeZKIW+oTWWWgRKi+K9/wUOFvy9ILxwYFDFPefDBxTIOSkQR+",
	"nb0N/HvaW8PsPJ8zJXS/onSEULCfKbiNwZVKMj02wgJPaw5lQyIs6MPv2xgJNFQyjtvlNAW/b4ukslpK",
	"2VAUVSFZPhpTZPdb9Jn4sSbV5RvlSjWyXSGWyqNsTKQqG5Au0rdFdj0a7uPQGwseRxX4AJTuQ+lm+UDI",
	"xx6or6UDG/etertjkpJESk1QqxfLlmx2oaTCQi2ldijRCKVLhZVRMEvGoea0qe1tmCBaK/WwWlRvX0Md",
	"JIiMQyXRcIYGtngfq4HRKnvokhBkWkdmBCggCtPQKLK3OKRaX7XjKFUb04Z3sdYBCUmNWdri259l2vAu",
	"ZmmOtb2QTqkqPpGyeDokQmvyhCmhjw+KIyivT/T6aCyIjDiTpIfe60MAvsU0xMOQwDThWPF3fRgYlM3Q",
	"dF6o+D9bfZrPzUPe0KjGNHRxGGWEx5RhXXzdSUDPaxok8lPgQnnD2eIsLrlQmtR8HsZT1kPHmKEhMXaX",
	"aRwqGoUEjC3yfzVZRYQFCKPJLNIHOj0L3RxhcO7jIiCih46hKZnO9prpgnoIuhQWBAXQkD5TcpY1hFgL",
	"xQ1lQe+alS0KF6o/nK1DuGZN3GIsrJJZxaKN1r/obbZn0QArjAT5PSZSkaCHzkaIcVNIn2gFv6WBPtNC",
	"6+Yoa3dOE8gA9rx7zYZgwDKY1ZXtqddwAA0EjAY+j5kamJZ66JJPk8UyjRMWRJwyJVHAEePqmsk4ivSu",
	"6nUdjAWOJgNovXxFYd6FZNbRQ+10O4RpQvvNfYRWO90ODK7zsdyM5KwWULDAcHEGRgOCzO9mhUOwTsAk",
	"KZE9dGJXzhgPqLTWjVIGbrpa58hfyrCotKudGhWpNCAB0ibKkDZDcRQRYTkZH1mClpZuSKA31bIFEiQ8",
	"TlZnYrUI3VRP51fGyFZML9DfaG5jzasp13PTc1wvnR3NGDFXMbV64NW10ynFUVBHbbDFty9Q04a3KVD/",
	"7HYSGtHNDXHgWbajP+qjM2HwJ46iULdAOdv7JI2GSz7jaWSOdUQILmTn8Ddb6bNKLBcaKlMiJR4Ty+x+",
	"vnz/DkV4FnIcaGSGgWYsIBbYFAs5wWFIgl7nz4/dzkSpqO+0xhf7+8YwTSScXg87ByP8tx9GL194P/z1",
	"2V+9Fz+8fO4ND0a+99x/9fJg9PIlHuGXnW4HBIzC06hz2Hm+//yFt//ce/bq6tmrw+d/PXxx0Pvby5f/",
	"6fxZZ2Fhwt6dwBqPZiXzxPH99z/iAF2YwX7//TUDGJjZDgkKYqKpmjPibPUjHob8TmNAECw5k4fXzMuv",
	"FZVoSqU0shBNcTjiYkoCXe4cq4n+cg5nEsRhppIVB3u5ynpTQORILTKphO0wlPkt+ezpr0EAYzQwHHgA",
	"woOhgVUIBmhESRh8d830Kg4pw2LmOcpaQkncV0R5UgmCpzmK6vym9HLZvUYTMM6adhOu9jGHBD0bDVLb",
	"e8HVQ8EWvf9HsjOuVSMi9XgxZa5LO3wj4cy9DuDl2HzvnVAZcUnd0S8d1cIY/ux2fHlbtjYaOHu+vM2v",
	"henwWdf8+9z+e3DNfBKGz7r6/8/h//arF/DhB/j/y2vW65lxLxnVGivjy1ukh5tdmz+1INe6g0fZiHtA",
	"i55ljxX4STrA1OwPXBergm/1J/gDBwGsPA7PcwXsLI0M0WOb+6LSN6VLM784Wi/j4WzKRTShPlxOGC1U",
	"Oh1UZfS83MWcXidqb0juJkRNiLhmoF1Z5QzgrHvQ+oVGMeOqh47CEDEekLxqZ+4y0ACWx+LSXMXoFkGx",
	"glrXLF1OUDBNZ383NzvZE5JpGYeS2zsYgtIlNx1I04PlBlbbchQBnLICM1gkg42ZsGZsUmEWYBEgKJ2Z",
	"lanW02MccTGkQUDYjqTe//HYqs/mfivS+g6YgrQQwL5PpESW40keC58UCb+DRyT8XrsVTdiIFl5can4x",
	"ncK9m49BAxzOtCTBsZpoUPiguNoLQSVmoBPya2bXCCcLhNQEK0QVCjiRhSs74sKSoKZLwXAIV0JEeDD+",
	"HSo4TmzldJsJZkFIAif5tS7PyOeI+HrCmsUNsSSGSAtUnx8elepzZhccXcKCo1NdJUsJsYxxGM4cn9HH",
	"L80VqeZ9ZUvDBcpskl0p3SRx9DLFM00zaMoDOppZjUcQp76odGu6SJ+NwTIAXIFKFNIbEs5gt9wZUXEo",
	"Ylq/ZgHXrUg+JWqi/7oTnI0tiTHuZYhpXqRHIaZslYLDeMqc9KQ/1pXZ7ziyCskK2Z3taciDWTIH5Y14",
	"zILdQyPFeA4j0Huh4v/iEVH/O67Qaz2TZBsMkalZRH0ge59PiUQjwafWK4dyJrXsF8R4MdAAnZ2gO+zc",
	"Fxwp2jW4ZoqjkPMbFEcaLk6dcDRtPhYsrdloS9+eVdbW19M4I+9HsPM4DO1fyxZwygMS9oYTD/SQnjHz",
	"/Nn90rH3g9bw8+fH7HfGCLRog+xW7VVvW2LuTe0H0EKxpkkVmcpFlTPEQxIWgNGd0gt+MIrk2UkRhLvJ",
	"FCM8JoGn1TIvpFLpjckeYRZUWCwEnuVasIazuQof//y4WoV1Fj6rPGohm9VkU56UGFXjiDN0N6H+xCmc",
	"zjSZwPuaDQ13Nx466YnUkqDi3JtiNnPmBrkFnjOlQRCSOyxInu1wjnRXbnCyh85DoiWKlhV4rDmixkOR",
	"2H3x/NUjYjx6pm/1TK3ZQRoGlMhHLWXgiK/mlwT0dzAI+0SAjNATQHeUBfzumumTiRI0ijQn0mwIK2KM",
	"kFoOputuNzdmWp3jgv5BtiFLQj6mLLelH7IdFEiLZ49o07JzSQWGw+QIU+M8l9WQtfpj/TOn+uiNTo3i",
	"lCorereM1DCK8zXDKBJcGZUqaV3vOo+VPYfmdPAu6FumWyORTL92QGAXssaka+YLAk6fOJS6GvkcUQHd",
	"3xD2HRBFsmrmyJ4sjbGFLrLaZPeLbkvsj4g6LpQqckoLxSjEPlm0AGUoaL7VIzSJp5h5guAALtAyPyfO",
	"tHBqKLqLWGDTi1u/MEFH6UXzg9++ld+ZMw73/Vjo5QR9IRJcb+icPtvppjKrGk3ahV+QKXNYKhreT1dX",
	"58gUQD4PgNviz+au8OV+9ubw2X7B3WEem0v8iVNHYrcFTl2GdTGU2Ommpj9wbivY9gyui7q7eH3sHRwc",
	"vEJJuSLKSlVpy0WzPQdYEc86UFSkj1XOHBWuG8ylKrI13IXDv0B9tFcO6c0CWIIH5PdBFw0Y+X1gjILz",
	"d1XLx2YPELIcluDYnNRD/oT4N6BRGOK38lYaPRUGLM1F5JjeEgbGAYwk0QPQnEqrNb1r5qEBZQPXGjXE",
	"kDQ5xcqf6AkyRELgiO6Sf2mjCEGzh8d22N03RB1PMBsTeRSG3bdkOiTi/WgA3bMl/ScWCBjIWsNglB3+",
	"wn0cXvFjPo1iRUQyAPj+jeBxNIAti7DSp+vOYef/9y1l/39G2XeH315f3/3Pd992r6/l9/Dn938pAkIV",
	"N77qdOfMffXorosGY2X+T/Q/oTL/J3mKzLCLCn4+1QdtKmyClWrL6fytKg4rZT3mGtpwFk0mGAg74VGm",
	"994129JyV2Fhy2cKXLfuBnjpBHX9tfZjJd8vubAuZF7JlbobcWqpsCcZo1n1Oss9Ywp6reLfA9I7e8+N",
	"C+7x1+m7Oceca3ZJSOaKP6tC2Wt+uPbGQ61yGvHqO18eQcCBR+teS8CWnOBiqbFPlCeJL4haVK8YIYHs",
	"R1jKOy6CviDSlFqUd2kLFQV3fhDmYr5Av5tiGvZxEAgiZe6CEn4pmuGICqn6paYEKvsBlXqFguKZgI9w",
	"afVIUObTCBcbMAQPzbgTNTIZL2Xq4HkhY57XHCWehn3rnSSsdld5US2J5w4hzjpQpEA7W01qg1ptedI7",
	"Bmaf1UUN2jt/flw9ZD0S7/cYh1TNvCjESi+dh8djQcaFtOGGvrn5qnI9jWTPHOer2L3qLCoOvNwKuIlX",
	"GaNt4Y9YkCWNfCy0fM2bulbu04gCu9oOKYGdzrVYbZpgdqWcyQmN0qoVBp7Z9IKDcsxKRJriCocZGWMl",
	"22opkojJdbzBuh0n79bzu1q+FFk6XuS5LKh8wlPcCqghsTZzeDWLjeFL6GNAZe0I/OfX7nlIxpSB89t6",
	"/RetGWHxtIfjgCov5GMvPc07R0tqLHLdjozBQKT7wjSMBSlwt7Tt2adqZV6sYLaKp8nkpNGazFMHLhLL",
	"1CwCRcaNRE6wiCZw7dTtACcwH0qHodEa0YgUzSqAJ0TmnYyu0+1ghsPZH/rv0gY/8aFXbu8omVYshJ6N",
	"NYPAzv3Mh6DBxkZhBf+tgfdsgM6cncxDg/0BuiA4mMGHZwN0EcPew8fnA6RPfyFRBD4fDLRa5pPQuGkN",
	"XgzQFZ2SAL2PFXzxwwC9BisIfHqpe7Izhy/+OkBHbvrwxd8G6BwLReESKu0q3Q3vWXe/+6z7vHvQfdH9",
	"ofuy+9fu3z4WsQhYuOkIe9hX9BZ4k7fMZpQWyywZ6JneCAN5zNk3uVaBfww5D37S5IBA2cqQjW0QDEAB",
	"yX6KjFZavt+CyhsP+z6JlF7dLAGZb6GZmGU+4FBrbIVNrhaCh/Wux9IfeqB69WhQVWdJaybsRhaIe+yH",
	"WQ+p7PmBYh+X/OYToRSZagWHlBWxtovSn8HSUvp7JghAEcUpIiJBJSkd4TjiZb8IHkclv+VfsBlMsHml",
	"fRRynLlgM0IVbv6UJlypuChbFPuivsgMmuoDZUU4V6XTFTGzSvbKk3D68Kzu/GzNkiFoVBb+VKSglWFF",
	"M4QWJPVA0peFx6v7hknA42FInjBOyie4C6BEkedzNqJjD3TlhweSnKD/0hEEB+9ZOJt7CZOu7w2ZLfWf",
	"WNkA2AkLvHuXLqOURJkHzQ9vBadg5e8nx7iSFciQUqmFRxKjaeftOBWO3+n6eK4Ng7vCoaTmnplUZNpP",
	"FrakfMZCpfC4kk2ocO/m3levv40vX2x/G+37zA1WPp2ddf9ZuQP11822/OBWD0a7EERgnmlD54uGyG7n",
	"TlBF0nUCV8aA9BN3rZVcJQ18VaV0fuwlxWsyJs/wgUWbRnZpciI/qzJAzLJ+2sQi8gi7pYKzqY37Uaw5",
	"pEVuKCsupH/IU/nibfscm1jhG1c2nEjQKRazsqEUWT2WsLOHp14u7GsFg/tK1l/8o+HTBWWyT1QrUalr",
	"w5MR8QuINeHOyYE6MMHkpvy22LLkWiy/uJC05v47s9e2+FzZHFcyCjBs9M19T9ENUMUGinXXipUra1Y+",
	"n06pWrezTFiLnLqcMVuubMM8JarAU+c9iGqP1jwh6dOo8IKORrcvKrWS2LuqUVmxUfbPj/NdLUdjrCaZ",
	"W88HdhygY70rU6ImvETIgGugXEYniwKFq6ifWvjqsi+9YOCJuMF6mbBpW12ryRT7mZWqenRaWQ5ugY3X",
	"5/pQdFyj2nKxOAyTiDuL5GxOvxarNVo0i14THsuvEh+eGhCVmTQCAtEI6xtqbsisf4vdW47F36eY4TH4",
	"p/WXNVPF6mLf4i1vp471BSIw9hNXhZImZTxMzA4lRRRhmKm6xphu53Za30qzSHIP1KLZ0toOaa1iv9ul",
	"veQpFQnGpC7FJZX1Wa7QphE8q2bHSFoKKbvxCAvMeTJ4vkH1UVh0xX9LQu5TNau2UN0ONVNYdKYyYyuQ",
	"ntZmUGfUUAf8Jhi5VLOw+BxzRwMTrXCtDR5xpjzqF7uAhCUnP13pNZ7SsNjq6l5YVD5apS/3wlk0KTj/",
	"sXFu8hniHuq9LbZNDMF/sOaia5r1bE04vSxbgzO7bjXaT9dbU8vUvhrZLr1kY4YseuThgJbdiEj6B6mK",
	"gMI3l0vCZmA2q89BGA9IRWmVZ1lZ367SMQN/qkH2iX/dmpFBup0RDkgxsQLl17XzzuGmgjtb4Rp4KVKq",
	"LUWFdhMCzrc45GGJl+k9cJtELCwyHCGMlCjgKti/eT8alV2ylk1iJ/u7EZ+osEAAvy1L/7q0tkXxp/eH",
	"iwC83wufYauSK2o2rtxBrHhc4hG+DYkxwSGXS56Sl6/iMr5faw3nSbCCEJujAOzfaG2bBcelo13CJ8AT",
	"Ycs8RP98WSL8anEYOcFRmbm5qmxNtTTrLP6g7EvOhSHof+LD9H554ZZh9YWzcUGIBQn64EBfyZps/CN1",
	"37WXxbiZJplDPN1GoVkp00l965K5TSxsdzFzwPZMYRDsvq58mVuSKpfzEy6Vs+Ile558WcEEuKFxHMyQ",
	"8GDSRL7ZzA65suBaBt6Mabhwr5yncw3zftZHutwUKmtT6zKSuiVCVruSWs3DvIDKKMSzbfCy9fhRscOc",
	"qamwvKlZdYF1rWJV6zGoZN0K2VJVZpTW1TPd7mhg7eoOp5ATVibW7XC77GSWcbmaHGw9jlU98k/Ckerx",
	"oZTr1OM1ec5SY4sy3KM+t0gk0sMzdpfkyCrUR3EY9pWIpeYxi07oWcW1OKNViQJcklSquHSS5mmdC+2S",
	"bEyFPWUmWN2JpyTNS2EHjHxW/YQfbeQSYH2Cq49TiDgsc5FZyL1S8ya5jC9tifafMP1unV5Xr7JNE2Yf",
	"nW9K0vN0uLp/Hi/ru0EyNeenh+fy+VXxZ1u78nGmPj7W19Fs/Uz8x/owy7gYm3aqHFErCaJVjSQp9daW",
	"MUkyvNr2g4PnS874/STnXbWzcpr/bb1p1GFnSW607R1CV0rqla8JKjG+bjZZ2dprtZbnXuaZcOEKmN/e",
	"piHmNj+MFx/qduPW+qT1jTn+u31+u9jirrhqFS66DfVoJWNdykirss/ufKrNyr3dp/q2RV61hDfV4kiu",
	"Yj8T47IOw3FhGrwpZnRkJdHCvZv9fvFZnjEi1Lb0JL06K0SNq/HFyouBXUgkiF/mNQy3QM9/eCnj6bJJ",
	"1bqzzjDbIZbEwy7KdkG0ks9UqhK+ueLNTM0XEUUnzoXhFAfjNOH6VWFQzhEXJmmF6a+XjVdS9Xap6qCN",
	"2Nr9oF++2NagM6efxdvfLbyWyKTYrKfFmdxfhXcTaZKxNYdVaWVcwMBdbmW1g1n5cEsl8MM7SFPs435J",
	"GKgjk4sH4tNA1AKIZUOEDZWyPH5BhUZz4Q5Wtm0DH1Rp18VIWN2mjZZQqVEXWWFVqw5bq9u0JZNMhasa",
	"NlqhY+/5Zt/haZINzhQ0gY7vSratOOhDhUHnYkSsGvI44hWaHEd8dUtWV1vZFnh4r2otvV1b9UB4eeBv",
	"G47IlgCmgt3yuyGYgOuA/6IroDS0RYXZZQNhrJojjys0yOOV7ZjwGBXasnE0VrXngoYVNJULRo0ogwiu",
	"kC3HZDbLUnd2eaFJEmQ7zOhDcLe1evjgXL988MuU4LlD0fqsfk71W2Ta7o6vhoZuB5d9xbvgUhZCfP9q",
	"sRgqPnav7oFhp7S2yB0RrGJBvFGIx48/0glhSaTW1XtR9W1f5c0AvIA6p0dRZRDLSG9EQ+LFUcjxA71M",
	"qG+rqGJyLY7z+GCO83aX1wg0nHmOucJytowqchFQHxxeT4BdXhZmXup2XqfDXvjtfGmg5OTXf5SFyDjf",
	"NDFpNwlD2I+ZmosdUCsQaLpZGXvWDsVaQCH4ZEzlhATlnjH1hV+a1vEBepqY9D1qqyx82WIUxhF+cMty",
	"ZGn4Qx0S7naO+XTI3wgcTS7sNA2Eq/usrY/814JPl6M/V6KUA+RKbYEdJG39hOWksMcLso1+rvjy2Wd+",
	"L517psz59jM0Z0BA5Y1nEg0/PH3kWJeTVJELatw4K8QP3IBszW/H7ni0eF47m0ZYnwyOpCSqtNzK5Y64",
	"BA198+ftu1h0X1BFfRz29VjTw2L9CJqfIy5jQfqUBeRzxd1TlIj+H0TwYvfkQrPE0vXmD9Gpsu4hqPJ5",
	"JZXvda+QMprBRgHzJJ6Gnstd8RAj68Ddf3UPIhpEfSplrM+BglauIiWvXL767jqJ0MdKCTqMFelPcRRR",
	"Nt7UaSTqY19WHrGsvSYy6k+JwvogXadO9WVcSZOSjpkHoRtN0saim5OoH4twt+pnOqZbEpiUwQ9PBMzx",
	"p+rO+sl86pyVN9lZgoU/ydwpVThHbQ+P2Uvk1dRsogcqPJbN2AFjRkeUBHOBTfILVBqfsjxFc4iluiSk",
	"xtOOeQepddVqE7im+CiMxZjUexWfX54knMOcQSwY1w5GW7DuRdE8ebB8Pep2ZENHrNb9ixfAPX2fY4ny",
	"ihLxHyJ4aRTTnZOPTf1dFt10G7S1ZJHkRlrMDt4jH8VqcrlW3MJsyMNif9t5E+i23urGIe4nWUAqWfLz",
	"Ody2NI65zG+rRwHWbZM2e31/4mw2uRru5KmyV1keLSafq5BMi1d7B12Uk24bXt7F0j1TZ5Enua8rvFuF",
	"fEGLV50mPSaVSA8B0REaQBMD/RXjCg10/4Nep8r1TjrYly8KB2u+rnC5XmewL19sMtg022t+tOn3RQkD",
	"qg3OVBnMDa/O6NzF0NxVb2Ei2KNMStc0FaoddtW8Y5XnphvYZN2LPbbctyu9ryuPUzew1jhNHs9YUDW7",
	"1PA1A/zp7dHxJR0zuFde7H+Q/HaI/vLj0eXpyxen747fn5ye9HXN/uXZm3dHVx8uTk3eZc1MOxOCA4g5",
	"b5hbJ20+ZT0R/QcB3vPzr1c/EiyIuHJvgYfw8bVbsJ9/vYL0VblRHZn7hD/A+H2ITAvoLz//etW/ev+P",
	"03dmNMClYFXg97T7iVKRMQlDiOQTm4FyrpPMr4foLxevjzUl9k+Ork6vzt4um3C22YIp6/UggS1U0O/c",
	"5IYTIt0Kor/A9PpnJ0u6z9VfHIAmBMpG3PhDMIV9lSRj1SQZRxEX6v/JiPiKCB7JHuVp45l0Y6eJixS6",
	"NJU63Q4csmGB5eHenm2sN9S1IGdd6lfVo3zPOJKVuTMenZ8Z765A0FsiUXHfmAXomE+nMaNqhk6Nlti7",
	"ZqfWGIDwLaYhHtJQ/04lCgjjkFRZUjaGjgZJ/QE0N0ibHyB9qutds2t2bBYL6cXTxEk5gwTlBAA64qJk",
	"gCb1ABGyh644GhOFJiSM0B1Vk2uWqbIwiS6KQoIlQZ84ZYjH4pr9dhli/wbypEPRj9+6pR5PpOqFs70f",
	"f4Iie9/BmP/7v9FRLmmc/vJqQrJD1ctsN0oidccRJDAAf8hc1UP0869XyGAJwVN8Catl6BlduJy/1+w1",
	"F+j3mPo3SOlvEBeIM8OjkY/DUHZh2XVzkEx5OEMzHgs0FPxOEoGmeIZs5kdJp1FIpEKCx4r00GsurtmU",
	"C4KAmZntDzkbo5DeEjMZkLvGZ8r2JIheMcICEiBu0i1TiaQZuEgHrhfsv2FclqUAV3Jrptu+o2GIjL5r",
	"ppIhoxEPQ36nPxlIouS1kMty/9PV1bnr7/CaDQaDa7aKl9liZyO9RohHxDT1jqg7Lm6QwkMgJcpya9iF",
	"0jBaSeyqIzzGlEmVgGuKA4JiRUNq0h+Cp3Ay6F7RfuuFN7SSZv3O01IXTfgduSUCUaVXObP2ugcyQ5yF",
	"sySRNngok2nEBRYzZIJym55tlyYcOsIjRQTCSBKF8NR5swFJaRLQi0oFuWaCeHNpEs0GmcMR8gUB72gc",
	"pvs9R8D668s8acC85wlJc4FFlFiX6/lV6aF3XJmZYz3MOdpDQ6KU9dfOUPMCJc8QDiVHVllHKRA027A9",
	"6zVIWjVTZ6qHrnRtV3E+k+Qok769i7BEd0TTuUS3RNBRppht+pqZoelu7yaE6YUhMGRLE5KIW0h4vriW",
	"PmeSSrN9E0EIAkfHCAslD/Uokyyoev/R2YmDMFRPk8R2Yd/xNRtiSV6+QIT5XG+L1ktQIjFh3pLYniJK",
	"fAKsLcvEgah1jxpHuc6AdIBql4D7UE+yCMrFkvuaLVcszIJV0blsr9fsimsszfOzDAtghARIaeHDwOsT",
	"YWakq17iHjrF/iT9nJQKLNvKSSldzOdTIu1q3fHs1l0le2aS11NpUG75X163Gdil7F4zvZUqqf8PMptv",
	"AEvoxlEqbPIEy4nekEhwwzVMRmczAiQnPA4DNCTXDCguIMK2Ew9D6qNvQ3pDEAaHWK3cfIfcIEwTN2SW",
	"toEyTVhOYutfM5dB/7sees/8/Nrq8SfLaTbExwx2S/ek+1AcNi4vhrQEBXAH3I+nhClLqUMeK81fdS1g",
	"/7AJc2i2iw28mDI/jAO9SuQzBlF6zfjINVFID65+ZtM/nCW6iCAjEAfmWYmVBXqYh9fst1+5uAFHZgek",
	"POGk2soqxXDi7xHmxXIPC0X9kMi9Z88Onj3b/+Hg4MXzl89eebYnT/fkqQnx0p68o/Mzp/0scHd0Lkkc",
	"cE/zCnRqlgQWnAqpOR8y+Tn0vlFGFQUYwHQ0yXmXPx15z394mRH6KbFgo7XaBm7IzEj4aKYmWu8y3xOB",
	"/o4mU+z3GLn71jyu6yIc0T401L8hs+8SXL+PrOv3P8jMKcVgPTP0b3sKKbtxe5byG3+CKdOQoBJFwgSZ",
	"QoJEIZ4hrBT2byQo19dMEnKjN3TKAzqa5fifyb2h9bcPF2c9dAbrAnYgjUnzXsTHijDjv15QFTMj9ZPv",
	"P1ycmfVkHAUEEqJruc4C+6DFtZOd4crV1pPQoMyv+H+7DT5Eb06v0B6O6N7t8z2tk+65WPmgku096z3T",
	"xRPGC4mfwdYFVQtrpjvag+Rq37qEO3bm/+Om3I8F/Q7IEX2A12OZgVuRP4oFOP7DpoHImaeWdxlqSfrV",
	"DPDb71J60RIlQyqMfK5LKUaImupWMF2z1PiiRw8ql3m6MMeU0yaBPRA00Qqp4o7+LPldsyz9gfTlYQDP",
	"HjBDU/wZhIquK+2o7EMJiXAQGEFWMINrNpwhP1bKpIkfIRyGpqZEI8Gn2TmhgiklZaBnUxPmfodFUEpY",
	"z/ef73vPnnv7z66eHxz+8Orw5f5/SkkpVzhR0/rJEP4Oo+kxfvftd6Xk5Ur/dvjs4GMzdPUjD2aw3Hpp",
	"LXGFWG5AXMnk0VC3vYyQ8sST410oz7oMo4nwLOQ4MPnm8ypRD52Z8flakt1NiNHqBTH2NDMWn0PefzPK",
	"7AQt64s11WA2u8OzrjmezhKGZslNb5jS5zSe25I8EdFEme5Bv9akR6aR0pIDoeL9h8Lp1rymDIfhrIty",
	"WrCVFAyHoCQBe4VWDBMFXdiemAKrhOnDwojD0cQkh89y8/zIrabdh6b/bnvum2+/XSQiN3DTj53NNzlN",
	"8Jsu+ianLX+D/sfw+j4NSpvI6NHfdNE8PkqrJdD8pouyU3GL2ul2QuoTJsEo6IxqEfYnxHve218wct3d",
	"3fUw/NzjYrxn68q9X86OT99dnkIdcH+DWDedvErUybyh79xCtAd9xMcR7Rx2Dnr7vYNOtxNhZeKtO0Fk",
	"DBAeiUMI4m/vx+fM58ZIUWyTOv3wy5E9bI7HRj/XejD6Fn7AURRSDVSOfvzpNDVgwfn1u14Hxmg0k7Mg",
	"6epUjway0ERcL4Ae0vP90vwmSbk9ptUxAJ2e/ov9/dVVhjjw7O6aOs9W14mZdUP/gwSm0sHqSiMuhjQI",
	"TNjJF89fra6hOPemmM3c+OClyg9VJqWP1ILh0DOHZ48IwY0PpIynUyxm6a7qbepAsmDZOfytYz+mG9z5",
	"+KcmG4GnxKRRL7nIS4vsWZBEoOCbq7qE3ALPhlDZ+2I9Q2nw595CPidZSoxXWrxJIjRVhfbwr6sjWx2e",
	"mEr7snRMbwlDRyf2DeQCub0h6igwvsAnWOF/miYuYQALs86P45ILeO6FfB7GU2vQSkMNdFH6vr/n7OvG",
	"8SmxgEsuVH84c/cLeNVdLI5oD8Yke9BSTzfgDcHXcn54P5IxZSBlE52Aj5DAbEzQt3CUk/SWfKfhOnc1",
	"9r/ohIwgy5RGrQ1om7YypSyW6GAfBXgmyyamMJjw02lVe1EzP4lTIz4KZkA+rz2DkjETFqw14hVYsBt1",
	"Q6NO5dJwlLHX4DkOuO9uWlz8e81dzVF975M0bnjpDKpdvGuict30IjymzNz2rPJHydXTy+PdURbwuyJH",
	"QZshpk6u7qAgx9ufVVyM/1y4CHr/j4cuDPZfVBFtyhtp4ftAxMcbolLGWsCBMzJFs1ZkeWsHHh2ZK6ct",
	"y5kF9mEYOzo7cZCHKHwJ4hP50zEpbrUK6xxbUhTNQz4nzSDKx96XJLf2n6ViSy8XZSNu7RMxszIKbF9H",
	"Z0fo+AgxHpBeoYyi+BifmneAdRfJsJTJLBCaj9k3PGW8ZTlZmJeInp6G8Un2XMC1Fl+7wZehC7PuQD4Z",
	"VJkf5W4BtaKCBlTPUL8H6WOXgmMvjeInlwIFg2bXReB02kVcpEEn4FyeZJE0Z3cfM2SbzuJpFZSOM6NZ",
	"D1VmY2pKd1vJCvmatWz4+Zrjc2riWqiHB7DEvUN+XMB/iDD2c2T3aNDMcDiT1IRX2+g02O1EcQHuX4d4",
	"nHHW4WioTzAI+v0DrIUQPwI0jUVkX+oTx5Eb4zZMBw+aQHMkBnNHOJ18Vu+KaESWEVV2i6Ukyksz/hay",
	"518oODHAlb7UOo3k5uG4DSS1uDW6BjyFfWNaXudcPdAq26CLBgqPB+a6fjAl06GLUzRo5ohd1IPN8FS7",
	"+UgQiNZEeiMaKiJ62UNlUUcKjxvpxz5Bgu1spMPsRm6lw8yb3+IeabD9fioJZGsf8nANyW/tSLXq2EB5",
	"UGdTM0LxWX7uSY3GdyZZeJ2Tfsp1qhzwC755hAf++9dLNFdewsazmgkUOHMFdqihfIQkzQVC5xhgIxFm",
	"driOOeUljSmWyhp7ridS/ciDWS2ir0m3fxZ4H6eOCnAppw/7AH+tyyxMJG9/+HMnkK07pxZpW0GaocrF",
	"LV8DXyXK2t6XDP91VigjAhaxdALfr8SSKTaHpbpHx8dzHVffQrT/qgIkracc/KlJw3BFqPRZaTE3pp1M",
	"vNTOMWaMKxvnFmFkdDEUkBFl4HKYbFgP2OVEqajvgt692H+VMDx4e9c5GOG//TB6+cL74a/P/uq9+OHl",
	"c294MPK95/6rlwejly/xCL/UlOgcYTuH+qz0wtt/7j17dfXs1eHzvx6+OOj97eXL/8DrvsoaE0zWuxM4",
	"ikA/WmAc339/zNkopL76/nvjEu9cdQU1fjlV1uD6oWD8xA52CxjvFp+7LohemVuS7QANZ8a4vWjlWoXb",
	"VpR8PVbkIoppXrlbuJ05O3H23OwABfG5AAYgLMUXX97kJd7SG5yVL4BLbVLGGW6lrDTFtqJ35uFWEkGl",
	"CpwK9U84Si7qn71WAW25RpZrWCfQJlXWvTT5Q7nx8YKoWDBjfpxQqbigPg6RMSDJCY0koiPEOPpw8Qsy",
	"VhvzJCciPoQxWWWdPM4MYoHf3Y99sbVVbcx31rNGZdKRVDJMtbypQcNVRmPwc5h9eIpN/z4Vmxrsdzrk",
	"novvlHDfNKOX6Xzhrt5c2UFtpASxKT2W60u5AwqEIH6n+11xMfQaGJnWYK1fT/JaNc1SVHYNZH1O53jp",
	"gmvPPWk9w0kuvljLXO71uFSFnhMuk1667pSlGG4GeEHvgSZKvdrui3+AZ3+SMGWFf0+WfUNFq8Mhdwm4",
	"jGFAhbdQ/tgW3yJszXj6uUvJSuGbW4zej0mjmIBaPWA9HNuz1FL/Dzh/2YLwOI4V3yKuOm29tX2t53y3",
	"lk99t5q7SeKzOOiiQX6J9DeRoJoY+zeUwWfCbqngbGoy8s5/Y0uB0wr4sfTSiEuNHyeTmTXi2pFdqEY6",
	"zO9E4102Ns/GvI5y4nC7Pd7/+5Yqri0ZhrimHcGu3VrOLe17lofhEOPEXatZbKpZ7KVpZMoVDPtAho+q",
	"qBloOENW0EDAuWpqBxwdfpz9w3DsCqbeZiXnPQiyexXWreRsUHJWkXuZbE/L46VnYhMvRlDnCoe1DtHt",
	"sfqh2NWzB2rNYi1CW/G3nvjLWcae7npkXXiXXx6cnJ5fnB4fXZ2eQBC78w9XiDKpCA56KHG8yNBjsoC9",
	"lQ4Yl67oSTqG9X0y1lT73Xg9GRG/QPuv67JRtBQVHDeebd/ZPwhI0M/R84ZLVJT6RJApv915P+tJIOPS",
	"G7RiaHeuJyXUvp70WerbVdJTRQ7T8pWWr7R85WvkK/U1v/xP7uv1Hmwko1/5cuMyLdi+4Gj4BUf524Vk",
	"/57UQ47L1fOVyDdLNCR2lYIH/o4jC7X29Jsz31QaW8Lp1hpkhk1u86wOsV893a2nC1YJeBBxKekwJDZw",
	"LNKVkalcaHCGUudYTa5smZVxD9BwZu+hTQR6SPIg8zfUiEo0GJkk5PcY9sCO4DHYNcsTHj8Cn95HfZNW",
	"gJOEgZrfziEe7Q7jjaY4313oGgjAkmRngENVOnO5PFbNjxPy9MPVbJG4SoPdLCOoEoLY+2I+9fUnUNVN",
	"NGTMTALhLftwpgMsd97MjaeyvCtMFVnpVVsGodh8YxOwIi5QzJJPgsobFDNFwySqrlY2S02xiey7oPJm",
	"a+/hzHD6MI7qqYGzOWUXs7fqmfVdGu2tP7SDdctQ1bYf2lX2fHHyur1Pa9jgkEGYMFioy7HigKrVT+KS",
	"YNhQHoV8XBaLS//+Cx837Xe5zqOzKr6a1knTnhHSv13IMPMJklLaj5Qz/Vd6wtaf0tDd+pNJzOK8Ns3B",
	"vDG/zaIdhg118cVtggWT4cK9bTQMGf0LMpyk6aZsHo25ENk9dDaCJBEyhgj9QddEzoQcX4GJnu2STrgA",
	"2o7hFy2AGdAWQn4XzdYk7Nv9ZJ+hGcEiu7hVpg6jW2vmO3zuuaobnB6pm+qsMcebDOCb6s+YgHbfVcYo",
	"2EgoQOCCW++q8F2fjSibmkBMChzAOA2QaQYl7VrmT37X3JqR3weuoE2cA7/KGJKA2lS8I0zDWJByo4kx",
	"vz46Ty3NK+teYmkdwAv5uA2517RdJNHOspogqHg7DKyXVSdNDuuQuEQsy17qSZQUt5H+JcKQVdblZaQi",
	"8wAbJRBafL/n2jmxva4TBtbQHw26SEN2B8bP2hzSjeiJua6aHSXBozLvrmZ7hoTrXdu3rG7dN5rznCPD",
	"8C4JFv6kKY73RyyIpwjDus4X80cTaaf+gLyD0F0hS9S/X8HPbfKpNvlUm3zqwSSfAobR5p96+PlxMhz2",
	"YaagMuy99L4nkUXrp6DSS7D3xeQWgXuMP5fZisHpQmYzCmlGo1V3k4yK5GQXd6FGetfsbIQGNhVMP9Pb",
	"ACWr4fLOSqKsgY2wIOKUKWNpE8a0l+n0mpk09BhJysYhsePqoQ9Jmu6BeYc0QPbKJtMdNOryEudSjlvG",
	"UHXQ1Qds0+ZDU5TIa2Yb16x+YRJXevjz3UHDUy6iSW6shnqlErGvYkFsZa1oDK6ZSVrtNmihSRxKbu+Y",
	"JBpobm8NHsDKMyWlMWAXKyJl6cUWb7sSqnC+PpaahgTyZUPrJECclake2ZeU1am+W3b14fYgya+jCaaH",
	"Tjgx9HjHxY05r66ghbLx2qdwBYNL7hELzFpJPhtozTo9aXqaG2+WvIYYsuEbK7buA0VYShO3sNgeuDCf",
	"Tq01vHL9aO3GDA8okXyO4ADYQ+9ZOIMllBut4cLQrN29c9jRVN7pdgiLp5pV248mFtbHbpU5UGkXOQfr",
	"WK+lRk2gv5lC2nKTzT6Gl218ZEkZNDWNG63OpVpI75rB5DXnxwo8v5asACBO//l3i9oy9VRrY+sr3aDL",
	"rbEGkigX+TWOIiIQMIfsGpjtNxmc7SJAvnMrlHezGkbbLKSLZ/v7RXftybidwdhqFyRAQ8P/TSRxTYh6",
	"z6eaqvaL3SM20nA5I1bDLdiKhK+7PbibEFayVqnY7KEzZfdBLpWTkCkSHYUh/GWcq3Iyy5nnNEehvik1",
	"oiQMZBcNY5uSPn3Ya195ppozHCgDEhEW6OOL5Ug3lEE2fGjO0UsPXRraumZWWP9ds/KBGU/Eo1jPGakJ",
	"l8T2ExCFaSgRdtHWzHk6IgKmzHxiJFWxJp8eLfK/wwPVIje/hWcmy54zZx4vrzKDdzd4Gw1X/C6RO3Gy",
	"t6CDjc9Rm1OnJAoAXah9UHnNCAUdzOgriAtHz+hbqnQDuqK7Z7UEqpv5LkfvqQeDHcc1c3oW9C7jKOJC",
	"yQyHXlBtVhz9ahFCZu+ap6yCg6alFZeO0YrJBbKqTDPFsSebIRhdQHE0gE4HOTKAr4wSopmYYXuGi8GX",
	"yVDsowSz8fOrY2fzsfBAfpVT9VP6i3g4A9Wc+hnFfJ4JzklZ6VQ0dDURhFyzgI5GBIw+SRt2yYGpOi/y",
	"w2vmoe+/N0v3/fe2TF15cZSy8G+At34zx8SvGVqcgtP4coq7nheFxxh6XFkyqzs6t/0FW48Mq9CjqsIt",
	"vjMOOFQVoX9upLDlGw3175Yc7XOU1mCzI4NNKu7c/Sd8fWq5fZP2GXPqRVfmdFJgocmfrNaz0ehTXeUk",
	"4YbVlaYKL80R3qYH/+rQVJIX/AT9iGVTcNogpfA8LJL04HgYku0lCLegyWYJXwKg49wY2rTgbVrwXcPX",
	"n6O4p4PjXaf5XyEL2/z+LZDvA8hzYUIfDYxDzoOJVnG8WK6ArnkQ/aOu8ZOuoY9awpn1ip+dfJCFOKzg",
	"1zKiQipwH++iECd/goN3HweBIFJ2U26RLRnyMWXdEs+Yros/0JiXTPFDaje7Rlz7kgVsJsJndo+aCmKa",
	"IYNGutyS92cca0Qu3Tcg5610Bi5Fbd76hNHV8A7SdVq3+Ybd5p30cFI1I3rcT/eUlR5hxMjdvCzslSSn",
	"14Pd4Dl0ndsgsxVArhaLFd3qshUlUZ4kviAlvm0r0tzDWjyY7KIGuS0ut5vXHr0jd8jS9TrwXKKC7n3R",
	"/9QIkEY+UwmUtxKOplICxzYu2j0bN7up48dKOzPEJHOfSyJ4bUKR3WUmiznK+kaWH3veELWEwFp29zUk",
	"KnMS8B4Ul4XLLt1hqSuy5bTVYs7AWaVblEAzwsqflMWcKYRPSt7flIWT2VBrWk9Xqh1It5ay04qX+w/N",
	"snOtZW86wss0lw+MMMHDUBr72UjwKZrGoaLeCIIYIL09hClL2gvouIBYxnqsb0d4a1GWrL6/zXBIdp4p",
	"TKrMtYlDw9zMbQDW5SyDsHjam46wh31Fb6E/z9ZsM5o8JJhbqqtMcF+NjC40Z5xmWRFltRjRURA8fC60",
	"wINWTrJ5DvS76Ps2B/titFKuon6dZWk5zz1xnnpQ2qn6kRFSK2PILRmmjexh37dbRXfhtPt2hI+S7i5d",
	"LJBWbLfgqQEeR41vXx+hdKsKCfDrFtgWamQ5cGHBmBV+JCjGrmtq20Kcq2ibEtyRAxuvM+X2PNEypk0Y",
	"U4o3zZpKiGx3wjzV/MrMCaefIyqIZY/fSGRqIMUhwR6GJ1Z8DM87pbzjIlh2LXJpumutVw9OuTS7DHIn",
	"2aSvRhLG5Rfx5pXzRuRvWnovLs3NTQYDTVies5ftda/as0+8zblDZgff2qMfMKJT+r0kagvAzsgTnwil",
	"yDQKtdyq/Aap9PXRMREKXdn2yv2vdTFXqn2X9NVdeuappPiVUq7Mw3WKLsVPY48ccgtVEW3ty4f25cP9",
	"Ib34HcRjAXxIsIDYf0MsyVZSRhUab36lEZFoxmNhXCLgzGciHERETLFuOJz1ELqElAcmsg38rLjLLmmz",
	"HWSVwh46d1nqoDAE2wyIRElI30yAhS7yY6n4FE3oeGICp6dpGrtoREPdx1i3PaFScTEzz/FzkfbsL2VH",
	"yVRvOXFrui3jUlCS6FQWJX1bjMSSZAQ27Ry7BXqj1+fE2nMW8wWZ0pmArT+ZBVhW+jUNyRks5JLCRYad",
	"RWX9xVNS1h9Mws8Uhz8lOJyLHmlJt5LSDQGoVqaUTOIj2/KgZkeC+0RC+MNMXHVyqwsUP6w6tr2tJ+jv",
	"42VH5VcnZmbJKcDFkV67AR7XqLxunqMqOYtcbiIaucdR+tOES+V+8Tkb0XEsSNDXp3n9FTwB8ifEv6HM",
	"FJlG5v3aJz7sg1a5mMgofe6mP6UP3u4xdWhzD7OiRp+eue1rKER/jj4a6fOWCNlUphuwF8qGEitkkdXM",
	"7pmw4ADcLc0xl5W5mGIW2EUzHRu23U+PBY/wVeb9h0PfOKq5EYZeQGUUGsX3aQYzfyAvFlO1LDkBJ980",
	"+DxRImz1S3NfMK9TllyBmLFu76i2wAKKHNzsiNYia/1lEIek6IBnOEJp/u8Kt/O2E2OjWtt9IfMu0s+u",
	"7/2/jLTDad9GbvdGJ0HRChaweHY0j9x2Z346ddEvgS7t+VNxFPIx0hRvOQKCYcjeNbtm77gih8jHGr5o",
	"GmvCJgkl99BrLuDeUS4LpY/Ri/0XCMtrpiZkBmchxlUSbRxxgXAY8jsTUV/3lW+sKID9L3xslvUUlmxr",
	"uaaTyJoVQrvOs5RsIFcsb/rJbm7LEyrk43GWkyxuWgXe8vyrvvjdHtjNDjjyq491++JsG2CPa2DddGuT",
	"+PG7uUQXCkEipTh60OA3T7nMUp+ZG8atwR8MB0UYTw76RT/qZVj6oz7UFv3mTte7SEPfKhxPlPfYp4yW",
	"BUE6bLkWD/pi/qgWayF/plhmsi65FcocLzZ1RWpdMVbcbVRVQrtLor2ZpFDr7vkbopZueEPcJjV9tD7U",
	"9+o0UJkgt+ufaplkmYdqwgB34qOavDlfF0RZTadhu0yJOtOqJS2D2FVshg0sJxlNZi+58/A+8eHyC3mI",
	"aJqUR7q8fWyW0GjZ3fuxq/Wz7qS9h3889/DAa/s0GHTRgHwmfqxL9xU1d/DmEZb9S6jke8KC5O+Qj/ta",
	"jsDt+jw3hcLQBeSnSS7xjVMVOAAEj+LKfhd3lLUo5xMf9kI+9kBkr1VbaknLmZdK2s6ao/Bx6I0Fj6ON",
	"2/KJUMAMqU/k5q1hT5AxlUrMNm4r8LfXFg68JLHp5gMzKfwzGst61GDfV65TFxDtmYxT622UOY7QYJP+",
	"167t2JxJK77u6gm1QX3Cgg1qaxbqGRbaeUIX8+4GE3SVp39N/xiV04p64pM811bWtBWWN3lVOxJEawFJ",
	"ryuVb2iitvZ9BR236nerfrfqd6t+t+p3q3636nerfrfq91NWvws1xa9R/3b27Ud6ZbbCg5mRO5QAVJ+5",
	"lrotX7qSP0PBTZ2qdhH8pZz1rONNPL80D+kybWF27dXavTolywJ62eySLTnwP3bes9xOUcaN9PSrsaMr",
	"U/Jr4kd2cVqG1DKkagzJEsyGHInfEPaIOVJcGKR5TJhmMeCxPR/yFGa83GJ6QaIQ+5YnXcEK3RMO9dg9",
	"s0e10NciqTxmcm3iqIEwYzPiQoPM/d3Xu/bnspDigpJbImE81rUdTTGjIy00zFisV6lrstBv1P341la9",
	"NxdSNxDPTeJBSo6tOmomc042Lks3CVU0GWM06RXByhfz4RyNLmXGNR9+fqyGir0vgoQES9JXeFwVIwG/",
	"YyHHQTE20B1VE/tlGoZhzrXetnCcAVR9//ohZdiEQbPp9R4/9SZLO5xlFu9rJuTuIi0CwSKFx+hbSaa3",
	"RCAu0HUHorWp6853xUPMEPrS8S01Z1VF0h6E6JDxtCKkXHETyWxtXGXF0LEbQQstWL5kiVtoPUxoGUM5",
	"s08ZS6OUQihSInzCFB4TxEcILloRDqaUSYj6Z29wM6EEi5GS9nipsNpRApiy99jJ6Srg8TAk6fmKxdNh",
	"LvzfOvkUvqbQni4EJsrSEGRhkXOR8ZANhLjLHOxzNB1DoY3DWbumlkSytiXaKNZf3TO1hDhKAlg7Mny4",
	"oWyLgLIHHN0TdDxRGwWuljOpyFTOAWmCpZEZyPSAFK+AqyNd48IMqY1X3carbgzTWVJ9MtiGIBPbjEk/",
	"wbckj2rO8rivivEW3i28m4b3UwC2z5lUAlNGAi8gIRmbLHGbS/F5qC9K80zXKO1a1pLvx2kbJ0kTrbxv",
	"GULTDKGYmJ+OApDlE7tRA5auIFK8tl6Q4Q0usVXLEFqGcA8MIZZzGWseLxOAxxl4GJLtMYCsXpBJUlUN",
	"4ZnxtPBu4d0kvHOk91Sgveukc/Xkd5trrsX2/WH7aQjtwOfTnVnlNb7Nw0OCTo7fv0WcVUD2ic+n7SG9",
	"BXbTwAYKfTJHcgD21s/iBYiuLbk1vtsjdwvv+4D3Uzlrm0AUUzIdEiEnNNoE49DWvOimEmFk2kd8VAHV",
	"kAr1bTqgFtstthvDNpAwmmap77EjPJKeIFOuyE59ZkwX6JzfEXE5IWGY3rRXwPy5vID6rbbeQr5pyJdR",
	"7pOC/m7u0paAvrYy71hAq9C3HODeOcBT0e5FEO3UJndxcl7NgeYiiFrZ3iK7aWRr+nwy0lyDeTdyPF2m",
	"dST3RRC1QruF9j1A+6mIafcycUvAhifB2Ff0lqSPHtcA9qUbVgvsFtiNAVumVPfocf176FkX/m2L7Mt/",
	"/rLxi5bL38P2UUsL8KYBnpDuY4M4G9Hx0hRsEmVCASBTIbY5zdNe0ufblEmFmU8Kk0McRdExtHAO0fAX",
	"MZrv/9z9iGywfPQ2hkBVYcjvTDQRzm71FnB2mI7m7+T3w1scxgRyUxfF7k+KdpYGbdhJlIQaUbBxFHlm",
	"xT0YcZXI148xTuJDiWK9QOgZCs/hGlCzw8gKJeEGfxUUQjNuB5CXZA6PnV2GMV2k5dqJSdnSHWooomn+",
	"2xsyK84br9lP5pclgU1aBG8FwYCNStCoheS8sFSYsjpBToZYUn9ZqBPb4rJYJ7ZIG+zkKwx24sijLNqJ",
	"I8iHrGAWYKbBJxO2+yrYah9NtIfH+8F12auJBw9vrRRFNCJ7NnfUEizb6I+xEIQpZMo7HLtmikB6Yn+7",
	"ND00oNNBOjoXYK2PGQ5nkso+VvlYdlqeQsKm7qL6ly7HykCFbu5ekn6rkya7q9pj8xH01kRSYUQ7PX1L",
	"EXNR7CxRNBHBziZw3PtiMxZC6B6lsH8DCfa8EWUBZeNyGj/9HHFhgjbasshkV8zGODUtIhtUMk/spoEj",
	"KHGO1eS163GFlcSWQ1eZwJpz9g47oFohKxdjZlJ5g7DvkwjOk9YmU9qj/vEISpPqmRIBEoLKGy/tqGgs",
	"l3qphzObubKH9MmRs3CGZD6nJaISDezsm8gVuZZE9eXt/cSf/Up0aYvMDPbQKMWW4zcGeEgjb+fZyU6A",
	"x5QmrUhY0NoxZgu52S2m8OgaouLKVVZfVzq3blDTcjTTdLGd11VOuZnmTvI1Fyeu1lKe9lDxXZILNuWv",
	"myeEbcr8vKC0PEXL8uPNqFgEv6+KXQVEYRquYlOmFAlAkUR4yOMco8/zql4hszKzSzmVPLE9LyxjY9Cv",
	"mKrbrpY0GbMpC8hn/YfTuj4wRcP6GbXRhT7hU87khEZIK2MSLCtDAtyXBIgzNHgt+PTc2V8GYN4cXPHM",
	"N5QhFxDchKAi88zbbA6Qu9YtZTP8ezGlXFGfuentYHOrjCGznFsfQSEpCz7tR412qXjDHaYmw/4Ey0kj",
	"fdY+BW2XjHLsYCtjMHmqy6aLbX/9uKEOm0XJ6x0x/KK+UgbfSHdb6kYrOWMiTD/VUpkb0eThGhZwK8Bq",
	"1bFirladetZ8a8bfVHfnjNgU7DtPxl6tA3OJLzKagbOIFfSRMLxU7RtyHhLMinO1V8nn3n1gSxFSqRpe",
	"gjapfaNHMMN886eJIDkafDXnMBlhcRNSRpaexExKSRzGxN7FCq2bSMLML0kjRufXsLmlQYzD+eNtgS0p",
	"OZhdukb+Bf1UsSEtnpmO9cpLqog+cuijj5XnxzxmcBQ6m0bYVyQ4kpKo5Nu5o1atA9UDMEutl0lrvbPq",
	"j2RMGaNsrM/kRKtuiI+QwGxM0LeU+WEs6S35Th8QL14fewcHB6+QueT6X3RCRjgOTdBid1eYtDKlLJbo",
	"YB8FeCbL7h0En25Z5Zy75jGXLQVTI5/XnlrJZBTf5lQ21UnWEL+6Z++OsoDfVZG/FRQQKm8SL6YqMrN1",
	"plvfBJmx+yf82/L4Jy8At+PgZ1WIUu8+M5/Wte+rc+2zhFHs12eo4oF5/egelT9ZhMEH0HuMe4+Mo8iY",
	"iFNOb15xEXSSnfIiGkwzc4BY1x09L2fS3JiVDmPFfukw+yXe6fZeswmn87rzaW/y7gnphqYXqb8e1peL",
	"p/SZZgVP2gUP2qSyObQNScjZOMkYUnZrNie5su/cWrfZ1m22EZnpZ4juQQvOlfBtxhW+MpZbJ/gWzfeA",
	"5iIP+MeI58D35Iz5O4DzyTHSLdeC84l/aQfTgrkFc0NgPjlGKdU9ZiyPuCB0zLYb74THStKAmF9SG9Fc",
	"Ut9rlsZAyVSmLAf/a7aKAbw2U2hjorRMoFkmYLGzGBXlMTOCccS97SvsyzhCRo+/Zm/O30M8B114LTbw",
	"JuKtgt+yg3tkB2/O3z8hZT/hC5AlZAt5RpaxAiyIy+JwzfjIVdmIH5hxt3yg5QMN8oExZZZ4nwj8N45g",
	"DA00Df42wHGL/XvRAeZDHD9G6I8jvtaFm1Xhaxnx3ui+Wpy2OG0Ip5pGHzs8qyrkZYp4XYi2inQL0kZB",
	"+iQUaMqGPGaBp0QsN8vnY1tCpqV5D8yV+D0z1a/MOFoYtzBuzPUzS7ePHM4hZTck8CrqxqVYBh3ZtFXX",
	"Fe0XqNUqzC2ImwSxpdUnoDfzeC2l+f2H2hrz+7iFaAvRxiD6/sPjh6balrLsmlpXW35v67fqcgvjZmE8",
	"R7mPHNJV741K7otqStz2vqcFa6NgfWz3PCQZiY+rPwEuffybTgwdH5W/AU6LHeP2JfBX9xI4TyXFD4Jz",
	"ZR4hfhp75JRbqIpoax0iW+F4f0gv9oV8LIC/1aWXZ/3AYYj8kELSD39CgjgkATIVi8PxHkPhS1t2zShP",
	"jHxW/aQ/G5PpkURt2kUUxqJ+hIhD0khcyYXd2HKEpmoxJoGuZO8TH9q/gZ7XqW7TOXs2EIOLLli7nZD7",
	"ODTOwxu3hQNPKhH7KhZk48Z8IhSwM+oTuXlr2BNkTKUSs43bCvzttOWUZXssX78BHtep3MY53TimWL2Q",
	"nqtDille4NiTF1AZhXj2ZMOLbTdImFUBMqoLfIG+TQT4dztIjstlgbpxDOCSCM8rGnAkh/wAGY4xr3qY",
	"2nnlY6cJcefornI+XOAhNh8uTK+hxLcbIOlJRCDaGm4MpaFTu3fVgbOgee99gX+dicpw/UVgnMD3RcDA",
	"LEBYSu5TLWKQwvJGouEMgQqax4dpxODjNCG7uqdIZt5P6upPzZ60NfowK70GfXSXHcMye/+JD+3+D2fo",
	"7KQ4N+oiI2w5ytOhMbBHrEFg2w3nCT2WRvN0vG1pMM8kOyZl6uB5mhkzPf2WJdN3cQsXuGJJaMJ51vfQ",
	"9IJsnvxWL/gqUGzjC26kSYwIVrFYnQ4wDJEtikYhHmfuuSiTJk9nkTXvtanzWlfp7Dah3WpCtBPw9AQ2",
	"y3j3VQWCzu17PkH1iI4bys/r6HTvi/0LLpYUH49DUHm3K5ks2ZbKpnQMO5JOvwoKwikFBPJhuWMDMJRO",
	"pgISr2CZMlhsIo82YXgYtkFqH/oltKENhHMw/0Yiu30uVbviiFA1gaT1cN/CBQqohD+p6tViC1lY05B4",
	"cRRyHFROSKvrIFNHn2WK04a8piH5AGV+NkXWuEWKJRF9MsU07OMgEETKQRcNzIKkf/WnREo8JvYbofqK",
	"TuETYUHyN2SVp2xMZLW7KEiomL2Pgnf993MjBevQUA6yxTVvpNsk/XwDF295smlqepYuG8jH58i+ga4y",
	"qGqgtzY/XntvlB4mUsnlfeLDR3JftN2TgRayyEhZZMVsqgW4qxZbQDZ1UEj3Zc+lIq2Q8R65ska9SBPd",
	"p3dGWcWjJFeZbSNVPiDtfefRZHJfR01eU4UtSDiU2wGr4Cm7gA+KrkCcbnzqrHCTOafqAkFKYlKQzRGm",
	"LLnSzCnCi5T4rBET4AKzrEKUZvzB/fM6e2M3x+3WJsoSovqiP/TNh/4nPnTXetu1bBybrQZcIVO4i2Jp",
	"nlrLiPh0NANnWyjAR8jSBhoSTXTSXhtB8hCw6yaOcqaxVFuyPXmaBS61khAWT/UqLpBeN/fVHzRa/MbT",
	"q6BPCZBeO/vjZ2/u54/dhdRfC6tzNSHo7MRaVBZOmr0SY9DCvlU2Cr18UWYUKmQMl/gW2MK8TFJ8kVcU",
	"XGPonzQRX3HHCta7xKiUMAkuJqzjdnZottNeQaqk5w/4AvkejfywbMB8rnhTjGePsGD7zOeBw+uUBRVw",
	"dMqCFTJ1v6XjRTrWi7sDCTqO+Bbear05f1/+QutNxNuHWV/dwyxNEsXPsWycj4f5JmMeD7Xyw5W+vErz",
	"xOHRCHIPGiXQQGc5atr0cO3zqmbx6qj1EWO2mfeS7z+sgm77NrIFb9PgLXoR+bjwWy2MVilu339YR862",
	"EbVakDYF0nw4rccFTkWJ8P4ggm8C0aSRrJDNPKW4o2pSEbdXlIj/6OG04G3B2wR4UwA8VghvKeFKfRnb",
	"xtBqgdocUOcDaD1skGqkeZJg4U+WQlPB6xVNERqNpgK8WzFgBaMsBmusxiVcAhRA8hLqXUA7K707oSxy",
	"3lyFDnJQpO++Lb9eqHSF6O5OTatIKoEVGc+Q4npPe+iEjLCeP5VoMIr/+GNWGm5EmcvTxctSqNbpdshn",
	"7Kuiu82PO3E6wUFAdQUcnud+X+0CMJx4sL89vbOdp+oB/jB4iKU74dCRMBC9AQ35y8Bmyz1/Fk2I2J2v",
	"zEXMJMJoilmMQ2R6M0hHARXEV+EM4TGmTBrOowl5iOUiT7mI2THU/meGB6xzO54HDmV+GAekn/92/kFE",
	"1+K+iMEswuK+HvLFjI4oCSyO4f8tbreF24uYIZwj4Oz1qEFRxStRgzwSjAn4v3BJzT6UCOULomIBKDIC",
	"WJBIEKl1EDYGzNxiQXksQSZLuD/VbVuj8hTfEBRHyTVRSD4jDVUvEtwHzxsoXahXn2M1Oc6McIUct+4D",
	"VocHJzw9RHdxW/w4IhY+6YPM2eylVnf5aKxT3rKxKCzGRO1sLE7p0KsNzlwTfpfsil1hrVyVDU/X66tV",
	"zlrNqBk75EWO2g2tQ1gYcznCmdJiIu9exUcLVG+POCY1SX51HS3oHdCrS0nQazlfFY1FnyyyS3m/Souc",
	"cKGI5mFYlR9mjiwNOX5kK5m5jASfuvdgmoIGml7gRRh8KmSHl7aFc+P/tJIXQuvmpGTo/SwoY4PJOHbB",
	"eQgLKo3CzX7zMRTGM9S4pJzJCY36N5QF23nO5fjCY+R1m1Foy7gqMK7FdR1bfnU//IvH0Tb84XQ7Szzi",
	"9M+tT9zX5xMHZFHiFecSUj5U8+Q8MvZwMKXME3Q82SydjpxJRabSIAf6QRMsETSPTPNI8VVAOtLFL8xg",
	"2guG9oKhGRBnifRRg9m5DeFhSLbnNJcAOuM6twrIx7mRtFBuodwMlP05unv8WN61+yt0XRXO7cV/C+bm",
	"wTznAPDooBz4fLobFVujmXwmfqwIOjl+/xZxtgrKJz6fthp2i+RGkaxp8+Lx69dTMh1uWR5jQRBGpmFT",
	"pqpMfmsH06K4RXEzKJ4mFPfoITyh0UYwNi1nRTGVWRxXBC8MowVwC+BGAWyp7vGCOJKeIFOuyO616nN+",
	"R8TlhIQhMl1WULHP5QUUbdXsFt+N4nuRWJ+AUVsE0e5gfnFyXuFa6iKIWiy3WG4Uy5oynwB6bZrQjbCL",
	"fUVvCXJNmUwv8HgNjtBDEnI2Nq6IVQ/Pl25YLaBbQDcDaJmS3COBs40pvrNnK2fQvjT+x+CJZ52ONQMw",
	"KWYXYGzqnGCFO48qdOK9ZVo8ZUHEaTYBqNnWvH+xSeyFzlwU+bJnFZBqYmmuc5vnvDAnRZJTb/10FKb5",
	"PsM2u4TNjwZ/w5GNcpbkm8hlqSjLScHHfQ0CSH0OiZD76b1T2oWiKlwrh0Xz+dTXSME9Nk7eTyYR+NPP",
	"3b31dOeG9r2U9tekBpNDZK26gDQPkNa5j5T2pv+1azv245kEGmuunlAb1Ccs2KC2Zm2eFfoPOi3Hx/tO",
	"ojeXzRHiuddJmt7m9WpOCf+Uz8lhVY9dPT7Qve0labpKVaWcVmYxqE+wY6IQI59VJtOXbrF3za7ZO67I",
	"IfKxZs5oGkt98kXYRaBHr92puGvOwcR1cUfBHqhiwRBGL/ZfICyvmZqQGahUjCtEPkcmCAwXCIchvzNP",
	"+3Rf+cZMBq6CpB9uuJvqdw9foVtIStYqda1S1yp1rVL3lJQ624B7ocbX2X1X2RChbFXKVqV8MFnDTa6t",
	"RMfKG62aVBX9WAhLYOU2NQixYAomGbDgYiRWE8IUPNUOnCL4kFXFxAB4bGZTnjmk6YT8c3hr8bX5wcuC",
	"KkO4DWNrG+l7luXJKTzBEcifo1GqDwpTLG5caBykhfiDhucpC5Lz20PCZYvHTfH4jis6osSIkqPzM8RH",
	"lkpNzKYVyJxH1ogyKickWC62NM25kuVJyg3Fvbbl2puh1ojQGhFaI0JrRHhyRoT6doCNrBBtuvgHly5+",
	"UxvHxzas6vrWjnlNrMmT2I5zhZedxUxsQIwYuVs8kZkfH/yZ7FIPM38q20pI5qBantgHFHm5PRk2ezI0",
	"oK13MPySydlexUdwqYtgaxpsvTlKjIo7NyYuxHj9mQ/R2Ulxdu7tZOQuw9Kej5lPwu1nIt/9lLqdKC5g",
	"AscwIYkwSjBWyAxMuZYftPygkB+Uk9E6Imsv5OOVOXtCPja58eG5AkaXEyyin/SaIBGzpdLsFz7eDQHn",
	"v7WzWJ1BowbZtiS4TCRpNvoLH0Ni/6cslEI+pmx3h7hfdPP6XPRjyHlgMAUZJPWxC/mCBIQpikMJxyjE",
	"GYHDG4qwlHdcBItP/qDF2icm8hlPI+O6CTPuT4ma8ADyY/mCaI3Y/nHYeTu7jKMDcXngiwN1rgeyL4L/",
	"+q//6nQ7etR2J3zOw77+/P+GemoTPTWSkEWPck2SZSjPj2FZzgso2UP2aj2cIc7CGRqYwQ4QlUjGUcSF",
	"IrBWLomWncxi9qxuh6uouMv3jKArvfjndvFtwjJJ2TgkbiRX+mw7oiQM4K31EFIOBogyqQgO9JDd4DoF",
	"nbtFLuo/ynbrchlW6pCrCC5bFrpL96uIeaYY+i2/I5mKHytw1CvI+wbkiIY8mMEEQj4eUzZGlNl0Ghmy",
	"7KUb+D0X35sJ6L10I+qiYazAzDDkamIsCHnEr3dez8AgyXsWq0mffI5M0yMcSs1NzCVPX/EbomdIZj9P",
	"hm98+p7+fPbhj7Nn7+iZPGMXP/jHZy/PbqJ//+v451c9Mvv5mf/8X7N/Pw9vzj5x+u7qn8/ffnr77N2n",
	"/1NvP53+8X+X+/vvTm7ufrkKP737NFb/9+vb/Xdv3v7x/tez5++ubu7O6B0N/v0u9OnZy7Ppu9vh888j",
	"+HzzIx2+eXX7nzeT2+DXH27+8+sP+//59893/jT84z+XP0TD2Zk8m4aT4Pjs5durD5/ffTr74/3V0ewt",
	"2+89+/VX/td/R6evsHf78u0/X6mfjv9Gbz5Pb6eXB+fxyV+HP8/e0ReTc9H/P7vrmr0edn548fL5wQ8v",
	"X3rPnx1g78WLV/veK//l3zzsv3jhH7wavvzh1b6RGrXkeH6xi7Jlza18hp1/ulNlJN6fM/zEMciIraoL",
	"rSl2QWEgfiyomnUOf/uYM8wuyryMBnEUq0nFdFchH/NY7VQ48xge5GekM2YBMtcfCQ92r5zRz79eFQpk",
	"PcqV/EiRz2ovCjHNc6LOb2AtdfxzgiViHLm24HHrx86yPE0LFPv995ex7xMpv//+ml2Zxm1rYNe1eU9y",
	"3Wi2bdisWTyYwy/csM8icUWl5tfm9GBKoRmPTQdDLQ5Mjj5jFMYjRVKJwGPVWz6jDah6OV0ubPd6hDkl",
	"CnuQPWrvi3WiWJWQI8SQR0RRIhBkF/f5dMiRTZqzcMD6BYq7BOLHuuw7l1/niab+bM9jy85jy+knoWGG",
	"w5mkOz+inQDRl57SEkzUSzg3jzAlSHWESaTrZHK6+Zwx4kMeQUjvVmjH0It4JQhxqXyWumhpBGbmPOfV",
	"pHs2U65pTbwX81+C3DbZ504yR6UZr4EsNSk/VZxunpTqrUNuYYQj/WuSkmrnpkb9SS6TinMwqSLzWmP6",
	"PaIRiKs4sxX8BKRFiXxQUYqY0vslFRdkC0nf3l0hrd2iS91eOdDeKV0KCrUp4L46nOSJpBgwuTIPN8ZX",
	"GXoayz+TW6dqWGuz0bTx++4P58VZaR4J3Hm8BRn5/kO5YHwft/Lwq5OH7z+UCMH3Hx4NFKCFWG0o7pJG",
	"nOmYBGg4c7BZipjjpP9WprUyrQGs+hmCe4yAHUd8I6y+OX/vkjCNRsRXlVD6RnfaArQFaAMA1QT6WLFp",
	"IltvnmGpthhNYmq3EG0hunOIjh21PUaQwnu2TTBqkjDUhugH2Wq5LUIbQmgsH4+Gq38bUROQJQvLSBAI",
	"8eUuHOduLk/PL06Pj65OT/Rk0RuiLidcKCLVOVYT5/3aQ+6+1RCSxnCmPzQk6o4QhtQdt54BlKVXs1Os",
	"FiF9nhnuqpAt8NjW+uUUBjqBMCzMOe5UvWDtFjwFXtYNYUH9TlrHg6fHILKkbwCRy8tiXFx2xSVymCdi",
	"SlfkSDLRCsMQucU3XoSZqr3C0ErnmbbXiqlk+1OzQRcNXGSlBxjYqKiHZOzr9BEJEkBYxd6IhoqIXpbj",
	"FLo06X+a6GjObWrdbjIv/L+6qKxzXix5ANYIZ5LWrBSgteXe2wtmkudsjm/nv22Ye+99ST+s9sDErJSZ",
	"fyNRQBSmoSw8RaWTvK/30Fm6bx227lOLydFCsyhY0LzPThKfj2QASBCfC3jYIIgSlNwSR9v6VNEr9rXM",
	"4ajyA9aD56sesEYhVrrG3hf3F5hBNOF7v8c41GdtqfCSRLPw5lESQYkEywgESxmPBRljZR6gINsQgobs",
	"s8gxvSUMuU4LQW1/O8EK/9O0cOTaXUt1S9WzLkqVs2a0sfzwfiRjypjWs/Uo4MkuHyGB2Zigbynzw1jS",
	"W/KdPm5evD72Dg4OXtkT5/+iEzLCcWiCObk4wkkrU8piiQ72UYBnctmxstjPXLdjQuJ1Kx0rS2ZAPq89",
	"g/Iz6lojfrih5yoHnMtB0eHFSxDWqkwbHHjtaua5FM4wGSc/NA9Clgk1KUAcDyz1wc9w7aVSwb1sx7oY",
	"/iMWpOB1e14ycAmhUpdz/yQW/4RKxcVMcwG9mkMsieX3Et/Cg3Mo5n4rZPimx0vocK2zuX2RIF2I44jL",
	"WJA+ZQH5rL9RlIj+H0TwPtjszZmdKurjsC+ovEm/foAH+lU2z1/4HRFoCM9QIehfMvj/tcpGLBiy2+r2",
	"RssCzcWxQhjJiPh0RH3gxntL2PFI8OmaEmT5HD5EUe05xJHidQav+FpDL2oqpbdG7Bx5gt6+zaNwtfKQ",
	"aabTAlA20/HWLUn3H6G2cj1N+t4dZQG/205oW715XlaMPN14to/2sGw5qZa5VCrqZ01HF1TeuBI7tBcJ",
	"HpLadn6oVGzhv4D21tIfnDk/U/YRWfdbe/tjtbcnEKjDXXlIWht7wzZ2x1sSFmk/N2FXByLZ+6L/WcOW",
	"rqutsKLrydyX/dxQc2s5v09lwO5/U7S9xFquqaHITg7Pr8qN5BYaWzSPC86Vj7fwPuyCc4WOj8ofiekC",
	"x7h9KPYVos5QRvFrMfvrw/XPK0BIY++k7eKsxFP7OLp1sb0PLBc/i37wkJZ4Gq4+j5vEbESQAF0evf0F",
	"RYLf0oCIklP5JZ6G565IE5F49Cz6yaBqHq50Zc9V3vYp66s6MQFtZDe+asDELZ6c9G7u5UihOKLnMZgX",
	"pM2OlKNqE3YbHmGB44LWOE3uJKIwXB/+++0vi5RvWszS/tLY29M4VDTCQu3BJa8j7DLCd30vzuRtZlQQ",
	"nF8PLVF9h5RhsOcshMN10Z7nItdhc72vp7+wMgWRo11CpM0jLm9+sJxDcmsN2VKeCSBshNE7Rw+OwE0a",
	"CEeA60VIzQN270uOl7tDmDHSLVLrCXwPJhDymUq43sxE6F0g3jxiTe0FxO5YWJnX1iSAkPg1ZRVUeZQi",
	"qv6Rbf/VVp1sgLK9O4GjCJjDwnocczYKqa966MpFc6YSKTHTRKV4JtQzFYjfsXnqehhgNTSNcB6otWTx",
	"0gwwNncwyEMaWOU3kZw+ZyM6jg3Gsq6ObkCajnQlGwi6HJtviNo9MHcqUlpTyLLj0/rkuV1DZF6elble",
	"zQulLZodQf5JyZdbT8LQrJikY4Y4S1JmyjLgXNIx0/+9Z6eZojsXbum41jiE6cl5nHmukS1LuoeW/WDl",
	"xt7L8emWBGAOokSuJEnj7mdLJ8lonJ8vKCvF9oFbEvzT9rGekW4tP95uJc8AmyakC+e+Lsxu1kX6i2Kn",
	"8i5KPQK+AocA93H3Pbl8LU30JX0ebWf9bDgI+SAcwjb260r5QZuhfNfmsxw3zbD/41k0AU66MwHQXWok",
	"szaydHizUtuX5euzDfJ016TJijnGgHWD8/PcPFZZrp41dMzITqmCSmMWPGiRVdl4ld/26tgqU472vsDH",
	"PrRYzU6VM1NlxoOGM3PyKDZP5UCVI85KZz/PUW97qb87a8u61LU7v5r8iArPtFny3fREW5Lq+gOoyTUJ",
	"31R6wNIElP91pMn+w5QmrZ/dLpiDo/3di575KDplYuiC3PIbIrMv1PkoP0CX2dtcfUoCHjouiNhy+ZR/",
	"eL8uYvNEb8+AcnEuR8kLdGOqD6znEOQVnOBbZ6nPvcbX0w/MFNP73TlO6Q5HK3KEVjBNVWMmMCrNTDKb",
	"WLItbh9WsZlWL7hn6FcG2nx4vq9IY8hyN4KFPyk1N17CzwAWE5HPIExq9QGcM7iwX6Gzky4yhhgbj3MW",
	"FfjgmgZXvhsy3SZlEgPnQp9mc52/b6HVbLOwfpBPEOZyzS75lKCjE2TzwspDNPgRS3jL9EESof91sfT1",
	"3xAQ2Hxp4pSKQdLIH7Eg2XaO/uNaOvrPURSZP07ILfXJwOR8LXw2OpsznT2q4Aybm8iATKzz5HpyoTWR",
	"rWapGSZg4Z9hmwmgG7kjIeFo6dVI5hIknGWvvEngxD8RyfMc9JoLlIy7a9ydQYvhLJwhcksEGhJ0i0Nq",
	"HsqDzOihM4bSGdpqPo/DQJcmVE2IQDjrDQN6ElzF+yElTKFvfR6GxFdcfGfQvXiTqKfaVPST3EJ5yUJt",
	"/0ZvxZ2cNJO+j9u3iPh7PCJMr8tsmWvuBURHAMen9xFh6Oj8DB309iGpBVZ0GJLszutfddtFW3wU0Uvz",
	"U5Ws5J89N6w0Lbkd8KEeQO/gmhkQy8NrhpCHYhEeor1r1uv1flMiZgYGtvZHILsCtaHMbfFRXe7qZbdr",
	"mxDT+Rk6M88+miAoxW8IW32Pq5GHTNlij26NgSvT1gqlybpSIOyOZUhxq5HZHtBw1kOQFt5+TaXhdBPO",
	"uFbbNI87CqaUWU5XonZs83oQjnh/VrwgHtie4aE4cFL7wT0pD7FUfQyJ9es8Ji9VsJ7Q7fENaebueDLF",
	"fn9K1IQ3c3+c2fKt9AexaXb9KD+l+q/6RX7KJGto/ZplelCzfZjf8D05JJpMpFFWsiZf3u9NOZCFlnux",
	"JOYxiTP6STqGUJBDLEkw7wybDZapRUzZE5NEGG/NygoD7rsHIQuGTidpVxtF1zaCpvfzLKONPJgblSza",
	"Wyxv9WYeKBlo4IPMewJXAvSCsrv3xVBzxRv5BWiqZDzLsWgayGOx7ivc1gjfyOW8JizkdmlDeVFkPE8Z",
	"VvpOpCRshaPNasbzMia7yZEQzlSbB7mANS2NcKF/beNbfHWPOoAoioNbHJ0gl/fsYb6EX8DFHg6mlHmC",
	"jidqo9gWcib1ucLgBqwiEywRtI5M60jxFTACe8iFGUob1qINa9EIhLMk+rih7HMmlYAsjZ6Wz2OA2c6w",
	"nekOpd1VBvtxWv0kqd2CvwV/k+BfSsOPnhtArB48DMn2olY5BpAJXbUa55lxtMhukd0UsnNk9wSQvOvo",
	"cx9kSYyCRTC3gedaKDcO5blwW48PyIHPpztRx314ekL8WBF0cvz+LeJsBZBPfD5tle0Wx03iGCjzKajW",
	"UzIdEiEnNNoIx2PB4ygLYyoRRqZxxEcrEPw2GUSL4BbBzSB4mqW5RwzgSHqCTLkiO5fG5/yOiMsJgfiy",
	"usfVovlcXkDJVjy34G4S3Iuk+hRktQiinVnAL07OK5u7L4KoBXQL6CYBnZLn44awJOmj7y1fTzOEfUVv",
	"CbJ9rJbOlyR5/N3CuIVxAzCWKcU9ZhD/Hnq79TW5/OcvNf1NLn8PW5eTFtGNI3qeUh8PsomQ1LibL32w",
	"CSCNo4gLRczDTFuzOE/fUUT/ZVtu4CXM0fnZ4pf2JXM/M8OFFwJpru8lxRYd57sdQxq1Ku06BvfDAEWG",
	"Mpp+Ppp/1fql8/OvVz8SLIgwLtSHv33UQPnp7dHxJR0zDCmD4fXrhVmME6zsF/p3EtivoeJHt+VF3tTw",
	"KJQajAyxJEijzbjih2EaGbmLgOdq3VRxKGxys6O7CREQ9gdWj0o0JJSN0YRLRQINr1iEncPOHnD6z57C",
	"YwiOYYZiHbSTZUXX8f7+85eZN/aLb8Jd2sR85KOcZ3nmFXbKveyr+8wHrWB/iEKOA9eC3eYkssFRHFAF",
	"FdiIjvUXUhKFziQPTbzXbueN1gn0LxDXAwS5iSR6dIJ+1OuZ+cqFCDF/28gg+sMJrKX+6835e6h8dmRT",
	"WGWyWaWrYr94d2XeZV0qLkwHRCh0RaaRFo/6i/cf7FDcOtjF73ZOsMLonzEODTXrjxGFmCI2HA4QnN2g",
	"TM/vWZgNqHX64ZcjveI/nSZdHDEcziSF8ZiYB2dsrGnRfda//MyH+p8rLG9garf6e/TtpT8hQRyS/0/F",
	"miCDSkoSk7MVAhJLMsAhgXpdtm9qSSIicGNrY2sBAQAA//9Aqticn/cDAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
