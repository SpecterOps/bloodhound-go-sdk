// Package oapiclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package oapiclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"gopkg.in/yaml.v2"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	HMACSignatureScopes  = "HMACSignature.Scopes"
	JWTBearerTokenScopes = "JWTBearerToken.Scopes"
	RequestDateScopes    = "RequestDate.Scopes"
	SignedRequestScopes  = "SignedRequest.Scopes"
)

// Defines values for EnumAuditLogStatus.
const (
	Failure EnumAuditLogStatus = "failure"
	Intent  EnumAuditLogStatus = "intent"
	Success EnumAuditLogStatus = "success"
)

// Defines values for EnumClientType.
const (
	Azurehound EnumClientType = "azurehound"
	Sharphound EnumClientType = "sharphound"
)

// Defines values for EnumDatapipeStatus.
const (
	Analyzing EnumDatapipeStatus = "analyzing"
	Idle      EnumDatapipeStatus = "idle"
	Ingesting EnumDatapipeStatus = "ingesting"
)

// Defines values for EnumJobStatus.
const (
	Minus1 EnumJobStatus = -1
	N0     EnumJobStatus = 0
	N1     EnumJobStatus = 1
	N2     EnumJobStatus = 2
	N3     EnumJobStatus = 3
	N4     EnumJobStatus = 4
	N5     EnumJobStatus = 5
	N6     EnumJobStatus = 6
	N7     EnumJobStatus = 7
	N8     EnumJobStatus = 8
)

// Defines values for EnumMfaActivationStatus.
const (
	Activated   EnumMfaActivationStatus = "activated"
	Deactivated EnumMfaActivationStatus = "deactivated"
	Pending     EnumMfaActivationStatus = "pending"
)

// Defines values for EnumRiskAcceptance.
const (
	Accepted   EnumRiskAcceptance = "accepted"
	All        EnumRiskAcceptance = "all"
	Empty      EnumRiskAcceptance = ""
	Unaccepted EnumRiskAcceptance = "unaccepted"
)

// Defines values for ModelAssetGroupSelectorSpecAction.
const (
	Add    ModelAssetGroupSelectorSpecAction = "add"
	Remove ModelAssetGroupSelectorSpecAction = "remove"
)

// Defines values for QueryEntityType.
const (
	QueryEntityTypeCount QueryEntityType = "count"
	QueryEntityTypeGraph QueryEntityType = "graph"
	QueryEntityTypeList  QueryEntityType = "list"
)

// Defines values for GetAiaCaEntityControllersParamsType.
const (
	GetAiaCaEntityControllersParamsTypeCount GetAiaCaEntityControllersParamsType = "count"
	GetAiaCaEntityControllersParamsTypeGraph GetAiaCaEntityControllersParamsType = "graph"
	GetAiaCaEntityControllersParamsTypeList  GetAiaCaEntityControllersParamsType = "list"
)

// Defines values for GetAzureEntityParamsType.
const (
	GetAzureEntityParamsTypeGraph GetAzureEntityParamsType = "graph"
	GetAzureEntityParamsTypeList  GetAzureEntityParamsType = "list"
)

// Defines values for GetEntityControllablesParamsType.
const (
	GetEntityControllablesParamsTypeCount GetEntityControllablesParamsType = "count"
	GetEntityControllablesParamsTypeGraph GetEntityControllablesParamsType = "graph"
	GetEntityControllablesParamsTypeList  GetEntityControllablesParamsType = "list"
)

// Defines values for GetEntityControllersParamsType.
const (
	GetEntityControllersParamsTypeCount GetEntityControllersParamsType = "count"
	GetEntityControllersParamsTypeGraph GetEntityControllersParamsType = "graph"
	GetEntityControllersParamsTypeList  GetEntityControllersParamsType = "list"
)

// Defines values for GetCertTemplateEntityControllersParamsType.
const (
	GetCertTemplateEntityControllersParamsTypeCount GetCertTemplateEntityControllersParamsType = "count"
	GetCertTemplateEntityControllersParamsTypeGraph GetCertTemplateEntityControllersParamsType = "graph"
	GetCertTemplateEntityControllersParamsTypeList  GetCertTemplateEntityControllersParamsType = "list"
)

// Defines values for GetComputerEntityAdminRightsParamsType.
const (
	GetComputerEntityAdminRightsParamsTypeCount GetComputerEntityAdminRightsParamsType = "count"
	GetComputerEntityAdminRightsParamsTypeGraph GetComputerEntityAdminRightsParamsType = "graph"
	GetComputerEntityAdminRightsParamsTypeList  GetComputerEntityAdminRightsParamsType = "list"
)

// Defines values for GetComputerEntityAdminsParamsType.
const (
	GetComputerEntityAdminsParamsTypeCount GetComputerEntityAdminsParamsType = "count"
	GetComputerEntityAdminsParamsTypeGraph GetComputerEntityAdminsParamsType = "graph"
	GetComputerEntityAdminsParamsTypeList  GetComputerEntityAdminsParamsType = "list"
)

// Defines values for GetComputerEntityConstrainedDelegationRightsParamsType.
const (
	GetComputerEntityConstrainedDelegationRightsParamsTypeCount GetComputerEntityConstrainedDelegationRightsParamsType = "count"
	GetComputerEntityConstrainedDelegationRightsParamsTypeGraph GetComputerEntityConstrainedDelegationRightsParamsType = "graph"
	GetComputerEntityConstrainedDelegationRightsParamsTypeList  GetComputerEntityConstrainedDelegationRightsParamsType = "list"
)

// Defines values for GetComputerEntityConstrainedUsersParamsType.
const (
	GetComputerEntityConstrainedUsersParamsTypeCount GetComputerEntityConstrainedUsersParamsType = "count"
	GetComputerEntityConstrainedUsersParamsTypeGraph GetComputerEntityConstrainedUsersParamsType = "graph"
	GetComputerEntityConstrainedUsersParamsTypeList  GetComputerEntityConstrainedUsersParamsType = "list"
)

// Defines values for GetComputerEntityControllablesParamsType.
const (
	GetComputerEntityControllablesParamsTypeCount GetComputerEntityControllablesParamsType = "count"
	GetComputerEntityControllablesParamsTypeGraph GetComputerEntityControllablesParamsType = "graph"
	GetComputerEntityControllablesParamsTypeList  GetComputerEntityControllablesParamsType = "list"
)

// Defines values for GetComputerEntityControllersParamsType.
const (
	GetComputerEntityControllersParamsTypeCount GetComputerEntityControllersParamsType = "count"
	GetComputerEntityControllersParamsTypeGraph GetComputerEntityControllersParamsType = "graph"
	GetComputerEntityControllersParamsTypeList  GetComputerEntityControllersParamsType = "list"
)

// Defines values for GetComputerEntityDcomRightsParamsType.
const (
	GetComputerEntityDcomRightsParamsTypeCount GetComputerEntityDcomRightsParamsType = "count"
	GetComputerEntityDcomRightsParamsTypeGraph GetComputerEntityDcomRightsParamsType = "graph"
	GetComputerEntityDcomRightsParamsTypeList  GetComputerEntityDcomRightsParamsType = "list"
)

// Defines values for GetComputerEntityDcomUsersParamsType.
const (
	GetComputerEntityDcomUsersParamsTypeCount GetComputerEntityDcomUsersParamsType = "count"
	GetComputerEntityDcomUsersParamsTypeGraph GetComputerEntityDcomUsersParamsType = "graph"
	GetComputerEntityDcomUsersParamsTypeList  GetComputerEntityDcomUsersParamsType = "list"
)

// Defines values for GetComputerEntityGroupMembershipParamsType.
const (
	GetComputerEntityGroupMembershipParamsTypeCount GetComputerEntityGroupMembershipParamsType = "count"
	GetComputerEntityGroupMembershipParamsTypeGraph GetComputerEntityGroupMembershipParamsType = "graph"
	GetComputerEntityGroupMembershipParamsTypeList  GetComputerEntityGroupMembershipParamsType = "list"
)

// Defines values for GetComputerEntityPsRemoteRightsParamsType.
const (
	GetComputerEntityPsRemoteRightsParamsTypeCount GetComputerEntityPsRemoteRightsParamsType = "count"
	GetComputerEntityPsRemoteRightsParamsTypeGraph GetComputerEntityPsRemoteRightsParamsType = "graph"
	GetComputerEntityPsRemoteRightsParamsTypeList  GetComputerEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetComputerEntityPsRemoteUsersParamsType.
const (
	GetComputerEntityPsRemoteUsersParamsTypeCount GetComputerEntityPsRemoteUsersParamsType = "count"
	GetComputerEntityPsRemoteUsersParamsTypeGraph GetComputerEntityPsRemoteUsersParamsType = "graph"
	GetComputerEntityPsRemoteUsersParamsTypeList  GetComputerEntityPsRemoteUsersParamsType = "list"
)

// Defines values for GetComputerEntityRdpRightsParamsType.
const (
	GetComputerEntityRdpRightsParamsTypeCount GetComputerEntityRdpRightsParamsType = "count"
	GetComputerEntityRdpRightsParamsTypeGraph GetComputerEntityRdpRightsParamsType = "graph"
	GetComputerEntityRdpRightsParamsTypeList  GetComputerEntityRdpRightsParamsType = "list"
)

// Defines values for GetComputerEntityRdpUsersParamsType.
const (
	GetComputerEntityRdpUsersParamsTypeCount GetComputerEntityRdpUsersParamsType = "count"
	GetComputerEntityRdpUsersParamsTypeGraph GetComputerEntityRdpUsersParamsType = "graph"
	GetComputerEntityRdpUsersParamsTypeList  GetComputerEntityRdpUsersParamsType = "list"
)

// Defines values for GetComputerEntitySessionsParamsType.
const (
	GetComputerEntitySessionsParamsTypeCount GetComputerEntitySessionsParamsType = "count"
	GetComputerEntitySessionsParamsTypeGraph GetComputerEntitySessionsParamsType = "graph"
	GetComputerEntitySessionsParamsTypeList  GetComputerEntitySessionsParamsType = "list"
)

// Defines values for GetComputerEntitySqlAdminsParamsType.
const (
	GetComputerEntitySqlAdminsParamsTypeCount GetComputerEntitySqlAdminsParamsType = "count"
	GetComputerEntitySqlAdminsParamsTypeGraph GetComputerEntitySqlAdminsParamsType = "graph"
	GetComputerEntitySqlAdminsParamsTypeList  GetComputerEntitySqlAdminsParamsType = "list"
)

// Defines values for GetContainerEntityControllersParamsType.
const (
	GetContainerEntityControllersParamsTypeCount GetContainerEntityControllersParamsType = "count"
	GetContainerEntityControllersParamsTypeGraph GetContainerEntityControllersParamsType = "graph"
	GetContainerEntityControllersParamsTypeList  GetContainerEntityControllersParamsType = "list"
)

// Defines values for GetDomainEntityComputersParamsType.
const (
	GetDomainEntityComputersParamsTypeCount GetDomainEntityComputersParamsType = "count"
	GetDomainEntityComputersParamsTypeGraph GetDomainEntityComputersParamsType = "graph"
	GetDomainEntityComputersParamsTypeList  GetDomainEntityComputersParamsType = "list"
)

// Defines values for GetDomainEntityControllersParamsType.
const (
	GetDomainEntityControllersParamsTypeCount GetDomainEntityControllersParamsType = "count"
	GetDomainEntityControllersParamsTypeGraph GetDomainEntityControllersParamsType = "graph"
	GetDomainEntityControllersParamsTypeList  GetDomainEntityControllersParamsType = "list"
)

// Defines values for GetDomainEntityDcSyncersParamsType.
const (
	GetDomainEntityDcSyncersParamsTypeCount GetDomainEntityDcSyncersParamsType = "count"
	GetDomainEntityDcSyncersParamsTypeGraph GetDomainEntityDcSyncersParamsType = "graph"
	GetDomainEntityDcSyncersParamsTypeList  GetDomainEntityDcSyncersParamsType = "list"
)

// Defines values for GetDomainEntityForeignAdminsParamsType.
const (
	GetDomainEntityForeignAdminsParamsTypeCount GetDomainEntityForeignAdminsParamsType = "count"
	GetDomainEntityForeignAdminsParamsTypeGraph GetDomainEntityForeignAdminsParamsType = "graph"
	GetDomainEntityForeignAdminsParamsTypeList  GetDomainEntityForeignAdminsParamsType = "list"
)

// Defines values for GetDomainEntityForeignGpoControllersParamsType.
const (
	GetDomainEntityForeignGpoControllersParamsTypeCount GetDomainEntityForeignGpoControllersParamsType = "count"
	GetDomainEntityForeignGpoControllersParamsTypeGraph GetDomainEntityForeignGpoControllersParamsType = "graph"
	GetDomainEntityForeignGpoControllersParamsTypeList  GetDomainEntityForeignGpoControllersParamsType = "list"
)

// Defines values for GetDomainEntityForeignGroupsParamsType.
const (
	GetDomainEntityForeignGroupsParamsTypeCount GetDomainEntityForeignGroupsParamsType = "count"
	GetDomainEntityForeignGroupsParamsTypeGraph GetDomainEntityForeignGroupsParamsType = "graph"
	GetDomainEntityForeignGroupsParamsTypeList  GetDomainEntityForeignGroupsParamsType = "list"
)

// Defines values for GetDomainEntityForeignUsersParamsType.
const (
	GetDomainEntityForeignUsersParamsTypeCount GetDomainEntityForeignUsersParamsType = "count"
	GetDomainEntityForeignUsersParamsTypeGraph GetDomainEntityForeignUsersParamsType = "graph"
	GetDomainEntityForeignUsersParamsTypeList  GetDomainEntityForeignUsersParamsType = "list"
)

// Defines values for GetDomainEntityGposParamsType.
const (
	GetDomainEntityGposParamsTypeCount GetDomainEntityGposParamsType = "count"
	GetDomainEntityGposParamsTypeGraph GetDomainEntityGposParamsType = "graph"
	GetDomainEntityGposParamsTypeList  GetDomainEntityGposParamsType = "list"
)

// Defines values for GetDomainEntityGroupsParamsType.
const (
	GetDomainEntityGroupsParamsTypeCount GetDomainEntityGroupsParamsType = "count"
	GetDomainEntityGroupsParamsTypeGraph GetDomainEntityGroupsParamsType = "graph"
	GetDomainEntityGroupsParamsTypeList  GetDomainEntityGroupsParamsType = "list"
)

// Defines values for GetDomainEntityInboundTrustsParamsType.
const (
	GetDomainEntityInboundTrustsParamsTypeCount GetDomainEntityInboundTrustsParamsType = "count"
	GetDomainEntityInboundTrustsParamsTypeGraph GetDomainEntityInboundTrustsParamsType = "graph"
	GetDomainEntityInboundTrustsParamsTypeList  GetDomainEntityInboundTrustsParamsType = "list"
)

// Defines values for GetDomainEntityLinkedGposParamsType.
const (
	GetDomainEntityLinkedGposParamsTypeCount GetDomainEntityLinkedGposParamsType = "count"
	GetDomainEntityLinkedGposParamsTypeGraph GetDomainEntityLinkedGposParamsType = "graph"
	GetDomainEntityLinkedGposParamsTypeList  GetDomainEntityLinkedGposParamsType = "list"
)

// Defines values for GetDomainEntityOusParamsType.
const (
	GetDomainEntityOusParamsTypeCount GetDomainEntityOusParamsType = "count"
	GetDomainEntityOusParamsTypeGraph GetDomainEntityOusParamsType = "graph"
	GetDomainEntityOusParamsTypeList  GetDomainEntityOusParamsType = "list"
)

// Defines values for GetDomainEntityOutboundTrustsParamsType.
const (
	GetDomainEntityOutboundTrustsParamsTypeCount GetDomainEntityOutboundTrustsParamsType = "count"
	GetDomainEntityOutboundTrustsParamsTypeGraph GetDomainEntityOutboundTrustsParamsType = "graph"
	GetDomainEntityOutboundTrustsParamsTypeList  GetDomainEntityOutboundTrustsParamsType = "list"
)

// Defines values for GetDomainEntityUsersParamsType.
const (
	GetDomainEntityUsersParamsTypeCount GetDomainEntityUsersParamsType = "count"
	GetDomainEntityUsersParamsTypeGraph GetDomainEntityUsersParamsType = "graph"
	GetDomainEntityUsersParamsTypeList  GetDomainEntityUsersParamsType = "list"
)

// Defines values for GetEnterpriseCaEntityControllersParamsType.
const (
	GetEnterpriseCaEntityControllersParamsTypeCount GetEnterpriseCaEntityControllersParamsType = "count"
	GetEnterpriseCaEntityControllersParamsTypeGraph GetEnterpriseCaEntityControllersParamsType = "graph"
	GetEnterpriseCaEntityControllersParamsTypeList  GetEnterpriseCaEntityControllersParamsType = "list"
)

// Defines values for GetGpoEntityComputersParamsType.
const (
	GetGpoEntityComputersParamsTypeCount GetGpoEntityComputersParamsType = "count"
	GetGpoEntityComputersParamsTypeGraph GetGpoEntityComputersParamsType = "graph"
	GetGpoEntityComputersParamsTypeList  GetGpoEntityComputersParamsType = "list"
)

// Defines values for GetGpoEntityControllersParamsType.
const (
	GetGpoEntityControllersParamsTypeCount GetGpoEntityControllersParamsType = "count"
	GetGpoEntityControllersParamsTypeGraph GetGpoEntityControllersParamsType = "graph"
	GetGpoEntityControllersParamsTypeList  GetGpoEntityControllersParamsType = "list"
)

// Defines values for GetGpoEntityOusParamsType.
const (
	GetGpoEntityOusParamsTypeCount GetGpoEntityOusParamsType = "count"
	GetGpoEntityOusParamsTypeGraph GetGpoEntityOusParamsType = "graph"
	GetGpoEntityOusParamsTypeList  GetGpoEntityOusParamsType = "list"
)

// Defines values for GetGpoEntityTierZeroParamsType.
const (
	GetGpoEntityTierZeroParamsTypeCount GetGpoEntityTierZeroParamsType = "count"
	GetGpoEntityTierZeroParamsTypeGraph GetGpoEntityTierZeroParamsType = "graph"
	GetGpoEntityTierZeroParamsTypeList  GetGpoEntityTierZeroParamsType = "list"
)

// Defines values for GetGpoEntityUsersParamsType.
const (
	GetGpoEntityUsersParamsTypeCount GetGpoEntityUsersParamsType = "count"
	GetGpoEntityUsersParamsTypeGraph GetGpoEntityUsersParamsType = "graph"
	GetGpoEntityUsersParamsTypeList  GetGpoEntityUsersParamsType = "list"
)

// Defines values for GetSearchResultParamsType.
const (
	Exact GetSearchResultParamsType = "exact"
	Fuzzy GetSearchResultParamsType = "fuzzy"
)

// Defines values for GetGroupEntityAdminRightsParamsType.
const (
	GetGroupEntityAdminRightsParamsTypeCount GetGroupEntityAdminRightsParamsType = "count"
	GetGroupEntityAdminRightsParamsTypeGraph GetGroupEntityAdminRightsParamsType = "graph"
	GetGroupEntityAdminRightsParamsTypeList  GetGroupEntityAdminRightsParamsType = "list"
)

// Defines values for GetGroupEntityControllablesParamsType.
const (
	GetGroupEntityControllablesParamsTypeCount GetGroupEntityControllablesParamsType = "count"
	GetGroupEntityControllablesParamsTypeGraph GetGroupEntityControllablesParamsType = "graph"
	GetGroupEntityControllablesParamsTypeList  GetGroupEntityControllablesParamsType = "list"
)

// Defines values for GetGroupEntityControllersParamsType.
const (
	GetGroupEntityControllersParamsTypeCount GetGroupEntityControllersParamsType = "count"
	GetGroupEntityControllersParamsTypeGraph GetGroupEntityControllersParamsType = "graph"
	GetGroupEntityControllersParamsTypeList  GetGroupEntityControllersParamsType = "list"
)

// Defines values for GetGroupEntityDcomRightsParamsType.
const (
	GetGroupEntityDcomRightsParamsTypeCount GetGroupEntityDcomRightsParamsType = "count"
	GetGroupEntityDcomRightsParamsTypeGraph GetGroupEntityDcomRightsParamsType = "graph"
	GetGroupEntityDcomRightsParamsTypeList  GetGroupEntityDcomRightsParamsType = "list"
)

// Defines values for GetGroupEntityMembersParamsType.
const (
	GetGroupEntityMembersParamsTypeCount GetGroupEntityMembersParamsType = "count"
	GetGroupEntityMembersParamsTypeGraph GetGroupEntityMembersParamsType = "graph"
	GetGroupEntityMembersParamsTypeList  GetGroupEntityMembersParamsType = "list"
)

// Defines values for GetGroupEntityMembershipsParamsType.
const (
	GetGroupEntityMembershipsParamsTypeCount GetGroupEntityMembershipsParamsType = "count"
	GetGroupEntityMembershipsParamsTypeGraph GetGroupEntityMembershipsParamsType = "graph"
	GetGroupEntityMembershipsParamsTypeList  GetGroupEntityMembershipsParamsType = "list"
)

// Defines values for GetGroupEntityPsRemoteRightsParamsType.
const (
	GetGroupEntityPsRemoteRightsParamsTypeCount GetGroupEntityPsRemoteRightsParamsType = "count"
	GetGroupEntityPsRemoteRightsParamsTypeGraph GetGroupEntityPsRemoteRightsParamsType = "graph"
	GetGroupEntityPsRemoteRightsParamsTypeList  GetGroupEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetGroupEntityRdpRightsParamsType.
const (
	GetGroupEntityRdpRightsParamsTypeCount GetGroupEntityRdpRightsParamsType = "count"
	GetGroupEntityRdpRightsParamsTypeGraph GetGroupEntityRdpRightsParamsType = "graph"
	GetGroupEntityRdpRightsParamsTypeList  GetGroupEntityRdpRightsParamsType = "list"
)

// Defines values for GetGroupEntitySessionsParamsType.
const (
	GetGroupEntitySessionsParamsTypeCount GetGroupEntitySessionsParamsType = "count"
	GetGroupEntitySessionsParamsTypeGraph GetGroupEntitySessionsParamsType = "graph"
	GetGroupEntitySessionsParamsTypeList  GetGroupEntitySessionsParamsType = "list"
)

// Defines values for LoginJSONBodyLoginMethod.
const (
	Secret LoginJSONBodyLoginMethod = "secret"
)

// Defines values for GetNtAuthStoreEntityControllersParamsType.
const (
	GetNtAuthStoreEntityControllersParamsTypeCount GetNtAuthStoreEntityControllersParamsType = "count"
	GetNtAuthStoreEntityControllersParamsTypeGraph GetNtAuthStoreEntityControllersParamsType = "graph"
	GetNtAuthStoreEntityControllersParamsTypeList  GetNtAuthStoreEntityControllersParamsType = "list"
)

// Defines values for GetOuEntityComputersParamsType.
const (
	GetOuEntityComputersParamsTypeCount GetOuEntityComputersParamsType = "count"
	GetOuEntityComputersParamsTypeGraph GetOuEntityComputersParamsType = "graph"
	GetOuEntityComputersParamsTypeList  GetOuEntityComputersParamsType = "list"
)

// Defines values for GetOuEntityGposParamsType.
const (
	GetOuEntityGposParamsTypeCount GetOuEntityGposParamsType = "count"
	GetOuEntityGposParamsTypeGraph GetOuEntityGposParamsType = "graph"
	GetOuEntityGposParamsTypeList  GetOuEntityGposParamsType = "list"
)

// Defines values for GetOuEntityGroupsParamsType.
const (
	GetOuEntityGroupsParamsTypeCount GetOuEntityGroupsParamsType = "count"
	GetOuEntityGroupsParamsTypeGraph GetOuEntityGroupsParamsType = "graph"
	GetOuEntityGroupsParamsTypeList  GetOuEntityGroupsParamsType = "list"
)

// Defines values for GetOuEntityUsersParamsType.
const (
	GetOuEntityUsersParamsTypeCount GetOuEntityUsersParamsType = "count"
	GetOuEntityUsersParamsTypeGraph GetOuEntityUsersParamsType = "graph"
	GetOuEntityUsersParamsTypeList  GetOuEntityUsersParamsType = "list"
)

// Defines values for GetRootCaEntityControllersParamsType.
const (
	GetRootCaEntityControllersParamsTypeCount GetRootCaEntityControllersParamsType = "count"
	GetRootCaEntityControllersParamsTypeGraph GetRootCaEntityControllersParamsType = "graph"
	GetRootCaEntityControllersParamsTypeList  GetRootCaEntityControllersParamsType = "list"
)

// Defines values for GetUserEntityAdminRightsParamsType.
const (
	GetUserEntityAdminRightsParamsTypeCount GetUserEntityAdminRightsParamsType = "count"
	GetUserEntityAdminRightsParamsTypeGraph GetUserEntityAdminRightsParamsType = "graph"
	GetUserEntityAdminRightsParamsTypeList  GetUserEntityAdminRightsParamsType = "list"
)

// Defines values for GetUserEntityConstrainedDelegationRightsParamsType.
const (
	GetUserEntityConstrainedDelegationRightsParamsTypeCount GetUserEntityConstrainedDelegationRightsParamsType = "count"
	GetUserEntityConstrainedDelegationRightsParamsTypeGraph GetUserEntityConstrainedDelegationRightsParamsType = "graph"
	GetUserEntityConstrainedDelegationRightsParamsTypeList  GetUserEntityConstrainedDelegationRightsParamsType = "list"
)

// Defines values for GetUserEntityControllablesParamsType.
const (
	GetUserEntityControllablesParamsTypeCount GetUserEntityControllablesParamsType = "count"
	GetUserEntityControllablesParamsTypeGraph GetUserEntityControllablesParamsType = "graph"
	GetUserEntityControllablesParamsTypeList  GetUserEntityControllablesParamsType = "list"
)

// Defines values for GetUserEntityControllersParamsType.
const (
	GetUserEntityControllersParamsTypeCount GetUserEntityControllersParamsType = "count"
	GetUserEntityControllersParamsTypeGraph GetUserEntityControllersParamsType = "graph"
	GetUserEntityControllersParamsTypeList  GetUserEntityControllersParamsType = "list"
)

// Defines values for GetUserEntityDcomRightsParamsType.
const (
	GetUserEntityDcomRightsParamsTypeCount GetUserEntityDcomRightsParamsType = "count"
	GetUserEntityDcomRightsParamsTypeGraph GetUserEntityDcomRightsParamsType = "graph"
	GetUserEntityDcomRightsParamsTypeList  GetUserEntityDcomRightsParamsType = "list"
)

// Defines values for GetUserEntityMembershipParamsType.
const (
	GetUserEntityMembershipParamsTypeCount GetUserEntityMembershipParamsType = "count"
	GetUserEntityMembershipParamsTypeGraph GetUserEntityMembershipParamsType = "graph"
	GetUserEntityMembershipParamsTypeList  GetUserEntityMembershipParamsType = "list"
)

// Defines values for GetUserEntityPsRemoteRightsParamsType.
const (
	GetUserEntityPsRemoteRightsParamsTypeCount GetUserEntityPsRemoteRightsParamsType = "count"
	GetUserEntityPsRemoteRightsParamsTypeGraph GetUserEntityPsRemoteRightsParamsType = "graph"
	GetUserEntityPsRemoteRightsParamsTypeList  GetUserEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetUserEntityRdpRightsParamsType.
const (
	GetUserEntityRdpRightsParamsTypeCount GetUserEntityRdpRightsParamsType = "count"
	GetUserEntityRdpRightsParamsTypeGraph GetUserEntityRdpRightsParamsType = "graph"
	GetUserEntityRdpRightsParamsTypeList  GetUserEntityRdpRightsParamsType = "list"
)

// Defines values for GetUserEntitySessionsParamsType.
const (
	GetUserEntitySessionsParamsTypeCount GetUserEntitySessionsParamsType = "count"
	GetUserEntitySessionsParamsTypeGraph GetUserEntitySessionsParamsType = "graph"
	GetUserEntitySessionsParamsTypeList  GetUserEntitySessionsParamsType = "list"
)

// Defines values for GetUserEntitySqlAdminRightsParamsType.
const (
	Count GetUserEntitySqlAdminRightsParamsType = "count"
	Graph GetUserEntitySqlAdminRightsParamsType = "graph"
	List  GetUserEntitySqlAdminRightsParamsType = "list"
)

// ApiErrorDetail defines model for api.error-detail.
type ApiErrorDetail struct {
	// Context The context in which the error took place
	Context *string `json:"context,omitempty"`

	// Message A human-readable description of the error
	Message *string `json:"message,omitempty"`
}

// ApiErrorWrapper defines model for api.error-wrapper.
type ApiErrorWrapper struct {
	// Errors The error(s) that occurred from processing the request
	Errors *[]ApiErrorDetail `json:"errors,omitempty"`

	// HttpStatus The HTTP status code
	HttpStatus *int `json:"http_status,omitempty"`

	// RequestId The unique identifier of the request that failed
	RequestId *openapi_types.UUID `json:"request_id,omitempty"`

	// Timestamp The RFC-3339 timestamp in which the error response was sent
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// ApiParamsPredicateFilterBoolean Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type ApiParamsPredicateFilterBoolean = bool

// ApiParamsPredicateFilterContains The contains predicate checks a property against the values in a given comma separated list.
// - `in` checks if the property matches an element in the given comma separated list.
//   - `in:Contains,GetChangesAll,MemberOf`
//
// - `nin` checks if the property does not match an element in the given comma separated list.
//   - `nin:LocalToComputer,MemberOfLocalGroup`
type ApiParamsPredicateFilterContains = string

// ApiParamsPredicateFilterInteger Filter results by column integer value. Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type ApiParamsPredicateFilterInteger = int

// ApiParamsPredicateFilterString Filter results by column string value. Valid filter predicates are `eq`, `~eq`, `neq`.
type ApiParamsPredicateFilterString = string

// ApiParamsPredicateFilterTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type ApiParamsPredicateFilterTime = time.Time

// ApiParamsPredicateFilterUuid Filter results by column string-formatted uuid value. Valid filter predicates are `eq`, `neq`.
type ApiParamsPredicateFilterUuid = openapi_types.UUID

// ApiParamsQueryLimit The limit of results requested by the client.
type ApiParamsQueryLimit = int

// ApiParamsQuerySkip The number of items to skip in a paginated response.
type ApiParamsQuerySkip = int

// ApiParamsQuerySortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order.
// See parameter description for details about which columns are sortable.
type ApiParamsQuerySortBy = string

// ApiRequestsUserSetSecret defines model for api.requests.user.set-secret.
type ApiRequestsUserSetSecret struct {
	NeedsPasswordReset *bool   `json:"needs_password_reset,omitempty"`
	Secret             *string `json:"secret,omitempty"`
}

// ApiRequestsUserUpdate defines model for api.requests.user.update.
type ApiRequestsUserUpdate struct {
	EmailAddress   *openapi_types.Email `json:"email_address,omitempty"`
	FirstName      *string              `json:"first_name,omitempty"`
	IsDisabled     *bool                `json:"is_disabled,omitempty"`
	LastName       *string              `json:"last_name,omitempty"`
	Principal      *string              `json:"principal,omitempty"`
	Roles          *[]int32             `json:"roles,omitempty"`
	SamlProviderId *string              `json:"saml_provider_id,omitempty"`
}

// ApiResponseAuthenticatedRequester defines model for api.response.authenticated-requester.
type ApiResponseAuthenticatedRequester struct {
	Data *ApiResponseAuthenticatedRequester_Data `json:"data,omitempty"`
}

// ApiResponseAuthenticatedRequester_Data defines model for ApiResponseAuthenticatedRequester.Data.
type ApiResponseAuthenticatedRequester_Data struct {
	union json.RawMessage
}

// ApiResponseDataQualityPlatformAggregate defines model for api.response.data-quality-platform-aggregate.
type ApiResponseDataQualityPlatformAggregate struct {
	// Count The total number of results.
	Count *int                                                 `json:"count,omitempty"`
	Data  *[]ApiResponseDataQualityPlatformAggregate_Data_Item `json:"data,omitempty"`

	// End The RFC-3339 timestamp to describe the end of a time range
	End *time.Time `json:"end,omitempty"`

	// Limit The limit of results requested by the client.
	Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

	// Skip The number of items to skip in a paginated response.
	Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

	// Start The RFC-3339 timestamp to describe the beginning of a time range
	Start *time.Time `json:"start,omitempty"`
}

// ApiResponseDataQualityPlatformAggregate_Data_Item defines model for api.response.data-quality-platform-aggregate.data.Item.
type ApiResponseDataQualityPlatformAggregate_Data_Item struct {
	union json.RawMessage
}

// ApiResponseFinding defines model for api.response.finding.
type ApiResponseFinding struct {
	Data *ApiResponseFinding_Data `json:"data,omitempty"`
}

// ApiResponseFinding_Data defines model for ApiResponseFinding.Data.
type ApiResponseFinding_Data struct {
	union json.RawMessage
}

// ApiResponsePagination defines model for api.response.pagination.
type ApiResponsePagination struct {
	// Count The total number of results.
	Count *int `json:"count,omitempty"`

	// Limit The limit of results requested by the client.
	Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

	// Skip The number of items to skip in a paginated response.
	Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
}

// ApiResponseTimeWindow defines model for api.response.time-window.
type ApiResponseTimeWindow struct {
	// End The RFC-3339 timestamp to describe the end of a time range
	End *time.Time `json:"end,omitempty"`

	// Start The RFC-3339 timestamp to describe the beginning of a time range
	Start *time.Time `json:"start,omitempty"`
}

// EnumAuditLogStatus defines model for enum.audit-log-status.
type EnumAuditLogStatus string

// EnumClientType This enum describes the collector client type.
type EnumClientType string

// EnumDatapipeStatus defines model for enum.datapipe-status.
type EnumDatapipeStatus string

// EnumJobStatus This enum describes the current status of a Job. Values are:
// - `-1` Invalid
// - `0` Ready
// - `1` Running
// - `2` Complete
// - `3` Canceled
// - `4` Timed Out
// - `5` Failed
// - `6` Ingesting
// - `7` Analyzing
// - `8` Partially Complete
type EnumJobStatus int

// EnumMfaActivationStatus The activation status of multi-factor authentication on a BloodHound user.
type EnumMfaActivationStatus string

// EnumRiskAcceptance defines model for enum.risk-acceptance.
type EnumRiskAcceptance string

// ModelAdDataQualityAggregation defines model for model.ad-data-quality-aggregation.
type ModelAdDataQualityAggregation struct {
	Acls          *int       `json:"acls,omitempty"`
	Aiacas        *int       `json:"aiacas,omitempty"`
	Certtemplates *int       `json:"certtemplates,omitempty"`
	Computers     *int       `json:"computers,omitempty"`
	Containers    *int       `json:"containers,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	DeletedAt     *NullTime  `json:"deleted_at,omitempty"`
	Domains       *int       `json:"domains,omitempty"`
	Enterprisecas *int       `json:"enterprisecas,omitempty"`
	Gpos          *int       `json:"gpos,omitempty"`
	Groups        *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                     *int32              `json:"id,omitempty"`
	LocalGroupCompleteness *float32            `json:"local_group_completeness,omitempty"`
	Ntauthstores           *int                `json:"ntauthstores,omitempty"`
	Ous                    *int                `json:"ous,omitempty"`
	Relationships          *int                `json:"relationships,omitempty"`
	Rootcas                *int                `json:"rootcas,omitempty"`
	RunId                  *openapi_types.UUID `json:"run_id,omitempty"`
	SessionCompleteness    *float32            `json:"session_completeness,omitempty"`
	Sessions               *int                `json:"sessions,omitempty"`
	UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
	Users                  *int                `json:"users,omitempty"`
}

// ModelAdDataQualityStat defines model for model.ad-data-quality-stat.
type ModelAdDataQualityStat struct {
	Acls          *int       `json:"acls,omitempty"`
	Aiacas        *int       `json:"aiacas,omitempty"`
	Certtemplates *int       `json:"certtemplates,omitempty"`
	Computers     *int       `json:"computers,omitempty"`
	Containers    *int       `json:"containers,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	DeletedAt     *NullTime  `json:"deleted_at,omitempty"`
	DomainSid     *string    `json:"domain_sid,omitempty"`
	Enterprisecas *int       `json:"enterprisecas,omitempty"`
	Gpos          *int       `json:"gpos,omitempty"`
	Groups        *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                     *int32              `json:"id,omitempty"`
	LocalGroupCompleteness *float64            `json:"local_group_completeness,omitempty"`
	Ntauthstores           *int                `json:"ntauthstores,omitempty"`
	Ous                    *int                `json:"ous,omitempty"`
	Relationships          *int                `json:"relationships,omitempty"`
	Rootcas                *int                `json:"rootcas,omitempty"`
	RunId                  *openapi_types.UUID `json:"run_id,omitempty"`
	SessionCompleteness    *float64            `json:"session_completeness,omitempty"`
	Sessions               *int                `json:"sessions,omitempty"`
	UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
	Users                  *int                `json:"users,omitempty"`
}

// ModelAppConfigParam defines model for model.app-config-param.
type ModelAppConfigParam struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32                  `json:"id,omitempty"`
	Key       *string                 `json:"key,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	UpdatedAt *time.Time              `json:"updated_at,omitempty"`
	Value     *map[string]interface{} `json:"value,omitempty"`
}

// ModelAssetGroup defines model for model.asset-group.
type ModelAssetGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *int32                     `json:"id,omitempty"`
	MemberCount *int                       `json:"member_count,omitempty"`
	Name        *string                    `json:"name,omitempty"`
	Selectors   *[]ModelAssetGroupSelector `json:"selectors,omitempty"`
	SystemGroup *bool                      `json:"system_group,omitempty"`
	Tag         *string                    `json:"tag,omitempty"`
	UpdatedAt   *time.Time                 `json:"updated_at,omitempty"`
}

// ModelAssetGroupCollection defines model for model.asset-group-collection.
type ModelAssetGroupCollection struct {
	CreatedAt *time.Time                        `json:"created_at,omitempty"`
	DeletedAt *NullTime                         `json:"deleted_at,omitempty"`
	Entries   *[]ModelAssetGroupCollectionEntry `json:"entries,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelAssetGroupCollectionEntry defines model for model.asset-group-collection-entry.
type ModelAssetGroupCollectionEntry struct {
	AssetGroupCollectionId *int64     `json:"asset_group_collection_id,omitempty"`
	CreatedAt              *time.Time `json:"created_at,omitempty"`
	DeletedAt              *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *int64                  `json:"id,omitempty"`
	NodeLabel  *string                 `json:"node_label,omitempty"`
	ObjectId   *string                 `json:"object_id,omitempty"`
	Properties *map[string]interface{} `json:"properties,omitempty"`
	UpdatedAt  *time.Time              `json:"updated_at,omitempty"`
}

// ModelAssetGroupMember defines model for model.asset-group-member.
type ModelAssetGroupMember struct {
	AssetGroupId    *int      `json:"asset_group_id,omitempty"`
	CustomMember    *bool     `json:"custom_member,omitempty"`
	EnvironmentId   *string   `json:"environment_id,omitempty"`
	EnvironmentKind *string   `json:"environment_kind,omitempty"`
	Kinds           *[]string `json:"kinds,omitempty"`
	Name            *string   `json:"name,omitempty"`
	ObjectId        *string   `json:"object_id,omitempty"`
	PrimaryKind     *string   `json:"primary_kind,omitempty"`
}

// ModelAssetGroupSelector defines model for model.asset-group-selector.
type ModelAssetGroupSelector struct {
	AssetGroupId *int32     `json:"asset_group_id,omitempty"`
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	DeletedAt    *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id             *int32     `json:"id,omitempty"`
	Name           *string    `json:"name,omitempty"`
	Selector       *string    `json:"selector,omitempty"`
	SystemSelector *bool      `json:"system_selector,omitempty"`
	UpdatedAt      *time.Time `json:"updated_at,omitempty"`
}

// ModelAssetGroupSelectorSpec defines model for model.asset-group-selector-spec.
type ModelAssetGroupSelectorSpec struct {
	Action       *ModelAssetGroupSelectorSpecAction `json:"action,omitempty"`
	SelectorName *string                            `json:"selector_name,omitempty"`
	Sid          *string                            `json:"sid,omitempty"`
}

// ModelAssetGroupSelectorSpecAction defines model for ModelAssetGroupSelectorSpec.Action.
type ModelAssetGroupSelectorSpecAction string

// ModelAuditLog defines model for model.audit-log.
type ModelAuditLog struct {
	Action     *string                 `json:"action,omitempty"`
	ActorEmail *openapi_types.Email    `json:"actor_email,omitempty"`
	ActorId    *openapi_types.UUID     `json:"actor_id,omitempty"`
	ActorName  *string                 `json:"actor_name,omitempty"`
	CommitId   *openapi_types.UUID     `json:"commit_id,omitempty"`
	CreatedAt  *time.Time              `json:"created_at,omitempty"`
	Fields     *map[string]interface{} `json:"fields,omitempty"`

	// Id This is the unique identifier for this object.
	Id              *int64              `json:"id,omitempty"`
	RequestId       *openapi_types.UUID `json:"request_id,omitempty"`
	SourceIpAddress *string             `json:"source_ip_address,omitempty"`
	Status          *EnumAuditLogStatus `json:"status,omitempty"`
}

// ModelAuthSecret defines model for model.auth-secret.
type ModelAuthSecret struct {
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	DeletedAt    *NullTime  `json:"deleted_at,omitempty"`
	DigestMethod *string    `json:"digest_method,omitempty"`
	ExpiresAt    *time.Time `json:"expires_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int32     `json:"id,omitempty"`
	TotpActivated *bool      `json:"totp_activated,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
}

// ModelAuthToken defines model for model.auth-token.
type ModelAuthToken struct {
	CreatedAt  *time.Time `json:"created_at,omitempty"`
	DeletedAt  *NullTime  `json:"deleted_at,omitempty"`
	HmacMethod *string    `json:"hmac_method,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *openapi_types.UUID `json:"id,omitempty"`
	Key        *string             `json:"key,omitempty"`
	LastAccess *time.Time          `json:"last_access,omitempty"`
	Name       *NullString         `json:"name,omitempty"`
	UpdatedAt  *time.Time          `json:"updated_at,omitempty"`
	UserId     *NullUuid           `json:"user_id,omitempty"`
}

// ModelAzureDataQualityAggregation defines model for model.azure-data-quality-aggregation.
type ModelAzureDataQualityAggregation struct {
	Apps      *int       `json:"apps,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	Devices   *int       `json:"devices,omitempty"`
	Groups    *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                *int32              `json:"id,omitempty"`
	KeyVaults         *int                `json:"key_vaults,omitempty"`
	ManagementGroups  *int                `json:"management_groups,omitempty"`
	Relationships     *int                `json:"relationships,omitempty"`
	ResourceGroups    *int                `json:"resource_groups,omitempty"`
	RunId             *openapi_types.UUID `json:"run_id,omitempty"`
	ServicePrincipals *int                `json:"service_principals,omitempty"`
	Subscriptions     *int                `json:"subscriptions,omitempty"`
	Tenants           *int                `json:"tenants,omitempty"`
	UpdatedAt         *time.Time          `json:"updated_at,omitempty"`
	Users             *int                `json:"users,omitempty"`
	Vms               *int                `json:"vms,omitempty"`
}

// ModelAzureDataQualityStat defines model for model.azure-data-quality-stat.
type ModelAzureDataQualityStat struct {
	Apps      *int       `json:"apps,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	Devices   *int       `json:"devices,omitempty"`
	Groups    *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                *int32              `json:"id,omitempty"`
	KeyVaults         *int                `json:"key_vaults,omitempty"`
	ManagementGroups  *int                `json:"management_groups,omitempty"`
	Relationships     *int                `json:"relationships,omitempty"`
	ResourceGroups    *int                `json:"resource_groups,omitempty"`
	RunId             *openapi_types.UUID `json:"run_id,omitempty"`
	ServicePrincipals *int                `json:"service_principals,omitempty"`
	Subscriptions     *int                `json:"subscriptions,omitempty"`
	Tenantid          *openapi_types.UUID `json:"tenantid,omitempty"`
	UpdatedAt         *time.Time          `json:"updated_at,omitempty"`
	Users             *int                `json:"users,omitempty"`
	Vms               *int                `json:"vms,omitempty"`
}

// ModelBhGraphEdge defines model for model.bh-graph.edge.
type ModelBhGraphEdge struct {
	Color *string                 `json:"color,omitempty"`
	Data  *map[string]interface{} `json:"data,omitempty"`
	End1  *ModelBhGraphLinkEnd    `json:"end1,omitempty"`
	End2  *ModelBhGraphLinkEnd    `json:"end2,omitempty"`
	Fade  *bool                   `json:"fade,omitempty"`
	Flow  *struct {
		Velocity *int `json:"velocity,omitempty"`
	} `json:"flow,omitempty"`
	Glyphs    *[]ModelBhGraphGlyph `json:"glyphs,omitempty"`
	Id1       *string              `json:"id1,omitempty"`
	Id2       *string              `json:"id2,omitempty"`
	Label     *ModelBhGraphLabel   `json:"label,omitempty"`
	LineStyle *string              `json:"lineStyle,omitempty"`
	Width     *int                 `json:"width,omitempty"`
}

// ModelBhGraphFontIcon defines model for model.bh-graph.font-icon.
type ModelBhGraphFontIcon struct {
	Color      *string `json:"color,omitempty"`
	FontFamily *string `json:"fontFamily,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// ModelBhGraphGlyph defines model for model.bh-graph.glyph.
type ModelBhGraphGlyph struct {
	Angle    *int                    `json:"angle,omitempty"`
	Blink    *bool                   `json:"blink,omitempty"`
	Border   *ModelBhGraphItemBorder `json:"border,omitempty"`
	Color    *string                 `json:"color,omitempty"`
	FontIcon *ModelBhGraphFontIcon   `json:"fontIcon,omitempty"`
	Image    *string                 `json:"image,omitempty"`
	Label    *ModelBhGraphLabel      `json:"label,omitempty"`
	Position *string                 `json:"position,omitempty"`
	Radius   *int                    `json:"radius,omitempty"`
	Size     *int                    `json:"size,omitempty"`
}

// ModelBhGraphGraph defines model for model.bh-graph.graph.
type ModelBhGraphGraph map[string]ModelBhGraphGraph_AdditionalProperties

// ModelBhGraphGraph_AdditionalProperties defines model for model.bh-graph.graph.AdditionalProperties.
type ModelBhGraphGraph_AdditionalProperties struct {
	union json.RawMessage
}

// ModelBhGraphItem defines model for model.bh-graph.item.
type ModelBhGraphItem struct {
	Color  *string                 `json:"color,omitempty"`
	Data   *map[string]interface{} `json:"data,omitempty"`
	Fade   *bool                   `json:"fade,omitempty"`
	Glyphs *[]ModelBhGraphGlyph    `json:"glyphs,omitempty"`
}

// ModelBhGraphItemBorder defines model for model.bh-graph.item-border.
type ModelBhGraphItemBorder struct {
	Color *string `json:"color,omitempty"`
}

// ModelBhGraphLabel defines model for model.bh-graph.label.
type ModelBhGraphLabel struct {
	Bold       *bool   `json:"bold,omitempty"`
	Color      *string `json:"color,omitempty"`
	FontFamily *string `json:"fontFamily,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// ModelBhGraphLinkEnd defines model for model.bh-graph.link-end.
type ModelBhGraphLinkEnd struct {
	Arrow   *bool                `json:"arrow,omitempty"`
	BackOff *int                 `json:"backOff,omitempty"`
	Color   *string              `json:"color,omitempty"`
	Glyphs  *[]ModelBhGraphGlyph `json:"glyphs,omitempty"`
	Label   *ModelBhGraphLabel   `json:"label,omitempty"`
}

// ModelBhGraphNode defines model for model.bh-graph.node.
type ModelBhGraphNode struct {
	Border *struct {
		Color     *string `json:"color,omitempty"`
		LineStyle *string `json:"lineStyle,omitempty"`
		Width     *int    `json:"width,omitempty"`
	} `json:"border,omitempty"`
	Color       *string `json:"color,omitempty"`
	Coordinates *struct {
		Lat *int `json:"lat,omitempty"`
		Lng *int `json:"lng,omitempty"`
	} `json:"coordinates,omitempty"`
	Cutout   *bool                   `json:"cutout,omitempty"`
	Data     *map[string]interface{} `json:"data,omitempty"`
	Fade     *bool                   `json:"fade,omitempty"`
	FontIcon *ModelBhGraphFontIcon   `json:"fontIcon,omitempty"`
	Glyphs   *[]ModelBhGraphGlyph    `json:"glyphs,omitempty"`
	Halos    *[]struct {
		Color  *string `json:"color,omitempty"`
		Radius *int    `json:"radius,omitempty"`
		Width  *int    `json:"width,omitempty"`
	} `json:"halos,omitempty"`
	Image *string `json:"image,omitempty"`
	Label *struct {
		BackgroundColor *string `json:"backgroundColor,omitempty"`
		Bold            *bool   `json:"bold,omitempty"`
		Center          *bool   `json:"center,omitempty"`
		Color           *string `json:"color,omitempty"`
		FontFamily      *string `json:"fontFamily,omitempty"`
		FontSize        *int    `json:"fontSize,omitempty"`
		Text            *string `json:"text,omitempty"`
	} `json:"label,omitempty"`
	Shape *string `json:"shape,omitempty"`
	Size  *int    `json:"size,omitempty"`
}

// ModelClient defines model for model.client.
type ModelClient struct {
	CompletedJobCount *int32                   `json:"completed_job_count,omitempty"`
	ConfiguredUser    *string                  `json:"configured_user,omitempty"`
	CreatedAt         *time.Time               `json:"created_at,omitempty"`
	CurrentJob        *ModelClientScheduledJob `json:"current_job,omitempty"`
	CurrentJobId      *NullInt64               `json:"current_job_id,omitempty"`
	DeletedAt         *NullTime                `json:"deleted_at,omitempty"`
	DomainController  *NullString              `json:"domain_controller,omitempty"`
	Events            *[]ModelClientSchedule   `json:"events,omitempty"`
	Hostname          *string                  `json:"hostname,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *openapi_types.UUID `json:"id,omitempty"`
	IpAddress   *string             `json:"ip_address,omitempty"`
	LastCheckin *time.Time          `json:"last_checkin,omitempty"`
	Name        *string             `json:"name,omitempty"`
	Token       *ModelAuthToken     `json:"token,omitempty"`
	Type        *EnumClientType     `json:"type,omitempty"`
	UpdatedAt   *time.Time          `json:"updated_at,omitempty"`
	UserSid     *NullString         `json:"user_sid,omitempty"`
	Version     *string             `json:"version,omitempty"`
}

// ModelClientDisplay defines model for model.client-display.
type ModelClientDisplay struct {
	CompletedJobCount  *int32                          `json:"completed_job_count,omitempty"`
	CompletedTaskCount *int32                          `json:"completed_task_count,omitempty"`
	ConfiguredUser     *string                         `json:"configured_user,omitempty"`
	CurrentJob         *ModelClientScheduledJobDisplay `json:"current_job,omitempty"`
	CurrentJobId       *NullInt64                      `json:"current_job_id,omitempty"`
	CurrentTask        *ModelClientScheduledJobDisplay `json:"current_task,omitempty"`
	CurrentTaskId      *NullInt64                      `json:"current_task_id,omitempty"`
	DomainController   *NullString                     `json:"domain_controller,omitempty"`
	Events             *[]ModelClientScheduleDisplay   `json:"events,omitempty"`
	Hostname           *string                         `json:"hostname,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *openapi_types.UUID `json:"id,omitempty"`
	IpAddress   *string             `json:"ip_address,omitempty"`
	LastCheckin *time.Time          `json:"last_checkin,omitempty"`
	Name        *string             `json:"name,omitempty"`
	Token       *ModelAuthToken     `json:"token,omitempty"`

	// Type This enum describes the collector client type.
	Type    *EnumClientType `json:"type,omitempty"`
	UserSid *NullString     `json:"user_sid,omitempty"`
	Version *string         `json:"version,omitempty"`
}

// ModelClientSchedule defines model for model.client-schedule.
type ModelClientSchedule struct {
	AdStructureCollection  *bool               `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool               `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool               `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool               `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID `json:"client_id,omitempty"`
	CreatedAt              *time.Time          `json:"created_at,omitempty"`
	DcRegistryCollection   *bool               `json:"dc_registry_collection,omitempty"`
	DeletedAt              *NullTime           `json:"deleted_at,omitempty"`
	Domains                *[]string           `json:"domains,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int32     `json:"id,omitempty"`
	LocalGroupCollection *bool      `json:"local_group_collection,omitempty"`
	NextScheduledAt      *time.Time `json:"next_scheduled_at,omitempty"`
	Ous                  *[]string  `json:"ous,omitempty"`
	Rrule                *string    `json:"rrule,omitempty"`
	SessionCollection    *bool      `json:"session_collection,omitempty"`
	UpdatedAt            *time.Time `json:"updated_at,omitempty"`
}

// ModelClientScheduleDisplay defines model for model.client-schedule-display.
type ModelClientScheduleDisplay struct {
	AdStructureCollection  *bool                 `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                 `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                 `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                 `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID   `json:"client_id,omitempty"`
	DcRegistryCollection   *bool                 `json:"dc_registry_collection,omitempty"`
	Domains                *[]ModelDomainDetails `json:"domains,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int32            `json:"id,omitempty"`
	LocalGroupCollection *bool             `json:"local_group_collection,omitempty"`
	Ous                  *[]ModelOuDetails `json:"ous,omitempty"`
	Rrule                *string           `json:"rrule,omitempty"`
	SessionCollection    *bool             `json:"session_collection,omitempty"`
}

// ModelClientScheduledJob defines model for model.client-scheduled-job.
type ModelClientScheduledJob struct {
	AdStructureCollection  *bool                          `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                          `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                          `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                          `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID            `json:"client_id,omitempty"`
	ClientName             *string                        `json:"client_name,omitempty"`
	CreatedAt              *time.Time                     `json:"created_at,omitempty"`
	DcRegistryCollection   *bool                          `json:"dc_registry_collection,omitempty"`
	DeletedAt              *NullTime                      `json:"deleted_at,omitempty"`
	DomainController       *NullString                    `json:"domain_controller,omitempty"`
	DomainResults          *[]ModelDomainCollectionResult `json:"domain_results,omitempty"`
	Domains                *[]string                      `json:"domains,omitempty"`
	EndTime                *time.Time                     `json:"end_time,omitempty"`
	EventId                *NullInt32                     `json:"event_id,omitempty"`
	EventTitle             *string                        `json:"event_title,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int64         `json:"id,omitempty"`
	LastIngest           *time.Time     `json:"last_ingest,omitempty"`
	LocalGroupCollection *bool          `json:"local_group_collection,omitempty"`
	LogPath              *NullString    `json:"log_path,omitempty"`
	Ous                  *[]string      `json:"ous,omitempty"`
	SessionCollection    *bool          `json:"session_collection,omitempty"`
	StartTime            *time.Time     `json:"start_time,omitempty"`
	Status               *EnumJobStatus `json:"status,omitempty"`
	StatusMessage        *string        `json:"statusMessage,omitempty"`
	UpdatedAt            *time.Time     `json:"updated_at,omitempty"`
}

// ModelClientScheduledJobDisplay defines model for model.client-scheduled-job-display.
type ModelClientScheduledJobDisplay struct {
	AdStructureCollection  *bool                          `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                          `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                          `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                          `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID            `json:"client_id,omitempty"`
	ClientName             *string                        `json:"client_name,omitempty"`
	DcRegistryCollection   *bool                          `json:"dc_registry_collection,omitempty"`
	DomainController       *string                        `json:"domain_controller,omitempty"`
	DomainResults          *[]ModelDomainCollectionResult `json:"domain_results,omitempty"`
	Domains                *[]ModelDomainDetails          `json:"domains,omitempty"`
	EndTime                *time.Time                     `json:"end_time,omitempty"`
	EventId                *NullInt32                     `json:"event_id,omitempty"`
	ExecutionTime          *time.Time                     `json:"execution_time,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int64            `json:"id,omitempty"`
	LocalGroupCollection *bool             `json:"local_group_collection,omitempty"`
	Ous                  *[]ModelOuDetails `json:"ous,omitempty"`
	SessionCollection    *bool             `json:"session_collection,omitempty"`
	StartTime            *time.Time        `json:"start_time,omitempty"`

	// Status This enum describes the current status of a Job. Values are:
	// - `-1` Invalid
	// - `0` Ready
	// - `1` Running
	// - `2` Complete
	// - `3` Canceled
	// - `4` Timed Out
	// - `5` Failed
	// - `6` Ingesting
	// - `7` Analyzing
	// - `8` Partially Complete
	Status        *EnumJobStatus `json:"status,omitempty"`
	StatusMessage *string        `json:"status_message,omitempty"`
}

// ModelCollectorManifest defines model for model.collector-manifest.
type ModelCollectorManifest struct {
	Latest   *string                  `json:"latest,omitempty"`
	Versions *[]ModelCollectorVersion `json:"versions,omitempty"`
}

// ModelCollectorVersion defines model for model.collector-version.
type ModelCollectorVersion struct {
	Deprecated *bool   `json:"deprecated,omitempty"`
	Sha256sum  *string `json:"sha256sum,omitempty"`
	Version    *string `json:"version,omitempty"`
}

// ModelComponentsBaseAdEntity defines model for model.components.base-ad-entity.
type ModelComponentsBaseAdEntity struct {
	Exists   *bool   `json:"exists,omitempty"`
	Name     *string `json:"name,omitempty"`
	Objectid *string `json:"objectid,omitempty"`
}

// ModelComponentsInt32Id defines model for model.components.int32.id.
type ModelComponentsInt32Id struct {
	// Id This is the unique identifier for this object.
	Id *int32 `json:"id,omitempty"`
}

// ModelComponentsInt64Id defines model for model.components.int64.id.
type ModelComponentsInt64Id struct {
	// Id This is the unique identifier for this object.
	Id *int64 `json:"id,omitempty"`
}

// ModelComponentsTimestamps defines model for model.components.timestamps.
type ModelComponentsTimestamps struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelComponentsUuid defines model for model.components.uuid.
type ModelComponentsUuid struct {
	// Id This is the unique identifier for this object.
	Id *openapi_types.UUID `json:"id,omitempty"`
}

// ModelDomainCollectionResult defines model for model.domain-collection-result.
type ModelDomainCollectionResult struct {
	// AiacaCount A count of aiacas enumerated
	AiacaCount *int `json:"aiaca_count,omitempty"`

	// CerttemplateCount A count of certtemplates enumerated
	CerttemplateCount *int `json:"certtemplate_count,omitempty"`

	// ComputerCount A count of computers enumerated
	ComputerCount *int `json:"computer_count,omitempty"`

	// ContainerCount A count of containers enumerated
	ContainerCount *int       `json:"container_count,omitempty"`
	CreatedAt      *time.Time `json:"created_at,omitempty"`
	DeletedAt      *NullTime  `json:"deleted_at,omitempty"`

	// DeletedCount A count of deleted objects enumerated
	DeletedCount *int `json:"deleted_count,omitempty"`

	// DomainName Name of the domain that was enumerated
	DomainName *string `json:"domain_name,omitempty"`

	// EnterprisecaCount A count of enterprisecas enumerated
	EnterprisecaCount *int `json:"enterpriseca_count,omitempty"`

	// GpoCount A count of gpos enumerated
	GpoCount *int `json:"gpo_count,omitempty"`

	// GroupCount A count of groups enumerated
	GroupCount *int `json:"group_count,omitempty"`

	// Id This is the unique identifier for this object.
	Id    *int64 `json:"id,omitempty"`
	JobId *int64 `json:"job_id,omitempty"`

	// Message A status message for a domain enumeration result
	Message *string `json:"message,omitempty"`

	// NtauthstoreCount A count of ntauthstores enumerated
	NtauthstoreCount *int `json:"ntauthstore_count,omitempty"`

	// OuCount A count of ous enumerated
	OuCount *int `json:"ou_count,omitempty"`

	// RootcaCount A count of rootcas enumerated
	RootcaCount *int `json:"rootca_count,omitempty"`

	// Success A boolean value indicating whether the domain enumeration succeeded
	Success   *bool      `json:"success,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UserCount A count of users enumerated
	UserCount *int `json:"user_count,omitempty"`
}

// ModelDomainDetails defines model for model.domain-details.
type ModelDomainDetails struct {
	Exists   *bool   `json:"exists,omitempty"`
	Name     *string `json:"name,omitempty"`
	Objectid *string `json:"objectid,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// ModelDomainSelector defines model for model.domain-selector.
type ModelDomainSelector struct {
	Collected *bool   `json:"collected,omitempty"`
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// ModelFeatureFlag defines model for model.feature-flag.
type ModelFeatureFlag struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Enabled     *bool      `json:"enabled,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int32     `json:"id,omitempty"`
	Key           *string    `json:"key,omitempty"`
	Name          *string    `json:"name,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
	UserUpdatable *bool      `json:"user_updatable,omitempty"`
}

// ModelFileUploadJob defines model for model.file-upload-job.
type ModelFileUploadJob struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	EndTime   *time.Time `json:"end_time,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *int64     `json:"id,omitempty"`
	LastIngest *time.Time `json:"last_ingest,omitempty"`
	StartTime  *time.Time `json:"start_time,omitempty"`

	// Status This enum describes the current status of a Job. Values are:
	// - `-1` Invalid
	// - `0` Ready
	// - `1` Running
	// - `2` Complete
	// - `3` Canceled
	// - `4` Timed Out
	// - `5` Failed
	// - `6` Ingesting
	// - `7` Analyzing
	// - `8` Partially Complete
	Status           *EnumJobStatus       `json:"status,omitempty"`
	StatusMessage    *string              `json:"status_message,omitempty"`
	UpdatedAt        *time.Time           `json:"updated_at,omitempty"`
	UserEmailAddress *openapi_types.Email `json:"user_email_address,omitempty"`
	UserId           *openapi_types.UUID  `json:"user_id,omitempty"`
}

// ModelListFinding defines model for model.list-finding.
type ModelListFinding struct {
	DomainSID     *string                            `json:"DomainSID,omitempty"`
	Finding       *string                            `json:"Finding,omitempty"`
	Principal     *string                            `json:"Principal,omitempty"`
	PrincipalKind *string                            `json:"PrincipalKind,omitempty"`
	Props         *map[string]map[string]interface{} `json:"Props,omitempty"`
	AcceptedUntil *time.Time                         `json:"accepted_until,omitempty"`
	CreatedAt     *time.Time                         `json:"created_at,omitempty"`
	DeletedAt     *NullTime                          `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelOuDetails defines model for model.ou-details.
type ModelOuDetails struct {
	Distinguishedname *string `json:"distinguishedname,omitempty"`
	Exists            *bool   `json:"exists,omitempty"`
	Name              *string `json:"name,omitempty"`
	Objectid          *string `json:"objectid,omitempty"`
	Type              *string `json:"type,omitempty"`
}

// ModelPermission defines model for model.permission.
type ModelPermission struct {
	Authority *string    `json:"authority,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRelationshipFinding defines model for model.relationship-finding.
type ModelRelationshipFinding struct {
	AcceptedUntil        *time.Time                         `json:"AcceptedUntil,omitempty"`
	ComboGraphRelationID *NullInt64                         `json:"ComboGraphRelationID,omitempty"`
	DomainSID            *string                            `json:"DomainSID,omitempty"`
	Finding              *string                            `json:"Finding,omitempty"`
	FromPrincipal        *string                            `json:"FromPrincipal,omitempty"`
	FromPrincipalKind    *string                            `json:"FromPrincipalKind,omitempty"`
	FromPrincipalProps   *map[string]map[string]interface{} `json:"FromPrincipalProps,omitempty"`
	PrincipalHash        *string                            `json:"PrincipalHash,omitempty"`
	RelProps             *map[string]map[string]interface{} `json:"RelProps,omitempty"`
	ToPrincipal          *string                            `json:"ToPrincipal,omitempty"`
	ToPrincipalKind      *string                            `json:"ToPrincipalKind,omitempty"`
	ToPrincipalProps     *map[string]map[string]interface{} `json:"ToPrincipalProps,omitempty"`
	CreatedAt            *time.Time                         `json:"created_at,omitempty"`
	DeletedAt            *NullTime                          `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRiskCounts defines model for model.risk-counts.
type ModelRiskCounts struct {
	CompositeRisk      *float64   `json:"CompositeRisk,omitempty"`
	DomainSID          *string    `json:"DomainSID,omitempty"`
	Finding            *string    `json:"Finding,omitempty"`
	FindingCount       *int       `json:"FindingCount,omitempty"`
	ImpactedAssetCount *int       `json:"ImpactedAssetCount,omitempty"`
	CreatedAt          *time.Time `json:"created_at,omitempty"`
	DeletedAt          *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRiskPostureStat defines model for model.risk-posture-stat.
type ModelRiskPostureStat struct {
	CreatedAt         *time.Time `json:"created_at,omitempty"`
	CriticalRiskCount *int       `json:"critical_risk_count,omitempty"`
	DeletedAt         *NullTime  `json:"deleted_at,omitempty"`
	DomainSid         *string    `json:"domain_sid,omitempty"`
	ExposureIndex     *float64   `json:"exposure_index,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int64     `json:"id,omitempty"`
	TierZeroCount *int64     `json:"tier_zero_count,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
}

// ModelRole defines model for model.role.
type ModelRole struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *int32             `json:"id,omitempty"`
	Name        *string            `json:"name,omitempty"`
	Permissions *[]ModelPermission `json:"permissions,omitempty"`
	UpdatedAt   *time.Time         `json:"updated_at,omitempty"`
}

// ModelSamlProvider defines model for model.saml-provider.
type ModelSamlProvider struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	DisplayName *string    `json:"display_name,omitempty"`

	// Id This is the unique identifier for this object.
	Id                         *int32     `json:"id,omitempty"`
	IdpIssuerUri               *string    `json:"idp_issuer_uri,omitempty"`
	IdpSsoUri                  *string    `json:"idp_sso_uri,omitempty"`
	Name                       *string    `json:"name,omitempty"`
	PrincipalAttributeMappings *[]string  `json:"principal_attribute_mappings,omitempty"`
	SpAcsUri                   *string    `json:"sp_acs_uri,omitempty"`
	SpIssuerUri                *string    `json:"sp_issuer_uri,omitempty"`
	SpMetadataUri              *string    `json:"sp_metadata_uri,omitempty"`
	SpSsoUri                   *string    `json:"sp_sso_uri,omitempty"`
	UpdatedAt                  *time.Time `json:"updated_at,omitempty"`
}

// ModelSamlSignOnEndpoint defines model for model.saml-sign-on-endpoint.
type ModelSamlSignOnEndpoint struct {
	IdpUrl *string `json:"idp_url,omitempty"`
	Name   *string `json:"name,omitempty"`
}

// ModelSavedQueriesPermissions defines model for model.saved-queries-permissions.
type ModelSavedQueriesPermissions struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id             *int64     `json:"id,omitempty"`
	Public         *bool      `json:"public,omitempty"`
	QueryId        *int64     `json:"query_id,omitempty"`
	SharedToUserId *NullUuid  `json:"shared_to_user_id,omitempty"`
	UpdatedAt      *time.Time `json:"updated_at,omitempty"`
}

// ModelSavedQuery defines model for model.saved-query.
type ModelSavedQuery struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64              `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Query     *string             `json:"query,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	UserId    *openapi_types.UUID `json:"user_id,omitempty"`
}

// ModelSearchResult defines model for model.search-result.
type ModelSearchResult struct {
	Distinguishedname *string `json:"distinguishedname,omitempty"`
	Name              *string `json:"name,omitempty"`
	Objectid          *string `json:"objectid,omitempty"`
	SystemTags        *string `json:"system_tags,omitempty"`
	Type              *string `json:"type,omitempty"`
}

// ModelUnifiedGraphEdge defines model for model.unified-graph.edge.
type ModelUnifiedGraphEdge struct {
	Kind       *string                            `json:"kind,omitempty"`
	Label      *string                            `json:"label,omitempty"`
	LastSeen   *time.Time                         `json:"lastSeen,omitempty"`
	Properties *map[string]map[string]interface{} `json:"properties,omitempty"`
	Source     *string                            `json:"source,omitempty"`
	Target     *string                            `json:"target,omitempty"`
}

// ModelUnifiedGraphGraph defines model for model.unified-graph.graph.
type ModelUnifiedGraphGraph struct {
	Edges *[]ModelUnifiedGraphEdge          `json:"edges,omitempty"`
	Nodes *map[string]ModelUnifiedGraphNode `json:"nodes,omitempty"`
}

// ModelUnifiedGraphNode defines model for model.unified-graph.node.
type ModelUnifiedGraphNode struct {
	IsTierZero *string                            `json:"isTierZero,omitempty"`
	Kind       *string                            `json:"kind,omitempty"`
	Label      *string                            `json:"label,omitempty"`
	LastSeen   *time.Time                         `json:"lastSeen,omitempty"`
	ObjectId   *string                            `json:"objectId,omitempty"`
	Properties *map[string]map[string]interface{} `json:"properties,omitempty"`
}

// ModelUser defines model for model.user.
type ModelUser struct {
	AuthSecret   *ModelAuthSecret `json:"AuthSecret,omitempty"`
	CreatedAt    *time.Time       `json:"created_at,omitempty"`
	DeletedAt    *NullTime        `json:"deleted_at,omitempty"`
	EmailAddress *NullString      `json:"email_address,omitempty"`
	EulaAccepted *bool            `json:"eula_accepted,omitempty"`
	FirstName    *NullString      `json:"first_name,omitempty"`

	// Id This is the unique identifier for this object.
	Id             *openapi_types.UUID `json:"id,omitempty"`
	IsDisabled     *bool               `json:"is_disabled,omitempty"`
	LastLogin      *time.Time          `json:"last_login,omitempty"`
	LastName       *NullString         `json:"last_name,omitempty"`
	PrincipalName  *string             `json:"principal_name,omitempty"`
	Roles          *[]ModelRole        `json:"roles,omitempty"`
	SamlProviderId *NullInt32          `json:"saml_provider_id,omitempty"`
	UpdatedAt      *time.Time          `json:"updated_at,omitempty"`
}

// NullInt32 defines model for null.int32.
type NullInt32 struct {
	Int32 *int32 `json:"int32,omitempty"`

	// Valid Valid is true if `int32` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullInt64 defines model for null.int64.
type NullInt64 struct {
	Int64 *int64 `json:"int64,omitempty"`

	// Valid Valid is true if `int64` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullString defines model for null.string.
type NullString struct {
	String *string `json:"string,omitempty"`

	// Valid Valid is true if `string`` is not `null`
	Valid *bool `json:"valid,omitempty"`
}

// NullTime defines model for null.time.
type NullTime struct {
	// Time An RFC-3339 formatted string
	Time *time.Time `json:"time,omitempty"`

	// Valid Valid is true if `time` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullUuid defines model for null.uuid.
type NullUuid struct {
	Uuid *openapi_types.UUID `json:"uuid,omitempty"`

	// Valid Valid is true if `uuid` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// HeaderPrefer defines model for header.prefer.
type HeaderPrefer = int

// PathObjectId The unique object identifier
type PathObjectId = string

// QueryClientsHydrateDomains defines model for query.clients.hydrate-domains.
type QueryClientsHydrateDomains = bool

// QueryClientsHydrateOus defines model for query.clients.hydrate-ous.
type QueryClientsHydrateOus = bool

// QueryClientsJobAdStructureCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobAdStructureCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobCaRegistryCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobCaRegistryCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobCertServicesCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobCertServicesCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobClientId Filter results by column string-formatted uuid value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobClientId = ApiParamsPredicateFilterUuid

// QueryClientsJobDcRegistryCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobDcRegistryCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobDomainController Filter results by column string value. Valid filter predicates are `eq`, `~eq`, `neq`.
type QueryClientsJobDomainController = ApiParamsPredicateFilterString

// QueryClientsJobEndTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobEndTime = ApiParamsPredicateFilterTime

// QueryClientsJobEventId Filter results by column integer value. Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobEventId = ApiParamsPredicateFilterInteger

// QueryClientsJobEventTitle Filter results by column string value. Valid filter predicates are `eq`, `~eq`, `neq`.
type QueryClientsJobEventTitle = ApiParamsPredicateFilterString

// QueryClientsJobExecutionTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobExecutionTime = ApiParamsPredicateFilterTime

// QueryClientsJobLastIngest Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobLastIngest = ApiParamsPredicateFilterTime

// QueryClientsJobLocalGroupCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobLocalGroupCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobLogPath Filter results by column string value. Valid filter predicates are `eq`, `~eq`, `neq`.
type QueryClientsJobLogPath = ApiParamsPredicateFilterString

// QueryClientsJobSessionCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobSessionCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobStartTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobStartTime = ApiParamsPredicateFilterTime

// QueryClientsJobStatus Filter results by column string value. Valid filter predicates are `eq`, `~eq`, `neq`.
type QueryClientsJobStatus = ApiParamsPredicateFilterString

// QueryCreatedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryCreatedAt = ApiParamsPredicateFilterTime

// QueryDeletedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryDeletedAt = ApiParamsPredicateFilterTime

// QueryEntityLimit defines model for query.entity.limit.
type QueryEntityLimit = int

// QueryEntitySkip defines model for query.entity.skip.
type QueryEntitySkip = int

// QueryEntitySortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order.
// See parameter description for details about which columns are sortable.
type QueryEntitySortBy = ApiParamsQuerySortBy

// QueryEntityType defines model for query.entity.type.
type QueryEntityType string

// QueryHydrateCounts defines model for query.hydrate-counts.
type QueryHydrateCounts = bool

// QueryLimit The limit of results requested by the client.
type QueryLimit = ApiParamsQueryLimit

// QuerySkip The number of items to skip in a paginated response.
type QuerySkip = ApiParamsQuerySkip

// QueryUpdatedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryUpdatedAt = ApiParamsPredicateFilterTime

// BadRequest defines model for bad-request.
type BadRequest = ApiErrorWrapper

// EntityInfoQueryResults defines model for entity-info-query-results.
type EntityInfoQueryResults struct {
	Data *struct {
		Props *map[string]map[string]interface{} `json:"props,omitempty"`
	} `json:"data,omitempty"`
}

// ErrorResponse defines model for error-response.
type ErrorResponse = ApiErrorWrapper

// Forbidden defines model for forbidden.
type Forbidden = ApiErrorWrapper

// InternalServerError defines model for internal-server-error.
type InternalServerError = ApiErrorWrapper

// NotFound defines model for not-found.
type NotFound = ApiErrorWrapper

// RelatedEntityQueryResults defines model for related-entity-query-results.
type RelatedEntityQueryResults struct {
	// Count The total number of results.
	Count *int `json:"count,omitempty"`
	Data  *[]struct {
		Label    *string `json:"label,omitempty"`
		Name     *string `json:"name,omitempty"`
		ObjectID *string `json:"objectID,omitempty"`
	} `json:"data,omitempty"`

	// Limit The limit of results requested by the client.
	Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

	// Skip The number of items to skip in a paginated response.
	Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
}

// TooManyRequests defines model for too-many-requests.
type TooManyRequests = ApiErrorWrapper

// Unauthorized defines model for unauthorized.
type Unauthorized = ApiErrorWrapper

// AcceptEulaParams defines parameters for AcceptEula.
type AcceptEulaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAdDomainDataQualityStatsParams defines parameters for GetAdDomainDataQualityStats.
type GetAdDomainDataQualityStatsParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityParams defines parameters for GetAiaCaEntity.
type GetAiaCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityControllersParams defines parameters for GetAiaCaEntityControllers.
type GetAiaCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetAiaCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityControllersParamsType defines parameters for GetAiaCaEntityControllers.
type GetAiaCaEntityControllersParamsType string

// StartAnalysisParams defines parameters for StartAnalysis.
type StartAnalysisParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupsParams defines parameters for ListAssetGroups.
type ListAssetGroupsParams struct {
	// SortBy Sortable columns are `name`, `tag`, and `member_count`.
	SortBy      *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name        *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Tag         *ApiParamsPredicateFilterString  `form:"tag,omitempty" json:"tag,omitempty"`
	SystemGroup *ApiParamsPredicateFilterString  `form:"system_group,omitempty" json:"system_group,omitempty"`
	MemberCount *ApiParamsPredicateFilterInteger `form:"member_count,omitempty" json:"member_count,omitempty"`
	Id          *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAssetGroupParams defines parameters for CreateAssetGroup.
type CreateAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAssetGroupParams defines parameters for DeleteAssetGroup.
type DeleteAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupParams defines parameters for GetAssetGroup.
type GetAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupJSONBody defines parameters for UpdateAssetGroup.
type UpdateAssetGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
}

// UpdateAssetGroupParams defines parameters for UpdateAssetGroup.
type UpdateAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupCollectionsParams defines parameters for ListAssetGroupCollections.
type ListAssetGroupCollectionsParams struct {
	SortBy *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id     *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupComboNodeParams defines parameters for GetAssetGroupComboNode.
type GetAssetGroupComboNodeParams struct {
	// Domainsid Filter by Domain security identifier.
	Domainsid *string `form:"domainsid,omitempty" json:"domainsid,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupCustomMemberCountParams defines parameters for GetAssetGroupCustomMemberCount.
type GetAssetGroupCustomMemberCountParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupMembersParams defines parameters for ListAssetGroupMembers.
type ListAssetGroupMembersParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `object_id`, `asset_group_id`, `primary_kind`, `environment_id`, `environment_kind`, and `name`.
	SortBy          *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	ObjectId        *ApiParamsPredicateFilterString `form:"object_id,omitempty" json:"object_id,omitempty"`
	PrimaryKind     *ApiParamsPredicateFilterString `form:"primary_kind,omitempty" json:"primary_kind,omitempty"`
	EnvironmentId   *ApiParamsPredicateFilterString `form:"environment_id,omitempty" json:"environment_id,omitempty"`
	EnvironmentKind *ApiParamsPredicateFilterString `form:"environment_kind,omitempty" json:"environment_kind,omitempty"`
	Name            *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	CustomMember    *ApiParamsPredicateFilterString `form:"custom_member,omitempty" json:"custom_member,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupMemberCountByKindParams defines parameters for ListAssetGroupMemberCountByKind.
type ListAssetGroupMemberCountByKindParams struct {
	ObjectId        *ApiParamsPredicateFilterString `form:"object_id,omitempty" json:"object_id,omitempty"`
	EnvironmentId   *ApiParamsPredicateFilterString `form:"environment_id,omitempty" json:"environment_id,omitempty"`
	PrimaryKind     *ApiParamsPredicateFilterString `form:"primary_kind,omitempty" json:"primary_kind,omitempty"`
	EnvironmentKind *ApiParamsPredicateFilterString `form:"environment_kind,omitempty" json:"environment_kind,omitempty"`
	Name            *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	CustomMember    *ApiParamsPredicateFilterString `form:"custom_member,omitempty" json:"custom_member,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupSelectorsDeprecatedJSONBody defines parameters for UpdateAssetGroupSelectorsDeprecated.
type UpdateAssetGroupSelectorsDeprecatedJSONBody = []ModelAssetGroupSelectorSpec

// UpdateAssetGroupSelectorsDeprecatedParams defines parameters for UpdateAssetGroupSelectorsDeprecated.
type UpdateAssetGroupSelectorsDeprecatedParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupSelectorsJSONBody defines parameters for UpdateAssetGroupSelectors.
type UpdateAssetGroupSelectorsJSONBody = []ModelAssetGroupSelectorSpec

// UpdateAssetGroupSelectorsParams defines parameters for UpdateAssetGroupSelectors.
type UpdateAssetGroupSelectorsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAssetGroupSelectorParams defines parameters for DeleteAssetGroupSelector.
type DeleteAssetGroupSelectorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAttackPathTypesParams defines parameters for ListAttackPathTypes.
type ListAttackPathTypesParams struct {
	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy  *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding *ApiParamsPredicateFilterString `form:"finding,omitempty" json:"finding,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// StartAnalysisBheParams defines parameters for StartAnalysisBhe.
type StartAnalysisBheParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAttackPathRiskJSONBody defines parameters for UpdateAttackPathRisk.
type UpdateAttackPathRiskJSONBody struct {
	AcceptUntil *time.Time `json:"accept_until,omitempty"`
	Accepted    *bool      `json:"accepted,omitempty"`
	RiskType    *string    `json:"risk_type,omitempty"`
}

// UpdateAttackPathRiskParams defines parameters for UpdateAttackPathRisk.
type UpdateAttackPathRiskParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// SortBy Sortable columns are `id`, `actor_id`, `actor_name`, `actor_email`, `action`, `request_id`, `created_at`, `source`, and `status`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Before Return logs created before the specified time. Value should be in the RFC-3339 format. If not supplied, this will default to the current time.
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`

	// After Return logs created after the specified time. Value should be in the RFC-3339 format. If not supplied, this will default to 1 year before the current time.
	After      *time.Time                      `form:"after,omitempty" json:"after,omitempty"`
	Id         *ApiParamsPredicateFilterString `form:"id,omitempty" json:"id,omitempty"`
	ActorId    *ApiParamsPredicateFilterString `form:"actor_id,omitempty" json:"actor_id,omitempty"`
	ActorName  *ApiParamsPredicateFilterString `form:"actor_name,omitempty" json:"actor_name,omitempty"`
	ActorEmail *ApiParamsPredicateFilterString `form:"actor_email,omitempty" json:"actor_email,omitempty"`
	Action     *ApiParamsPredicateFilterString `form:"action,omitempty" json:"action,omitempty"`
	RequestId  *ApiParamsPredicateFilterString `form:"request_id,omitempty" json:"request_id,omitempty"`
	Source     *ApiParamsPredicateFilterString `form:"source,omitempty" json:"source,omitempty"`

	// Status Filter results by column value. Valid filter predicates are `eq`, `neq`. Valid values are `success` and `failure`.
	Status *ApiParamsPredicateFilterString `form:"status,omitempty" json:"status,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAvailableDomainsParams defines parameters for GetAvailableDomains.
type GetAvailableDomainsParams struct {
	// SortBy Sortable columns are objectid, name.
	SortBy    *ApiParamsPredicateFilterString `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Objectid  *ApiParamsPredicateFilterString `form:"objectid,omitempty" json:"objectid,omitempty"`
	Name      *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	Collected *ApiParamsPredicateFilterString `form:"collected,omitempty" json:"collected,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureTenantDataQualityStatsParams defines parameters for GetAzureTenantDataQualityStats.
type GetAzureTenantDataQualityStatsParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureEntityParams defines parameters for GetAzureEntity.
type GetAzureEntityParams struct {
	// ObjectId The object ID of the entity being operated on.
	ObjectId string `form:"object_id" json:"object_id"`

	// Counts Returns related entity counts. Does not work with `related_entity_type` parameter.
	Counts *bool `form:"counts,omitempty" json:"counts,omitempty"`

	// RelatedEntityType Flags the query to return related entity information based on the type passed.
	RelatedEntityType *string `form:"related_entity_type,omitempty" json:"related_entity_type,omitempty"`

	// Type The type of return data expected. Only works with `related_entity_type` parameter.
	Type *GetAzureEntityParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	// Only compatible with `related_entity_type` and `type=list`
	Skip *ApiParamsQuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	// Only compatible with `related_entity_type` and `type=list`
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureEntityParamsType defines parameters for GetAzureEntity.
type GetAzureEntityParamsType string

// GetEntityParams defines parameters for GetEntity.
type GetEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllablesParams defines parameters for GetEntityControllables.
type GetEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllablesParamsType defines parameters for GetEntityControllables.
type GetEntityControllablesParamsType string

// GetEntityControllersParams defines parameters for GetEntityControllers.
type GetEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllersParamsType defines parameters for GetEntityControllers.
type GetEntityControllersParamsType string

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// SortBy Sortable columns are first_name, last_name, email_address, principal_name, last_login, created_at, updated_at, deleted_at.
	SortBy        *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	FirstName     *ApiParamsPredicateFilterString `form:"first_name,omitempty" json:"first_name,omitempty"`
	LastName      *ApiParamsPredicateFilterString `form:"last_name,omitempty" json:"last_name,omitempty"`
	EmailAddress  *ApiParamsPredicateFilterString `form:"email_address,omitempty" json:"email_address,omitempty"`
	PrincipalName *ApiParamsPredicateFilterString `form:"principal_name,omitempty" json:"principal_name,omitempty"`
	Id            *ApiParamsPredicateFilterUuid   `form:"id,omitempty" json:"id,omitempty"`
	LastLogin     *ApiParamsPredicateFilterTime   `form:"last_login,omitempty" json:"last_login,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	EmailAddress       *openapi_types.Email `json:"email_address,omitempty"`
	FirstName          *string              `json:"first_name,omitempty"`
	IsDisabled         *bool                `json:"is_disabled,omitempty"`
	LastName           *string              `json:"last_name,omitempty"`
	NeedsPasswordReset *bool                `json:"needs_password_reset,omitempty"`
	Principal          *string              `json:"principal,omitempty"`
	Roles              *[]int32             `json:"roles,omitempty"`
	SamlProviderId     *string              `json:"saml_provider_id,omitempty"`
	Secret             *string              `json:"secret,omitempty"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateUserParams defines parameters for UpdateUser.
type UpdateUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// RemoveUserMfaJSONBody defines parameters for RemoveUserMfa.
type RemoveUserMfaJSONBody struct {
	Secret *string `json:"secret,omitempty"`
}

// RemoveUserMfaParams defines parameters for RemoveUserMfa.
type RemoveUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// AddUserMfaJSONBody defines parameters for AddUserMfa.
type AddUserMfaJSONBody struct {
	Secret *string `json:"secret,omitempty"`
}

// AddUserMfaParams defines parameters for AddUserMfa.
type AddUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetMfaActivationStatusParams defines parameters for GetMfaActivationStatus.
type GetMfaActivationStatusParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ActivateUserMfaJSONBody defines parameters for ActivateUserMfa.
type ActivateUserMfaJSONBody struct {
	Otp *string `json:"otp,omitempty"`
}

// ActivateUserMfaParams defines parameters for ActivateUserMfa.
type ActivateUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteUserSecretParams defines parameters for DeleteUserSecret.
type DeleteUserSecretParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateOrSetUserSecretParams defines parameters for CreateOrSetUserSecret.
type CreateOrSetUserSecretParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityParams defines parameters for GetCertTemplateEntity.
type GetCertTemplateEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityControllersParams defines parameters for GetCertTemplateEntityControllers.
type GetCertTemplateEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetCertTemplateEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityControllersParamsType defines parameters for GetCertTemplateEntityControllers.
type GetCertTemplateEntityControllersParamsType string

// DeleteBloodHoundDatabaseJSONBody defines parameters for DeleteBloodHoundDatabase.
type DeleteBloodHoundDatabaseJSONBody struct {
	DeleteAssetGroupSelectors *[]int `json:"deleteAssetGroupSelectors,omitempty"`
	DeleteCollectedGraphData  *bool  `json:"deleteCollectedGraphData,omitempty"`
	DeleteDataQualityHistory  *bool  `json:"deleteDataQualityHistory,omitempty"`
	DeleteFileIngestHistory   *bool  `json:"deleteFileIngestHistory,omitempty"`
}

// DeleteBloodHoundDatabaseParams defines parameters for DeleteBloodHoundDatabase.
type DeleteBloodHoundDatabaseParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientsParams defines parameters for ListClients.
type ListClientsParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `name`, `ip_address`, `hostname`, `configured_user`, `last_checkin`, `completed_job_count`, `created_at`, `updated_at`, `deleted_at`.
	SortBy            *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name              *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	IpAddress         *ApiParamsPredicateFilterString  `form:"ip_address,omitempty" json:"ip_address,omitempty"`
	Hostname          *ApiParamsPredicateFilterString  `form:"hostname,omitempty" json:"hostname,omitempty"`
	ConfiguredUser    *ApiParamsPredicateFilterString  `form:"configured_user,omitempty" json:"configured_user,omitempty"`
	Version           *ApiParamsPredicateFilterString  `form:"version,omitempty" json:"version,omitempty"`
	UserSid           *ApiParamsPredicateFilterString  `form:"user_sid,omitempty" json:"user_sid,omitempty"`
	LastCheckin       *ApiParamsPredicateFilterString  `form:"last_checkin,omitempty" json:"last_checkin,omitempty"`
	CurrentJobId      *ApiParamsPredicateFilterInteger `form:"current_job_id,omitempty" json:"current_job_id,omitempty"`
	CompletedJobCount *ApiParamsPredicateFilterInteger `form:"completed_job_count,omitempty" json:"completed_job_count,omitempty"`
	DomainController  *ApiParamsPredicateFilterString  `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Id                *ApiParamsPredicateFilterUuid    `form:"id,omitempty" json:"id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientJSONBody defines parameters for CreateClient.
type CreateClientJSONBody struct {
	DomainController *string                `json:"domain_controller,omitempty"`
	Events           *[]ModelClientSchedule `json:"events,omitempty"`
	Name             *string                `json:"name,omitempty"`

	// Type This enum describes the collector client type.
	Type *EnumClientType `json:"type,omitempty"`
}

// CreateClientParams defines parameters for CreateClient.
type CreateClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LogClientErrorJSONBody defines parameters for LogClientError.
type LogClientErrorJSONBody struct {
	Additional *map[string]string `json:"additional,omitempty"`
	TaskError  *string            `json:"task_error,omitempty"`
}

// LogClientErrorParams defines parameters for LogClientError.
type LogClientErrorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientInfoJSONBody defines parameters for UpdateClientInfo.
type UpdateClientInfoJSONBody struct {
	Address  *string `json:"address,omitempty"`
	Hostname *string `json:"hostname,omitempty"`
	Username *string `json:"username,omitempty"`
	Usersid  *string `json:"usersid,omitempty"`
	Version  *string `json:"version,omitempty"`
}

// UpdateClientInfoParams defines parameters for UpdateClientInfo.
type UpdateClientInfoParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteClientParams defines parameters for DeleteClient.
type DeleteClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientParams defines parameters for GetClient.
type GetClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientJSONBody defines parameters for UpdateClient.
type UpdateClientJSONBody struct {
	DomainController *string `json:"domain_controller,omitempty"`
	Name             *string `json:"name,omitempty"`
}

// UpdateClientParams defines parameters for UpdateClient.
type UpdateClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientCompletedJobsParams defines parameters for ListClientCompletedJobs.
type ListClientCompletedJobsParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientCompletedTasksParams defines parameters for ListClientCompletedTasks.
type ListClientCompletedTasksParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduledJobParams defines parameters for CreateClientScheduledJob.
type CreateClientScheduledJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduledTaskParams defines parameters for CreateClientScheduledTask.
type CreateClientScheduledTaskParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ReplaceClientTokenParams defines parameters for ReplaceClientToken.
type ReplaceClientTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCollectorManifestParams defines parameters for GetCollectorManifest.
type GetCollectorManifestParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DownloadCollectorParams defines parameters for DownloadCollector.
type DownloadCollectorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCollectorChecksumParams defines parameters for GetCollectorChecksum.
type GetCollectorChecksumParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCompletenessStatsParams defines parameters for GetCompletenessStats.
type GetCompletenessStatsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityParams defines parameters for GetComputerEntity.
type GetComputerEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminRightsParams defines parameters for GetComputerEntityAdminRights.
type GetComputerEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminRightsParamsType defines parameters for GetComputerEntityAdminRights.
type GetComputerEntityAdminRightsParamsType string

// GetComputerEntityAdminsParams defines parameters for GetComputerEntityAdmins.
type GetComputerEntityAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminsParamsType defines parameters for GetComputerEntityAdmins.
type GetComputerEntityAdminsParamsType string

// GetComputerEntityConstrainedDelegationRightsParams defines parameters for GetComputerEntityConstrainedDelegationRights.
type GetComputerEntityConstrainedDelegationRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityConstrainedDelegationRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityConstrainedDelegationRightsParamsType defines parameters for GetComputerEntityConstrainedDelegationRights.
type GetComputerEntityConstrainedDelegationRightsParamsType string

// GetComputerEntityConstrainedUsersParams defines parameters for GetComputerEntityConstrainedUsers.
type GetComputerEntityConstrainedUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityConstrainedUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityConstrainedUsersParamsType defines parameters for GetComputerEntityConstrainedUsers.
type GetComputerEntityConstrainedUsersParamsType string

// GetComputerEntityControllablesParams defines parameters for GetComputerEntityControllables.
type GetComputerEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityControllablesParamsType defines parameters for GetComputerEntityControllables.
type GetComputerEntityControllablesParamsType string

// GetComputerEntityControllersParams defines parameters for GetComputerEntityControllers.
type GetComputerEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityControllersParamsType defines parameters for GetComputerEntityControllers.
type GetComputerEntityControllersParamsType string

// GetComputerEntityDcomRightsParams defines parameters for GetComputerEntityDcomRights.
type GetComputerEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityDcomRightsParamsType defines parameters for GetComputerEntityDcomRights.
type GetComputerEntityDcomRightsParamsType string

// GetComputerEntityDcomUsersParams defines parameters for GetComputerEntityDcomUsers.
type GetComputerEntityDcomUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityDcomUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityDcomUsersParamsType defines parameters for GetComputerEntityDcomUsers.
type GetComputerEntityDcomUsersParamsType string

// GetComputerEntityGroupMembershipParams defines parameters for GetComputerEntityGroupMembership.
type GetComputerEntityGroupMembershipParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityGroupMembershipParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityGroupMembershipParamsType defines parameters for GetComputerEntityGroupMembership.
type GetComputerEntityGroupMembershipParamsType string

// GetComputerEntityPsRemoteRightsParams defines parameters for GetComputerEntityPsRemoteRights.
type GetComputerEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityPsRemoteRightsParamsType defines parameters for GetComputerEntityPsRemoteRights.
type GetComputerEntityPsRemoteRightsParamsType string

// GetComputerEntityPsRemoteUsersParams defines parameters for GetComputerEntityPsRemoteUsers.
type GetComputerEntityPsRemoteUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityPsRemoteUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityPsRemoteUsersParamsType defines parameters for GetComputerEntityPsRemoteUsers.
type GetComputerEntityPsRemoteUsersParamsType string

// GetComputerEntityRdpRightsParams defines parameters for GetComputerEntityRdpRights.
type GetComputerEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityRdpRightsParamsType defines parameters for GetComputerEntityRdpRights.
type GetComputerEntityRdpRightsParamsType string

// GetComputerEntityRdpUsersParams defines parameters for GetComputerEntityRdpUsers.
type GetComputerEntityRdpUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityRdpUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityRdpUsersParamsType defines parameters for GetComputerEntityRdpUsers.
type GetComputerEntityRdpUsersParamsType string

// GetComputerEntitySessionsParams defines parameters for GetComputerEntitySessions.
type GetComputerEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntitySessionsParamsType defines parameters for GetComputerEntitySessions.
type GetComputerEntitySessionsParamsType string

// GetComputerEntitySqlAdminsParams defines parameters for GetComputerEntitySqlAdmins.
type GetComputerEntitySqlAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntitySqlAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntitySqlAdminsParamsType defines parameters for GetComputerEntitySqlAdmins.
type GetComputerEntitySqlAdminsParamsType string

// ListAppConfigParamsParams defines parameters for ListAppConfigParams.
type ListAppConfigParamsParams struct {
	// Parameter Parameter filter. Must follow the convention: parameter=eq:value
	Parameter *string `form:"parameter,omitempty" json:"parameter,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// SetAppConfigParamParams defines parameters for SetAppConfigParam.
type SetAppConfigParamParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityParams defines parameters for GetContainerEntity.
type GetContainerEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityControllersParams defines parameters for GetContainerEntityControllers.
type GetContainerEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetContainerEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityControllersParamsType defines parameters for GetContainerEntityControllers.
type GetContainerEntityControllersParamsType string

// GetDatapipeStatusParams defines parameters for GetDatapipeStatus.
type GetDatapipeStatusParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ExportAttackPathFindingsParams defines parameters for ExportAttackPathFindings.
type ExportAttackPathFindingsParams struct {
	// Finding Finding Type
	Finding string `form:"finding" json:"finding"`

	// FilterAccepted Risk acceptance filter
	FilterAccepted *EnumRiskAcceptance `form:"filterAccepted,omitempty" json:"filterAccepted,omitempty"`

	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAvailableAttackPathTypesForDomainParams defines parameters for ListAvailableAttackPathTypesForDomain.
type ListAvailableAttackPathTypesForDomainParams struct {
	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy  *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding *ApiParamsPredicateFilterString `form:"finding,omitempty" json:"finding,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListDomainAttackPathsDetailsParams defines parameters for ListDomainAttackPathsDetails.
type ListDomainAttackPathsDetailsParams struct {
	FindingDeprecated *ApiParamsPredicateFilterString `form:"finding,omitempty" json:"finding,omitempty"`

	// SortBy Sortable columns are `domain_sid`, `index`, `AcceptedUntil`, `id`, `created_at`, `updated_at`, `deleted_at`. Relationship risks can be sorted on `FromPrincipal` and `ToPrincipal` in addition to the sortable columns for List Risks.
	SortBy                  *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	FromPrincipalDeprecated *ApiParamsPredicateFilterString  `form:"FromPrincipal,omitempty" json:"FromPrincipal,omitempty"`
	ToPrincipalDeprecated   *ApiParamsPredicateFilterString  `form:"ToPrincipal,omitempty" json:"ToPrincipal,omitempty"`
	FromPrincipal           *ApiParamsPredicateFilterString  `form:"from_principal,omitempty" json:"from_principal,omitempty"`
	ToPrincipal             *ApiParamsPredicateFilterString  `form:"to_principal,omitempty" json:"to_principal,omitempty"`
	PrincipalsHash          *ApiParamsPredicateFilterString  `form:"principals_hash,omitempty" json:"principals_hash,omitempty"`
	Accepted                *ApiParamsPredicateFilterString  `form:"Accepted,omitempty" json:"Accepted,omitempty"`
	AcceptedUntilDeprecated *ApiParamsPredicateFilterTime    `form:"AcceptedUntil,omitempty" json:"AcceptedUntil,omitempty"`
	AcceptedUntil           *ApiParamsPredicateFilterTime    `form:"accepted_until,omitempty" json:"accepted_until,omitempty"`
	Principal               *ApiParamsPredicateFilterString  `form:"Principal,omitempty" json:"Principal,omitempty"`
	Finding                 *ApiParamsPredicateFilterString  `form:"Finding,omitempty" json:"Finding,omitempty"`
	DomainSid               *ApiParamsPredicateFilterString  `form:"domain_sid,omitempty" json:"domain_sid,omitempty"`
	Id                      *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAttackPathSparklineValuesParams defines parameters for ListAttackPathSparklineValues.
type ListAttackPathSparklineValuesParams struct {
	// SortBy Sortable columns are `CompositeRisk`, `FindingCount`, `ImpactedAssetCount`, `domain_sid`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy  *ApiParamsQuerySortBy          `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding ApiParamsPredicateFilterString `form:"finding" json:"finding"`

	// From Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	From *ApiParamsPredicateFilterTime `form:"from,omitempty" json:"from,omitempty"`

	// To Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	To *ApiParamsPredicateFilterTime `form:"to,omitempty" json:"to,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityParams defines parameters for GetDomainEntity.
type GetDomainEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateDomainEntityJSONBody defines parameters for UpdateDomainEntity.
type UpdateDomainEntityJSONBody struct {
	Collected *bool `json:"collected,omitempty"`
}

// UpdateDomainEntityParams defines parameters for UpdateDomainEntity.
type UpdateDomainEntityParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityComputersParams defines parameters for GetDomainEntityComputers.
type GetDomainEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityComputersParamsType defines parameters for GetDomainEntityComputers.
type GetDomainEntityComputersParamsType string

// GetDomainEntityControllersParams defines parameters for GetDomainEntityControllers.
type GetDomainEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityControllersParamsType defines parameters for GetDomainEntityControllers.
type GetDomainEntityControllersParamsType string

// GetDomainEntityDcSyncersParams defines parameters for GetDomainEntityDcSyncers.
type GetDomainEntityDcSyncersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityDcSyncersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityDcSyncersParamsType defines parameters for GetDomainEntityDcSyncers.
type GetDomainEntityDcSyncersParamsType string

// GetDomainEntityForeignAdminsParams defines parameters for GetDomainEntityForeignAdmins.
type GetDomainEntityForeignAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignAdminsParamsType defines parameters for GetDomainEntityForeignAdmins.
type GetDomainEntityForeignAdminsParamsType string

// GetDomainEntityForeignGpoControllersParams defines parameters for GetDomainEntityForeignGpoControllers.
type GetDomainEntityForeignGpoControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignGpoControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignGpoControllersParamsType defines parameters for GetDomainEntityForeignGpoControllers.
type GetDomainEntityForeignGpoControllersParamsType string

// GetDomainEntityForeignGroupsParams defines parameters for GetDomainEntityForeignGroups.
type GetDomainEntityForeignGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignGroupsParamsType defines parameters for GetDomainEntityForeignGroups.
type GetDomainEntityForeignGroupsParamsType string

// GetDomainEntityForeignUsersParams defines parameters for GetDomainEntityForeignUsers.
type GetDomainEntityForeignUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignUsersParamsType defines parameters for GetDomainEntityForeignUsers.
type GetDomainEntityForeignUsersParamsType string

// GetDomainEntityGposParams defines parameters for GetDomainEntityGpos.
type GetDomainEntityGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityGposParamsType defines parameters for GetDomainEntityGpos.
type GetDomainEntityGposParamsType string

// GetDomainEntityGroupsParams defines parameters for GetDomainEntityGroups.
type GetDomainEntityGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityGroupsParamsType defines parameters for GetDomainEntityGroups.
type GetDomainEntityGroupsParamsType string

// GetDomainEntityInboundTrustsParams defines parameters for GetDomainEntityInboundTrusts.
type GetDomainEntityInboundTrustsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityInboundTrustsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityInboundTrustsParamsType defines parameters for GetDomainEntityInboundTrusts.
type GetDomainEntityInboundTrustsParamsType string

// GetDomainEntityLinkedGposParams defines parameters for GetDomainEntityLinkedGpos.
type GetDomainEntityLinkedGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityLinkedGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityLinkedGposParamsType defines parameters for GetDomainEntityLinkedGpos.
type GetDomainEntityLinkedGposParamsType string

// GetDomainEntityOusParams defines parameters for GetDomainEntityOus.
type GetDomainEntityOusParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityOusParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityOusParamsType defines parameters for GetDomainEntityOus.
type GetDomainEntityOusParamsType string

// GetDomainEntityOutboundTrustsParams defines parameters for GetDomainEntityOutboundTrusts.
type GetDomainEntityOutboundTrustsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityOutboundTrustsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityOutboundTrustsParamsType defines parameters for GetDomainEntityOutboundTrusts.
type GetDomainEntityOutboundTrustsParamsType string

// GetDomainEntityUsersParams defines parameters for GetDomainEntityUsers.
type GetDomainEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityUsersParamsType defines parameters for GetDomainEntityUsers.
type GetDomainEntityUsersParamsType string

// GetEnterpriseCaEntityParams defines parameters for GetEnterpriseCaEntity.
type GetEnterpriseCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEnterpriseCaEntityControllersParams defines parameters for GetEnterpriseCaEntityControllers.
type GetEnterpriseCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEnterpriseCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEnterpriseCaEntityControllersParamsType defines parameters for GetEnterpriseCaEntityControllers.
type GetEnterpriseCaEntityControllersParamsType string

// ListClientSchedulesParams defines parameters for ListClientSchedules.
type ListClientSchedulesParams struct {
	// SortBy Sortable columns are `next_scheduled_at`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	Rrule                  *ApiParamsPredicateFilterString        `form:"rrule,omitempty" json:"rrule,omitempty"`
	NextScheduledAt        *ApiParamsPredicateFilterTime          `form:"next_scheduled_at,omitempty" json:"next_scheduled_at,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduleParams defines parameters for CreateClientSchedule.
type CreateClientScheduleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteClientEventParams defines parameters for DeleteClientEvent.
type DeleteClientEventParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientScheduleParams defines parameters for GetClientSchedule.
type GetClientScheduleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientEventParams defines parameters for UpdateClientEvent.
type UpdateClientEventParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListFeatureFlagsParams defines parameters for ListFeatureFlags.
type ListFeatureFlagsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ToggleFeatureFlagParams defines parameters for ToggleFeatureFlag.
type ToggleFeatureFlagParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListFileUploadJobsParams defines parameters for ListFileUploadJobs.
type ListFileUploadJobsParams struct {
	// SortBy Sortable columns are `user_email_address`, `status`, `status_message`, `start_time`, `end_time`, `last_ingest`, `id`, `created_at`, `updated_at`, and `deleted_at`.
	SortBy           *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	UserId           *ApiParamsPredicateFilterString  `form:"user_id,omitempty" json:"user_id,omitempty"`
	UserEmailAddress *ApiParamsPredicateFilterString  `form:"user_email_address,omitempty" json:"user_email_address,omitempty"`
	Status           *ApiParamsPredicateFilterInteger `form:"status,omitempty" json:"status,omitempty"`
	StatusMessage    *ApiParamsPredicateFilterString  `form:"status_message,omitempty" json:"status_message,omitempty"`
	StartTime        *ApiParamsPredicateFilterTime    `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime          *ApiParamsPredicateFilterTime    `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest       *ApiParamsPredicateFilterTime    `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`
	Id               *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAcceptedFileUploadTypesParams defines parameters for ListAcceptedFileUploadTypes.
type ListAcceptedFileUploadTypesParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateFileUploadJobParams defines parameters for CreateFileUploadJob.
type CreateFileUploadJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UploadFileToJobJSONBody defines parameters for UploadFileToJob.
type UploadFileToJobJSONBody = map[string]interface{}

// UploadFileToJobParams defines parameters for UploadFileToJob.
type UploadFileToJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`

	// ContentType Content type header, used to specify the type of content being sent by the client.
	ContentType string `json:"Content-Type"`
}

// EndFileUploadJobParams defines parameters for EndFileUploadJob.
type EndFileUploadJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityParams defines parameters for GetGpoEntity.
type GetGpoEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityComputersParams defines parameters for GetGpoEntityComputers.
type GetGpoEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityComputersParamsType defines parameters for GetGpoEntityComputers.
type GetGpoEntityComputersParamsType string

// GetGpoEntityControllersParams defines parameters for GetGpoEntityControllers.
type GetGpoEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityControllersParamsType defines parameters for GetGpoEntityControllers.
type GetGpoEntityControllersParamsType string

// GetGpoEntityOusParams defines parameters for GetGpoEntityOus.
type GetGpoEntityOusParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityOusParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityOusParamsType defines parameters for GetGpoEntityOus.
type GetGpoEntityOusParamsType string

// GetGpoEntityTierZeroParams defines parameters for GetGpoEntityTierZero.
type GetGpoEntityTierZeroParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityTierZeroParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityTierZeroParamsType defines parameters for GetGpoEntityTierZero.
type GetGpoEntityTierZeroParamsType string

// GetGpoEntityUsersParams defines parameters for GetGpoEntityUsers.
type GetGpoEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityUsersParamsType defines parameters for GetGpoEntityUsers.
type GetGpoEntityUsersParamsType string

// GetSearchResultParams defines parameters for GetSearchResult.
type GetSearchResultParams struct {
	// SearchQuery Search query
	SearchQuery string `form:"search_query" json:"search_query"`

	// Type The type of search strategy to use. Default is `fuzzy`.
	Type *GetSearchResultParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSearchResultParamsType defines parameters for GetSearchResult.
type GetSearchResultParamsType string

// RunCypherQueryJSONBody defines parameters for RunCypherQuery.
type RunCypherQueryJSONBody struct {
	IncludeProperties *bool   `json:"include_properties,omitempty"`
	Query             *string `json:"query,omitempty"`
}

// RunCypherQueryParams defines parameters for RunCypherQuery.
type RunCypherQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPathCompositionParams defines parameters for GetPathComposition.
type GetPathCompositionParams struct {
	// SourceNode The ID of the starting node.
	SourceNode int32 `form:"source_node" json:"source_node"`

	// TargetNode The ID of the ending node.
	TargetNode int32 `form:"target_node" json:"target_node"`

	// EdgeType The type of edge to show the composition for.
	EdgeType string `form:"edge_type" json:"edge_type"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetShortestPathParams defines parameters for GetShortestPath.
type GetShortestPathParams struct {
	// StartNode The start node objectId
	StartNode int32 `form:"start_node" json:"start_node"`

	// EndNode The end node objectId
	EndNode           int32                             `form:"end_node" json:"end_node"`
	RelationshipKinds *ApiParamsPredicateFilterContains `form:"relationship_kinds,omitempty" json:"relationship_kinds,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityParams defines parameters for GetGroupEntity.
type GetGroupEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityAdminRightsParams defines parameters for GetGroupEntityAdminRights.
type GetGroupEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityAdminRightsParamsType defines parameters for GetGroupEntityAdminRights.
type GetGroupEntityAdminRightsParamsType string

// GetGroupEntityControllablesParams defines parameters for GetGroupEntityControllables.
type GetGroupEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityControllablesParamsType defines parameters for GetGroupEntityControllables.
type GetGroupEntityControllablesParamsType string

// GetGroupEntityControllersParams defines parameters for GetGroupEntityControllers.
type GetGroupEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityControllersParamsType defines parameters for GetGroupEntityControllers.
type GetGroupEntityControllersParamsType string

// GetGroupEntityDcomRightsParams defines parameters for GetGroupEntityDcomRights.
type GetGroupEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityDcomRightsParamsType defines parameters for GetGroupEntityDcomRights.
type GetGroupEntityDcomRightsParamsType string

// GetGroupEntityMembersParams defines parameters for GetGroupEntityMembers.
type GetGroupEntityMembersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityMembersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityMembersParamsType defines parameters for GetGroupEntityMembers.
type GetGroupEntityMembersParamsType string

// GetGroupEntityMembershipsParams defines parameters for GetGroupEntityMemberships.
type GetGroupEntityMembershipsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityMembershipsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityMembershipsParamsType defines parameters for GetGroupEntityMemberships.
type GetGroupEntityMembershipsParamsType string

// GetGroupEntityPsRemoteRightsParams defines parameters for GetGroupEntityPsRemoteRights.
type GetGroupEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityPsRemoteRightsParamsType defines parameters for GetGroupEntityPsRemoteRights.
type GetGroupEntityPsRemoteRightsParamsType string

// GetGroupEntityRdpRightsParams defines parameters for GetGroupEntityRdpRights.
type GetGroupEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityRdpRightsParamsType defines parameters for GetGroupEntityRdpRights.
type GetGroupEntityRdpRightsParamsType string

// GetGroupEntitySessionsParams defines parameters for GetGroupEntitySessions.
type GetGroupEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntitySessionsParamsType defines parameters for GetGroupEntitySessions.
type GetGroupEntitySessionsParamsType string

// IngestDataParams defines parameters for IngestData.
type IngestDataParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobsParams defines parameters for GetClientJobs.
type GetClientJobsParams struct {
	// SortBy Sortable columns are `client_name`, `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAvailableClientJobsParams defines parameters for ListAvailableClientJobs.
type ListAvailableClientJobsParams struct {
	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, and `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientCurrentJobParams defines parameters for GetClientCurrentJob.
type GetClientCurrentJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// EndClientJobParams defines parameters for EndClientJob.
type EndClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientFinishedJobsParams defines parameters for ListClientFinishedJobs.
type ListClientFinishedJobsParams struct {
	// SortBy Sortable columns are `client_name`, `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// StartClientJobJSONBody defines parameters for StartClientJob.
type StartClientJobJSONBody struct {
	Id *int64 `json:"id,omitempty"`
}

// StartClientJobParams defines parameters for StartClientJob.
type StartClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobParams defines parameters for GetClientJob.
type GetClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CancelClientJobParams defines parameters for CancelClientJob.
type CancelClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobLogParams defines parameters for GetClientJobLog.
type GetClientJobLogParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	// LoginMethod The type of login. Currently only `secret` is supported.
	LoginMethod LoginJSONBodyLoginMethod `json:"login_method"`

	// Otp The One Time Password for a single login. This field can be used instead of `secret`
	Otp *string `json:"otp,omitempty"`

	// Secret The password for the user. This field can be used instead of `otp`.
	Secret   *string `json:"secret,omitempty"`
	Username string  `json:"username"`
}

// LoginParams defines parameters for Login.
type LoginParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LoginJSONBodyLoginMethod defines parameters for Login.
type LoginJSONBodyLoginMethod string

// LogoutParams defines parameters for Logout.
type LogoutParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetLatestTierZeroComboNodeParams defines parameters for GetLatestTierZeroComboNode.
type GetLatestTierZeroComboNodeParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComboTreeGraphParams defines parameters for GetComboTreeGraph.
type GetComboTreeGraphParams struct {
	// NodeId Node ID
	NodeId *int64 `form:"node_id,omitempty" json:"node_id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetMetaEntityParams defines parameters for GetMetaEntity.
type GetMetaEntityParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityParams defines parameters for GetNtAuthStoreEntity.
type GetNtAuthStoreEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityControllersParams defines parameters for GetNtAuthStoreEntityControllers.
type GetNtAuthStoreEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetNtAuthStoreEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityControllersParamsType defines parameters for GetNtAuthStoreEntityControllers.
type GetNtAuthStoreEntityControllersParamsType string

// GetOuEntityParams defines parameters for GetOuEntity.
type GetOuEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityComputersParams defines parameters for GetOuEntityComputers.
type GetOuEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityComputersParamsType defines parameters for GetOuEntityComputers.
type GetOuEntityComputersParamsType string

// GetOuEntityGposParams defines parameters for GetOuEntityGpos.
type GetOuEntityGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityGposParamsType defines parameters for GetOuEntityGpos.
type GetOuEntityGposParamsType string

// GetOuEntityGroupsParams defines parameters for GetOuEntityGroups.
type GetOuEntityGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityGroupsParamsType defines parameters for GetOuEntityGroups.
type GetOuEntityGroupsParamsType string

// GetOuEntityUsersParams defines parameters for GetOuEntityUsers.
type GetOuEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityUsersParamsType defines parameters for GetOuEntityUsers.
type GetOuEntityUsersParamsType string

// PathfindingParams defines parameters for Pathfinding.
type PathfindingParams struct {
	// StartNode Start Node
	StartNode string `form:"start_node" json:"start_node"`

	// EndNode End Node
	EndNode string `form:"end_node" json:"end_node"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListPermissionsParams defines parameters for ListPermissions.
type ListPermissionsParams struct {
	// SortBy Sortable columns are `authority`, `name`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy    *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Authority *ApiParamsPredicateFilterString  `form:"authority,omitempty" json:"authority,omitempty"`
	Name      *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Id        *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPermissionParams defines parameters for GetPermission.
type GetPermissionParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPlatformDataQualityAggregateParams defines parameters for GetPlatformDataQualityAggregate.
type GetPlatformDataQualityAggregateParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPostureStatsParams defines parameters for GetPostureStats.
type GetPostureStatsParams struct {
	// SortBy Sortable columns are `domain_sid`, `exposure_index`, `tier_zero_count`, `critical_risk_count`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// FromDeprecated Lower bound for created_at; to return posture stats starting at a specific date/time
	FromDeprecated *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// ToDeprecated Upper bound for created_at; to return posture stats upto a specific date/time
	ToDeprecated      *time.Time                       `form:"to,omitempty" json:"to,omitempty"`
	DomainSid         *ApiParamsPredicateFilterString  `form:"domain_sid,omitempty" json:"domain_sid,omitempty"`
	ExposureIndex     *ApiParamsPredicateFilterInteger `form:"exposure_index,omitempty" json:"exposure_index,omitempty"`
	TierZeroCount     *ApiParamsPredicateFilterInteger `form:"tier_zero_count,omitempty" json:"tier_zero_count,omitempty"`
	CriticalRiskCount *ApiParamsPredicateFilterInteger `form:"critical_risk_count,omitempty" json:"critical_risk_count,omitempty"`
	Id                *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {
	// SortBy Sortable columns are `name`, `description`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name   *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Id     *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRoleParams defines parameters for GetRole.
type GetRoleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityParams defines parameters for GetRootCaEntity.
type GetRootCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityControllersParams defines parameters for GetRootCaEntityControllers.
type GetRootCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetRootCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityControllersParamsType defines parameters for GetRootCaEntityControllers.
type GetRootCaEntityControllersParamsType string

// ListSamlProvidersParams defines parameters for ListSamlProviders.
type ListSamlProvidersParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateSamlProviderMultipartBody defines parameters for CreateSamlProvider.
type CreateSamlProviderMultipartBody struct {
	// Metadata Metadata XML file.
	Metadata *openapi_types.File `json:"metadata,omitempty"`

	// Name Name of the new SAML provider.
	Name *string `json:"name,omitempty"`
}

// DeleteSamlProviderParams defines parameters for DeleteSamlProvider.
type DeleteSamlProviderParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSamlProviderParams defines parameters for GetSamlProvider.
type GetSamlProviderParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSamlSignSignOnEndpointsParams defines parameters for GetSamlSignSignOnEndpoints.
type GetSamlSignSignOnEndpointsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListSavedQueriesParams defines parameters for ListSavedQueries.
type ListSavedQueriesParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are user_id, name, query, id, created_at, updated_at, deleted_at.
	SortBy *ApiParamsQuerySortBy             `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name   *ApiParamsPredicateFilterString   `form:"name,omitempty" json:"name,omitempty"`
	Query  *ApiParamsPredicateFilterString   `form:"query,omitempty" json:"query,omitempty"`
	UserId *ApiParamsPredicateFilterString   `form:"user_id,omitempty" json:"user_id,omitempty"`
	Scope  *ApiParamsPredicateFilterContains `form:"scope,omitempty" json:"scope,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateSavedQueryParams defines parameters for CreateSavedQuery.
type CreateSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteSavedQueryParams defines parameters for DeleteSavedQuery.
type DeleteSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateSavedQueryParams defines parameters for UpdateSavedQuery.
type UpdateSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteSavedQueryPermissionsJSONBody defines parameters for DeleteSavedQueryPermissions.
type DeleteSavedQueryPermissionsJSONBody struct {
	// UserIds A list of user ids that will have their permission revoked from the given saved query
	UserIds *[]openapi_types.UUID `json:"user_ids,omitempty"`
}

// DeleteSavedQueryPermissionsParams defines parameters for DeleteSavedQueryPermissions.
type DeleteSavedQueryPermissionsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ShareSavedQueryJSONBody defines parameters for ShareSavedQuery.
type ShareSavedQueryJSONBody struct {
	Public  *bool                 `json:"public,omitempty"`
	UserIds *[]openapi_types.UUID `json:"user_ids,omitempty"`
}

// ShareSavedQueryParams defines parameters for ShareSavedQuery.
type ShareSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Q Search parameter for the name or object ID of a node.
	Q string `form:"q" json:"q"`

	// Type Node type.
	// Some AD examples: `Base`, `User`, `Computer`, `Group`, `Container`.
	// Some Azure examples: `AZBase`, `AZApp`, `AZDevice`.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSelfParams defines parameters for GetSelf.
type GetSelfParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetApiSpecParams defines parameters for GetApiSpec.
type GetApiSpecParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAuthTokensParams defines parameters for ListAuthTokens.
type ListAuthTokensParams struct {
	// UserId Provide a user id to filter tokens by. This filter is only honored for Admin users.
	UserId *ApiParamsPredicateFilterUuid `form:"user_id,omitempty" json:"user_id,omitempty"`

	// SortBy Sortable columns are `user_id`, `client_id`, `name`, `last_access`, `created_at`, `updated_at`, `deleted_at`.
	SortBy     *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name       *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	Key        *ApiParamsPredicateFilterString `form:"key,omitempty" json:"key,omitempty"`
	HmacMethod *ApiParamsPredicateFilterString `form:"hmac_method,omitempty" json:"hmac_method,omitempty"`
	LastAccess *ApiParamsPredicateFilterTime   `form:"last_access,omitempty" json:"last_access,omitempty"`
	Id         *ApiParamsPredicateFilterUuid   `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAuthTokenJSONBody defines parameters for CreateAuthToken.
type CreateAuthTokenJSONBody struct {
	TokenName *string             `json:"token_name,omitempty"`
	UserId    *openapi_types.UUID `json:"user_id,omitempty"`
}

// CreateAuthTokenParams defines parameters for CreateAuthToken.
type CreateAuthTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAuthTokenParams defines parameters for DeleteAuthToken.
type DeleteAuthTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityParams defines parameters for GetUserEntity.
type GetUserEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityAdminRightsParams defines parameters for GetUserEntityAdminRights.
type GetUserEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityAdminRightsParamsType defines parameters for GetUserEntityAdminRights.
type GetUserEntityAdminRightsParamsType string

// GetUserEntityConstrainedDelegationRightsParams defines parameters for GetUserEntityConstrainedDelegationRights.
type GetUserEntityConstrainedDelegationRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityConstrainedDelegationRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityConstrainedDelegationRightsParamsType defines parameters for GetUserEntityConstrainedDelegationRights.
type GetUserEntityConstrainedDelegationRightsParamsType string

// GetUserEntityControllablesParams defines parameters for GetUserEntityControllables.
type GetUserEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityControllablesParamsType defines parameters for GetUserEntityControllables.
type GetUserEntityControllablesParamsType string

// GetUserEntityControllersParams defines parameters for GetUserEntityControllers.
type GetUserEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityControllersParamsType defines parameters for GetUserEntityControllers.
type GetUserEntityControllersParamsType string

// GetUserEntityDcomRightsParams defines parameters for GetUserEntityDcomRights.
type GetUserEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityDcomRightsParamsType defines parameters for GetUserEntityDcomRights.
type GetUserEntityDcomRightsParamsType string

// GetUserEntityMembershipParams defines parameters for GetUserEntityMembership.
type GetUserEntityMembershipParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityMembershipParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityMembershipParamsType defines parameters for GetUserEntityMembership.
type GetUserEntityMembershipParamsType string

// GetUserEntityPsRemoteRightsParams defines parameters for GetUserEntityPsRemoteRights.
type GetUserEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityPsRemoteRightsParamsType defines parameters for GetUserEntityPsRemoteRights.
type GetUserEntityPsRemoteRightsParamsType string

// GetUserEntityRdpRightsParams defines parameters for GetUserEntityRdpRights.
type GetUserEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityRdpRightsParamsType defines parameters for GetUserEntityRdpRights.
type GetUserEntityRdpRightsParamsType string

// GetUserEntitySessionsParams defines parameters for GetUserEntitySessions.
type GetUserEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntitySessionsParamsType defines parameters for GetUserEntitySessions.
type GetUserEntitySessionsParamsType string

// GetUserEntitySqlAdminRightsParams defines parameters for GetUserEntitySqlAdminRights.
type GetUserEntitySqlAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`.
	// The only supported type is `list`, but unsupported `graph` and `count` can be used.
	// An invalid type will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntitySqlAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntitySqlAdminRightsParamsType defines parameters for GetUserEntitySqlAdminRights.
type GetUserEntitySqlAdminRightsParamsType string

// GetApiVersionParams defines parameters for GetApiVersion.
type GetApiVersionParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAssetGroupJSONRequestBody defines body for CreateAssetGroup for application/json ContentType.
type CreateAssetGroupJSONRequestBody = ModelAssetGroup

// UpdateAssetGroupJSONRequestBody defines body for UpdateAssetGroup for application/json ContentType.
type UpdateAssetGroupJSONRequestBody UpdateAssetGroupJSONBody

// UpdateAssetGroupSelectorsDeprecatedJSONRequestBody defines body for UpdateAssetGroupSelectorsDeprecated for application/json ContentType.
type UpdateAssetGroupSelectorsDeprecatedJSONRequestBody = UpdateAssetGroupSelectorsDeprecatedJSONBody

// UpdateAssetGroupSelectorsJSONRequestBody defines body for UpdateAssetGroupSelectors for application/json ContentType.
type UpdateAssetGroupSelectorsJSONRequestBody = UpdateAssetGroupSelectorsJSONBody

// UpdateAttackPathRiskJSONRequestBody defines body for UpdateAttackPathRisk for application/json ContentType.
type UpdateAttackPathRiskJSONRequestBody UpdateAttackPathRiskJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = ApiRequestsUserUpdate

// RemoveUserMfaJSONRequestBody defines body for RemoveUserMfa for application/json ContentType.
type RemoveUserMfaJSONRequestBody RemoveUserMfaJSONBody

// AddUserMfaJSONRequestBody defines body for AddUserMfa for application/json ContentType.
type AddUserMfaJSONRequestBody AddUserMfaJSONBody

// ActivateUserMfaJSONRequestBody defines body for ActivateUserMfa for application/json ContentType.
type ActivateUserMfaJSONRequestBody ActivateUserMfaJSONBody

// CreateOrSetUserSecretJSONRequestBody defines body for CreateOrSetUserSecret for application/json ContentType.
type CreateOrSetUserSecretJSONRequestBody = ApiRequestsUserSetSecret

// DeleteBloodHoundDatabaseJSONRequestBody defines body for DeleteBloodHoundDatabase for application/json ContentType.
type DeleteBloodHoundDatabaseJSONRequestBody DeleteBloodHoundDatabaseJSONBody

// CreateClientJSONRequestBody defines body for CreateClient for application/json ContentType.
type CreateClientJSONRequestBody CreateClientJSONBody

// LogClientErrorJSONRequestBody defines body for LogClientError for application/json ContentType.
type LogClientErrorJSONRequestBody LogClientErrorJSONBody

// UpdateClientInfoJSONRequestBody defines body for UpdateClientInfo for application/json ContentType.
type UpdateClientInfoJSONRequestBody UpdateClientInfoJSONBody

// UpdateClientJSONRequestBody defines body for UpdateClient for application/json ContentType.
type UpdateClientJSONRequestBody UpdateClientJSONBody

// CreateClientScheduledJobJSONRequestBody defines body for CreateClientScheduledJob for application/json ContentType.
type CreateClientScheduledJobJSONRequestBody = ModelClientScheduledJob

// CreateClientScheduledTaskJSONRequestBody defines body for CreateClientScheduledTask for application/json ContentType.
type CreateClientScheduledTaskJSONRequestBody = ModelClientScheduledJob

// SetAppConfigParamJSONRequestBody defines body for SetAppConfigParam for application/json ContentType.
type SetAppConfigParamJSONRequestBody = ModelAppConfigParam

// UpdateDomainEntityJSONRequestBody defines body for UpdateDomainEntity for application/json ContentType.
type UpdateDomainEntityJSONRequestBody UpdateDomainEntityJSONBody

// CreateClientScheduleJSONRequestBody defines body for CreateClientSchedule for application/json ContentType.
type CreateClientScheduleJSONRequestBody = ModelClientSchedule

// UpdateClientEventJSONRequestBody defines body for UpdateClientEvent for application/json ContentType.
type UpdateClientEventJSONRequestBody = ModelClientSchedule

// UploadFileToJobJSONRequestBody defines body for UploadFileToJob for application/json ContentType.
type UploadFileToJobJSONRequestBody = UploadFileToJobJSONBody

// RunCypherQueryJSONRequestBody defines body for RunCypherQuery for application/json ContentType.
type RunCypherQueryJSONRequestBody RunCypherQueryJSONBody

// StartClientJobJSONRequestBody defines body for StartClientJob for application/json ContentType.
type StartClientJobJSONRequestBody StartClientJobJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreateSamlProviderMultipartRequestBody defines body for CreateSamlProvider for multipart/form-data ContentType.
type CreateSamlProviderMultipartRequestBody CreateSamlProviderMultipartBody

// CreateSavedQueryJSONRequestBody defines body for CreateSavedQuery for application/json ContentType.
type CreateSavedQueryJSONRequestBody = ModelSavedQuery

// UpdateSavedQueryJSONRequestBody defines body for UpdateSavedQuery for application/json ContentType.
type UpdateSavedQueryJSONRequestBody = ModelSavedQuery

// DeleteSavedQueryPermissionsJSONRequestBody defines body for DeleteSavedQueryPermissions for application/json ContentType.
type DeleteSavedQueryPermissionsJSONRequestBody DeleteSavedQueryPermissionsJSONBody

// ShareSavedQueryJSONRequestBody defines body for ShareSavedQuery for application/json ContentType.
type ShareSavedQueryJSONRequestBody ShareSavedQueryJSONBody

// CreateAuthTokenJSONRequestBody defines body for CreateAuthToken for application/json ContentType.
type CreateAuthTokenJSONRequestBody CreateAuthTokenJSONBody

// AsModelUser returns the union data inside the ApiResponseAuthenticatedRequester_Data as a ModelUser
func (t ApiResponseAuthenticatedRequester_Data) AsModelUser() (ModelUser, error) {
	var body ModelUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelUser overwrites any union data inside the ApiResponseAuthenticatedRequester_Data as the provided ModelUser
func (t *ApiResponseAuthenticatedRequester_Data) FromModelUser(v ModelUser) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelUser performs a merge with any union data inside the ApiResponseAuthenticatedRequester_Data, using the provided ModelUser
func (t *ApiResponseAuthenticatedRequester_Data) MergeModelUser(v ModelUser) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelClient returns the union data inside the ApiResponseAuthenticatedRequester_Data as a ModelClient
func (t ApiResponseAuthenticatedRequester_Data) AsModelClient() (ModelClient, error) {
	var body ModelClient
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelClient overwrites any union data inside the ApiResponseAuthenticatedRequester_Data as the provided ModelClient
func (t *ApiResponseAuthenticatedRequester_Data) FromModelClient(v ModelClient) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelClient performs a merge with any union data inside the ApiResponseAuthenticatedRequester_Data, using the provided ModelClient
func (t *ApiResponseAuthenticatedRequester_Data) MergeModelClient(v ModelClient) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseAuthenticatedRequester_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseAuthenticatedRequester_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelAdDataQualityAggregation returns the union data inside the ApiResponseDataQualityPlatformAggregate_Data_Item as a ModelAdDataQualityAggregation
func (t ApiResponseDataQualityPlatformAggregate_Data_Item) AsModelAdDataQualityAggregation() (ModelAdDataQualityAggregation, error) {
	var body ModelAdDataQualityAggregation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelAdDataQualityAggregation overwrites any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Item as the provided ModelAdDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Item) FromModelAdDataQualityAggregation(v ModelAdDataQualityAggregation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelAdDataQualityAggregation performs a merge with any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Item, using the provided ModelAdDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Item) MergeModelAdDataQualityAggregation(v ModelAdDataQualityAggregation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelAzureDataQualityAggregation returns the union data inside the ApiResponseDataQualityPlatformAggregate_Data_Item as a ModelAzureDataQualityAggregation
func (t ApiResponseDataQualityPlatformAggregate_Data_Item) AsModelAzureDataQualityAggregation() (ModelAzureDataQualityAggregation, error) {
	var body ModelAzureDataQualityAggregation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelAzureDataQualityAggregation overwrites any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Item as the provided ModelAzureDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Item) FromModelAzureDataQualityAggregation(v ModelAzureDataQualityAggregation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelAzureDataQualityAggregation performs a merge with any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Item, using the provided ModelAzureDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Item) MergeModelAzureDataQualityAggregation(v ModelAzureDataQualityAggregation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseDataQualityPlatformAggregate_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseDataQualityPlatformAggregate_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelListFinding returns the union data inside the ApiResponseFinding_Data as a ModelListFinding
func (t ApiResponseFinding_Data) AsModelListFinding() (ModelListFinding, error) {
	var body ModelListFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelListFinding overwrites any union data inside the ApiResponseFinding_Data as the provided ModelListFinding
func (t *ApiResponseFinding_Data) FromModelListFinding(v ModelListFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelListFinding performs a merge with any union data inside the ApiResponseFinding_Data, using the provided ModelListFinding
func (t *ApiResponseFinding_Data) MergeModelListFinding(v ModelListFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelRelationshipFinding returns the union data inside the ApiResponseFinding_Data as a ModelRelationshipFinding
func (t ApiResponseFinding_Data) AsModelRelationshipFinding() (ModelRelationshipFinding, error) {
	var body ModelRelationshipFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelRelationshipFinding overwrites any union data inside the ApiResponseFinding_Data as the provided ModelRelationshipFinding
func (t *ApiResponseFinding_Data) FromModelRelationshipFinding(v ModelRelationshipFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelRelationshipFinding performs a merge with any union data inside the ApiResponseFinding_Data, using the provided ModelRelationshipFinding
func (t *ApiResponseFinding_Data) MergeModelRelationshipFinding(v ModelRelationshipFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseFinding_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseFinding_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelBhGraphNode returns the union data inside the ModelBhGraphGraph_AdditionalProperties as a ModelBhGraphNode
func (t ModelBhGraphGraph_AdditionalProperties) AsModelBhGraphNode() (ModelBhGraphNode, error) {
	var body ModelBhGraphNode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelBhGraphNode overwrites any union data inside the ModelBhGraphGraph_AdditionalProperties as the provided ModelBhGraphNode
func (t *ModelBhGraphGraph_AdditionalProperties) FromModelBhGraphNode(v ModelBhGraphNode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelBhGraphNode performs a merge with any union data inside the ModelBhGraphGraph_AdditionalProperties, using the provided ModelBhGraphNode
func (t *ModelBhGraphGraph_AdditionalProperties) MergeModelBhGraphNode(v ModelBhGraphNode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelBhGraphEdge returns the union data inside the ModelBhGraphGraph_AdditionalProperties as a ModelBhGraphEdge
func (t ModelBhGraphGraph_AdditionalProperties) AsModelBhGraphEdge() (ModelBhGraphEdge, error) {
	var body ModelBhGraphEdge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelBhGraphEdge overwrites any union data inside the ModelBhGraphGraph_AdditionalProperties as the provided ModelBhGraphEdge
func (t *ModelBhGraphGraph_AdditionalProperties) FromModelBhGraphEdge(v ModelBhGraphEdge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelBhGraphEdge performs a merge with any union data inside the ModelBhGraphGraph_AdditionalProperties, using the provided ModelBhGraphEdge
func (t *ModelBhGraphGraph_AdditionalProperties) MergeModelBhGraphEdge(v ModelBhGraphEdge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModelBhGraphGraph_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModelBhGraphGraph_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AcceptEula request
	AcceptEula(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdDomainDataQualityStats request
	GetAdDomainDataQualityStats(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiaCaEntity request
	GetAiaCaEntity(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiaCaEntityControllers request
	GetAiaCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartAnalysis request
	StartAnalysis(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroups request
	ListAssetGroups(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssetGroupWithBody request with any body
	CreateAssetGroupWithBody(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAssetGroup(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetGroup request
	DeleteAssetGroup(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroup request
	GetAssetGroup(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupWithBody request with any body
	UpdateAssetGroupWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroup(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupCollections request
	ListAssetGroupCollections(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroupComboNode request
	GetAssetGroupComboNode(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroupCustomMemberCount request
	GetAssetGroupCustomMemberCount(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupMembers request
	ListAssetGroupMembers(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupMemberCountByKind request
	ListAssetGroupMemberCountByKind(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupSelectorsDeprecatedWithBody request with any body
	UpdateAssetGroupSelectorsDeprecatedWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroupSelectorsDeprecated(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupSelectorsWithBody request with any body
	UpdateAssetGroupSelectorsWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroupSelectors(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetGroupSelector request
	DeleteAssetGroupSelector(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttackPathTypes request
	ListAttackPathTypes(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartAnalysisBhe request
	StartAnalysisBhe(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttackPathRiskWithBody request with any body
	UpdateAttackPathRiskWithBody(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttackPathRisk(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableDomains request
	GetAvailableDomains(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAzureTenantDataQualityStats request
	GetAzureTenantDataQualityStats(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAzureEntity request
	GetAzureEntity(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntity request
	GetEntity(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntityControllables request
	GetEntityControllables(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntityControllers request
	GetEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserMfaWithBody request with any body
	RemoveUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveUserMfa(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserMfaWithBody request with any body
	AddUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserMfa(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMfaActivationStatus request
	GetMfaActivationStatus(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateUserMfaWithBody request with any body
	ActivateUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateUserMfa(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserSecret request
	DeleteUserSecret(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrSetUserSecretWithBody request with any body
	CreateOrSetUserSecretWithBody(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrSetUserSecret(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertTemplateEntity request
	GetCertTemplateEntity(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertTemplateEntityControllers request
	GetCertTemplateEntityControllers(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBloodHoundDatabaseWithBody request with any body
	DeleteBloodHoundDatabaseWithBody(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteBloodHoundDatabase(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClients request
	ListClients(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientWithBody request with any body
	CreateClientWithBody(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClient(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogClientErrorWithBody request with any body
	LogClientErrorWithBody(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogClientError(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientInfoWithBody request with any body
	UpdateClientInfoWithBody(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClientInfo(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClient request
	DeleteClient(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClient request
	GetClient(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientWithBody request with any body
	UpdateClientWithBody(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClient(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientCompletedJobs request
	ListClientCompletedJobs(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientCompletedTasks request
	ListClientCompletedTasks(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduledJobWithBody request with any body
	CreateClientScheduledJobWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientScheduledJob(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduledTaskWithBody request with any body
	CreateClientScheduledTaskWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientScheduledTask(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceClientToken request
	ReplaceClientToken(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorManifest request
	GetCollectorManifest(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadCollector request
	DownloadCollector(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorChecksum request
	GetCollectorChecksum(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletenessStats request
	GetCompletenessStats(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntity request
	GetComputerEntity(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityAdminRights request
	GetComputerEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityAdmins request
	GetComputerEntityAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityConstrainedDelegationRights request
	GetComputerEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityConstrainedUsers request
	GetComputerEntityConstrainedUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityControllables request
	GetComputerEntityControllables(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityControllers request
	GetComputerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityDcomRights request
	GetComputerEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityDcomUsers request
	GetComputerEntityDcomUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityGroupMembership request
	GetComputerEntityGroupMembership(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityPsRemoteRights request
	GetComputerEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityPsRemoteUsers request
	GetComputerEntityPsRemoteUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityRdpRights request
	GetComputerEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityRdpUsers request
	GetComputerEntityRdpUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntitySessions request
	GetComputerEntitySessions(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntitySqlAdmins request
	GetComputerEntitySqlAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppConfigParams request
	ListAppConfigParams(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAppConfigParamWithBody request with any body
	SetAppConfigParamWithBody(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAppConfigParam(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerEntity request
	GetContainerEntity(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerEntityControllers request
	GetContainerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatapipeStatus request
	GetDatapipeStatus(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportAttackPathFindings request
	ExportAttackPathFindings(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableAttackPathTypesForDomain request
	ListAvailableAttackPathTypesForDomain(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDomainAttackPathsDetails request
	ListDomainAttackPathsDetails(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttackPathSparklineValues request
	ListAttackPathSparklineValues(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntity request
	GetDomainEntity(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDomainEntityWithBody request with any body
	UpdateDomainEntityWithBody(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDomainEntity(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityComputers request
	GetDomainEntityComputers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityControllers request
	GetDomainEntityControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityDcSyncers request
	GetDomainEntityDcSyncers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignAdmins request
	GetDomainEntityForeignAdmins(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignGpoControllers request
	GetDomainEntityForeignGpoControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignGroups request
	GetDomainEntityForeignGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignUsers request
	GetDomainEntityForeignUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityGpos request
	GetDomainEntityGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityGroups request
	GetDomainEntityGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityInboundTrusts request
	GetDomainEntityInboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityLinkedGpos request
	GetDomainEntityLinkedGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityOus request
	GetDomainEntityOus(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityOutboundTrusts request
	GetDomainEntityOutboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityUsers request
	GetDomainEntityUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnterpriseCaEntity request
	GetEnterpriseCaEntity(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnterpriseCaEntityControllers request
	GetEnterpriseCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientSchedules request
	ListClientSchedules(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduleWithBody request with any body
	CreateClientScheduleWithBody(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientSchedule(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientEvent request
	DeleteClientEvent(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientSchedule request
	GetClientSchedule(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientEventWithBody request with any body
	UpdateClientEventWithBody(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClientEvent(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFeatureFlags request
	ListFeatureFlags(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleFeatureFlag request
	ToggleFeatureFlag(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFileUploadJobs request
	ListFileUploadJobs(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAcceptedFileUploadTypes request
	ListAcceptedFileUploadTypes(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFileUploadJob request
	CreateFileUploadJob(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFileToJobWithBody request with any body
	UploadFileToJobWithBody(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadFileToJob(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndFileUploadJob request
	EndFileUploadJob(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntity request
	GetGpoEntity(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityComputers request
	GetGpoEntityComputers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityControllers request
	GetGpoEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityOus request
	GetGpoEntityOus(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityTierZero request
	GetGpoEntityTierZero(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityUsers request
	GetGpoEntityUsers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResult request
	GetSearchResult(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunCypherQueryWithBody request with any body
	RunCypherQueryWithBody(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunCypherQuery(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPathComposition request
	GetPathComposition(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShortestPath request
	GetShortestPath(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntity request
	GetGroupEntity(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityAdminRights request
	GetGroupEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityControllables request
	GetGroupEntityControllables(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityControllers request
	GetGroupEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityDcomRights request
	GetGroupEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityMembers request
	GetGroupEntityMembers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityMemberships request
	GetGroupEntityMemberships(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityPsRemoteRights request
	GetGroupEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityRdpRights request
	GetGroupEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntitySessions request
	GetGroupEntitySessions(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IngestData request
	IngestData(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJobs request
	GetClientJobs(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableClientJobs request
	ListAvailableClientJobs(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientCurrentJob request
	GetClientCurrentJob(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndClientJob request
	EndClientJob(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientFinishedJobs request
	ListClientFinishedJobs(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartClientJobWithBody request with any body
	StartClientJobWithBody(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartClientJob(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJob request
	GetClientJob(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelClientJob request
	CancelClientJob(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJobLog request
	GetClientJobLog(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestTierZeroComboNode request
	GetLatestTierZeroComboNode(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComboTreeGraph request
	GetComboTreeGraph(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetaEntity request
	GetMetaEntity(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNtAuthStoreEntity request
	GetNtAuthStoreEntity(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNtAuthStoreEntityControllers request
	GetNtAuthStoreEntityControllers(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntity request
	GetOuEntity(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityComputers request
	GetOuEntityComputers(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityGpos request
	GetOuEntityGpos(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityGroups request
	GetOuEntityGroups(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityUsers request
	GetOuEntityUsers(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pathfinding request
	Pathfinding(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissions request
	ListPermissions(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermission request
	GetPermission(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformDataQualityAggregate request
	GetPlatformDataQualityAggregate(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostureStats request
	GetPostureStats(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootCaEntity request
	GetRootCaEntity(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootCaEntityControllers request
	GetRootCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSamlProviders request
	ListSamlProviders(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSamlProviderWithBody request with any body
	CreateSamlProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSamlProvider request
	DeleteSamlProvider(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlProvider request
	GetSamlProvider(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlSignSignOnEndpoints request
	GetSamlSignSignOnEndpoints(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSavedQueries request
	ListSavedQueries(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSavedQueryWithBody request with any body
	CreateSavedQueryWithBody(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSavedQuery(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSavedQuery request
	DeleteSavedQuery(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSavedQueryWithBody request with any body
	UpdateSavedQueryWithBody(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSavedQuery(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSavedQueryPermissionsWithBody request with any body
	DeleteSavedQueryPermissionsWithBody(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSavedQueryPermissions(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShareSavedQueryWithBody request with any body
	ShareSavedQueryWithBody(ctx context.Context, savedQueryId int32, params *ShareSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShareSavedQuery(ctx context.Context, savedQueryId int32, params *ShareSavedQueryParams, body ShareSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelf request
	GetSelf(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiSpec request
	GetApiSpec(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuthTokens request
	ListAuthTokens(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthTokenWithBody request with any body
	CreateAuthTokenWithBody(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuthToken(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthToken request
	DeleteAuthToken(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntity request
	GetUserEntity(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityAdminRights request
	GetUserEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityConstrainedDelegationRights request
	GetUserEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityControllables request
	GetUserEntityControllables(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityControllers request
	GetUserEntityControllers(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityDcomRights request
	GetUserEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityMembership request
	GetUserEntityMembership(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityPsRemoteRights request
	GetUserEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityRdpRights request
	GetUserEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntitySessions request
	GetUserEntitySessions(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntitySqlAdminRights request
	GetUserEntitySqlAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiVersion request
	GetApiVersion(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AcceptEula(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEulaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdDomainDataQualityStats(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdDomainDataQualityStatsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiaCaEntity(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiaCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiaCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiaCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartAnalysis(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartAnalysisRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroups(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssetGroupWithBody(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssetGroup(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetGroup(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetGroupRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroup(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroup(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupCollections(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupCollectionsRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroupComboNode(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupComboNodeRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroupCustomMemberCount(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupCustomMemberCountRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupMembers(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupMembersRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupMemberCountByKind(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupMemberCountByKindRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsDeprecatedWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsDeprecated(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsDeprecatedRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectors(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetGroupSelector(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetGroupSelectorRequest(c.Server, assetGroupId, assetGroupSelectorId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttackPathTypes(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttackPathTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartAnalysisBhe(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartAnalysisBheRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttackPathRiskWithBody(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttackPathRiskRequestWithBody(c.Server, attackPathId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttackPathRisk(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttackPathRiskRequest(c.Server, attackPathId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableDomains(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAzureTenantDataQualityStats(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAzureTenantDataQualityStatsRequest(c.Server, tenantId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAzureEntity(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAzureEntityRequest(c.Server, entityType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntity(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntityControllables(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserMfa(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserMfa(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMfaActivationStatus(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMfaActivationStatusRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateUserMfa(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserSecret(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserSecretRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrSetUserSecretWithBody(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrSetUserSecretRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrSetUserSecret(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrSetUserSecretRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertTemplateEntity(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertTemplateEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertTemplateEntityControllers(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertTemplateEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBloodHoundDatabaseWithBody(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBloodHoundDatabaseRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBloodHoundDatabase(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBloodHoundDatabaseRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClients(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientWithBody(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClient(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogClientErrorWithBody(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogClientErrorRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogClientError(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogClientErrorRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientInfoWithBody(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientInfoRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientInfo(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientInfoRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClient(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClient(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientWithBody(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClient(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientCompletedJobs(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientCompletedJobsRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientCompletedTasks(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientCompletedTasksRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledJobWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledJobRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledJob(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledJobRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledTaskWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledTaskRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledTask(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledTaskRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceClientToken(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceClientTokenRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorManifest(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorManifestRequest(c.Server, collectorType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadCollector(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadCollectorRequest(c.Server, collectorType, releaseTag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorChecksum(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorChecksumRequest(c.Server, collectorType, releaseTag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletenessStats(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletenessStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntity(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityConstrainedDelegationRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityConstrainedUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityConstrainedUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityControllables(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityDcomUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityDcomUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityGroupMembership(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityGroupMembershipRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityPsRemoteUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityPsRemoteUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityRdpUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRdpUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntitySessions(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntitySqlAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntitySqlAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppConfigParams(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppConfigParamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppConfigParamWithBody(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppConfigParamRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppConfigParam(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppConfigParamRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerEntity(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatapipeStatus(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatapipeStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAttackPathFindings(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAttackPathFindingsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableAttackPathTypesForDomain(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableAttackPathTypesForDomainRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDomainAttackPathsDetails(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDomainAttackPathsDetailsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttackPathSparklineValues(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttackPathSparklineValuesRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntity(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainEntityWithBody(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainEntityRequestWithBody(c.Server, objectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainEntity(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainEntityRequest(c.Server, objectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityComputers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityDcSyncers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityDcSyncersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignAdmins(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignGpoControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignGpoControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityInboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityInboundTrustsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityLinkedGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityLinkedGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityOus(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityOusRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityOutboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityOutboundTrustsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnterpriseCaEntity(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnterpriseCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnterpriseCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnterpriseCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientSchedules(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduleWithBody(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientSchedule(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientEvent(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientEventRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientSchedule(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientScheduleRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientEventWithBody(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientEventRequestWithBody(c.Server, eventId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientEvent(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientEventRequest(c.Server, eventId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFeatureFlags(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFeatureFlagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleFeatureFlag(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleFeatureFlagRequest(c.Server, featureId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFileUploadJobs(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFileUploadJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAcceptedFileUploadTypes(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAcceptedFileUploadTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFileUploadJob(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFileUploadJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileToJobWithBody(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileToJobRequestWithBody(c.Server, fileUploadJobId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileToJob(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileToJobRequest(c.Server, fileUploadJobId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndFileUploadJob(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndFileUploadJobRequest(c.Server, fileUploadJobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntity(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityComputers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityOus(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityOusRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityTierZero(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityTierZeroRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityUsers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResult(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunCypherQueryWithBody(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunCypherQueryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunCypherQuery(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunCypherQueryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPathComposition(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPathCompositionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShortestPath(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShortestPathRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntity(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityControllables(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityMembers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityMembersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityMemberships(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityMembershipsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntitySessions(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestData(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJobs(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableClientJobs(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableClientJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientCurrentJob(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientCurrentJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndClientJob(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndClientJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientFinishedJobs(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientFinishedJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartClientJobWithBody(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartClientJobRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartClientJob(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartClientJobRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJob(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelClientJob(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelClientJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJobLog(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobLogRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestTierZeroComboNode(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestTierZeroComboNodeRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComboTreeGraph(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComboTreeGraphRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetaEntity(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNtAuthStoreEntity(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNtAuthStoreEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNtAuthStoreEntityControllers(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNtAuthStoreEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntity(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityComputers(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityGpos(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityGroups(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityUsers(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pathfinding(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPathfindingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissions(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermission(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionRequest(c.Server, permissionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformDataQualityAggregate(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformDataQualityAggregateRequest(c.Server, platformId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostureStats(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostureStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, roleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootCaEntity(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSamlProviders(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSamlProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSamlProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSamlProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSamlProvider(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSamlProviderRequest(c.Server, samlProviderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlProvider(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlProviderRequest(c.Server, samlProviderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlSignSignOnEndpoints(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlSignSignOnEndpointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSavedQueries(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSavedQueriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSavedQueryWithBody(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSavedQueryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSavedQuery(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSavedQueryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQuery(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryRequest(c.Server, savedQueryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSavedQueryWithBody(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSavedQueryRequestWithBody(c.Server, savedQueryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSavedQuery(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSavedQueryRequest(c.Server, savedQueryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQueryPermissionsWithBody(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryPermissionsRequestWithBody(c.Server, savedQueryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQueryPermissions(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryPermissionsRequest(c.Server, savedQueryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareSavedQueryWithBody(ctx context.Context, savedQueryId int32, params *ShareSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareSavedQueryRequestWithBody(c.Server, savedQueryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShareSavedQuery(ctx context.Context, savedQueryId int32, params *ShareSavedQueryParams, body ShareSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShareSavedQueryRequest(c.Server, savedQueryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelf(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiSpec(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiSpecRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuthTokens(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuthTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthTokenWithBody(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthToken(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthToken(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthTokenRequest(c.Server, tokenId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntity(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityConstrainedDelegationRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityControllables(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityControllers(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityMembership(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityMembershipRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntitySessions(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntitySqlAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntitySqlAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiVersion(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAcceptEulaRequest generates requests for AcceptEula
func NewAcceptEulaRequest(server string, params *AcceptEulaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accept-eula")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAdDomainDataQualityStatsRequest generates requests for GetAdDomainDataQualityStats
func NewGetAdDomainDataQualityStatsRequest(server string, domainId string, params *GetAdDomainDataQualityStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ad-domains/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAiaCaEntityRequest generates requests for GetAiaCaEntity
func NewGetAiaCaEntityRequest(server string, objectId PathObjectId, params *GetAiaCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/aiacas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAiaCaEntityControllersRequest generates requests for GetAiaCaEntityControllers
func NewGetAiaCaEntityControllersRequest(server string, objectId PathObjectId, params *GetAiaCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/aiacas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartAnalysisRequest generates requests for StartAnalysis
func NewStartAnalysisRequest(server string, params *StartAnalysisParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/analysis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupsRequest generates requests for ListAssetGroups
func NewListAssetGroupsRequest(server string, params *ListAssetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SystemGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "system_group", runtime.ParamLocationQuery, *params.SystemGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "member_count", runtime.ParamLocationQuery, *params.MemberCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAssetGroupRequest calls the generic CreateAssetGroup builder with application/json body
func NewCreateAssetGroupRequest(server string, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAssetGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAssetGroupRequestWithBody generates requests for CreateAssetGroup with any type of body
func NewCreateAssetGroupRequestWithBody(server string, params *CreateAssetGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAssetGroupRequest generates requests for DeleteAssetGroup
func NewDeleteAssetGroupRequest(server string, assetGroupId int32, params *DeleteAssetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupRequest generates requests for GetAssetGroup
func NewGetAssetGroupRequest(server string, assetGroupId int32, params *GetAssetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupRequest calls the generic UpdateAssetGroup builder with application/json body
func NewUpdateAssetGroupRequest(server string, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupRequestWithBody generates requests for UpdateAssetGroup with any type of body
func NewUpdateAssetGroupRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupCollectionsRequest generates requests for ListAssetGroupCollections
func NewListAssetGroupCollectionsRequest(server string, assetGroupId int32, params *ListAssetGroupCollectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/collections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupComboNodeRequest generates requests for GetAssetGroupComboNode
func NewGetAssetGroupComboNodeRequest(server string, assetGroupId int32, params *GetAssetGroupComboNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/combo-node", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Domainsid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainsid", runtime.ParamLocationQuery, *params.Domainsid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupCustomMemberCountRequest generates requests for GetAssetGroupCustomMemberCount
func NewGetAssetGroupCustomMemberCountRequest(server string, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/custom-selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupMembersRequest generates requests for ListAssetGroupMembers
func NewListAssetGroupMembersRequest(server string, assetGroupId int32, params *ListAssetGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, *params.ObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_kind", runtime.ParamLocationQuery, *params.PrimaryKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_id", runtime.ParamLocationQuery, *params.EnvironmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_kind", runtime.ParamLocationQuery, *params.EnvironmentKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_member", runtime.ParamLocationQuery, *params.CustomMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupMemberCountByKindRequest generates requests for ListAssetGroupMemberCountByKind
func NewListAssetGroupMemberCountByKindRequest(server string, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/members/counts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, *params.ObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_id", runtime.ParamLocationQuery, *params.EnvironmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_kind", runtime.ParamLocationQuery, *params.PrimaryKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_kind", runtime.ParamLocationQuery, *params.EnvironmentKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_member", runtime.ParamLocationQuery, *params.CustomMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupSelectorsDeprecatedRequest calls the generic UpdateAssetGroupSelectorsDeprecated builder with application/json body
func NewUpdateAssetGroupSelectorsDeprecatedRequest(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody generates requests for UpdateAssetGroupSelectorsDeprecated with any type of body
func NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupSelectorsRequest calls the generic UpdateAssetGroupSelectors builder with application/json body
func NewUpdateAssetGroupSelectorsRequest(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupSelectorsRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupSelectorsRequestWithBody generates requests for UpdateAssetGroupSelectors with any type of body
func NewUpdateAssetGroupSelectorsRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAssetGroupSelectorRequest generates requests for DeleteAssetGroupSelector
func NewDeleteAssetGroupSelectorRequest(server string, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "asset_group_selector_id", runtime.ParamLocationPath, assetGroupSelectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAttackPathTypesRequest generates requests for ListAttackPathTypes
func NewListAttackPathTypesRequest(server string, params *ListAttackPathTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-path-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartAnalysisBheRequest generates requests for StartAnalysisBhe
func NewStartAnalysisBheRequest(server string, params *StartAnalysisBheParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-paths")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAttackPathRiskRequest calls the generic UpdateAttackPathRisk builder with application/json body
func NewUpdateAttackPathRiskRequest(server string, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAttackPathRiskRequestWithBody(server, attackPathId, params, "application/json", bodyReader)
}

// NewUpdateAttackPathRiskRequestWithBody generates requests for UpdateAttackPathRisk with any type of body
func NewUpdateAttackPathRiskRequestWithBody(server string, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attack_path_id", runtime.ParamLocationPath, attackPathId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-paths/%s/acceptance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/audit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_id", runtime.ParamLocationQuery, *params.ActorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_name", runtime.ParamLocationQuery, *params.ActorName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_email", runtime.ParamLocationQuery, *params.ActorEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "request_id", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAvailableDomainsRequest generates requests for GetAvailableDomains
func NewGetAvailableDomainsRequest(server string, params *GetAvailableDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/available-domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Objectid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objectid", runtime.ParamLocationQuery, *params.Objectid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Collected != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collected", runtime.ParamLocationQuery, *params.Collected); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAzureTenantDataQualityStatsRequest generates requests for GetAzureTenantDataQualityStats
func NewGetAzureTenantDataQualityStatsRequest(server string, tenantId string, params *GetAzureTenantDataQualityStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant_id", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/azure-tenants/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAzureEntityRequest generates requests for GetAzureEntity
func NewGetAzureEntityRequest(server string, entityType string, params *GetAzureEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity_type", runtime.ParamLocationPath, entityType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/azure/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, params.ObjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelatedEntityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "related_entity_type", runtime.ParamLocationQuery, *params.RelatedEntityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityRequest generates requests for GetEntity
func NewGetEntityRequest(server string, objectId PathObjectId, params *GetEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityControllablesRequest generates requests for GetEntityControllables
func NewGetEntityControllablesRequest(server string, objectId PathObjectId, params *GetEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityControllersRequest generates requests for GetEntityControllers
func NewGetEntityControllersRequest(server string, objectId PathObjectId, params *GetEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_name", runtime.ParamLocationQuery, *params.FirstName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_name", runtime.ParamLocationQuery, *params.LastName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_address", runtime.ParamLocationQuery, *params.EmailAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrincipalName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principal_name", runtime.ParamLocationQuery, *params.PrincipalName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastLogin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_login", runtime.ParamLocationQuery, *params.LastLogin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId openapi_types.UUID, params *DeleteUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId openapi_types.UUID, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewRemoveUserMfaRequest calls the generic RemoveUserMfa builder with application/json body
func NewRemoveUserMfaRequest(server string, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewRemoveUserMfaRequestWithBody generates requests for RemoveUserMfa with any type of body
func NewRemoveUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewAddUserMfaRequest calls the generic AddUserMfa builder with application/json body
func NewAddUserMfaRequest(server string, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewAddUserMfaRequestWithBody generates requests for AddUserMfa with any type of body
func NewAddUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetMfaActivationStatusRequest generates requests for GetMfaActivationStatus
func NewGetMfaActivationStatusRequest(server string, userId openapi_types.UUID, params *GetMfaActivationStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa-activation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewActivateUserMfaRequest calls the generic ActivateUserMfa builder with application/json body
func NewActivateUserMfaRequest(server string, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewActivateUserMfaRequestWithBody generates requests for ActivateUserMfa with any type of body
func NewActivateUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa-activation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUserSecretRequest generates requests for DeleteUserSecret
func NewDeleteUserSecretRequest(server string, userId openapi_types.UUID, params *DeleteUserSecretParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateOrSetUserSecretRequest calls the generic CreateOrSetUserSecret builder with application/json body
func NewCreateOrSetUserSecretRequest(server string, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrSetUserSecretRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewCreateOrSetUserSecretRequestWithBody generates requests for CreateOrSetUserSecret with any type of body
func NewCreateOrSetUserSecretRequestWithBody(server string, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCertTemplateEntityRequest generates requests for GetCertTemplateEntity
func NewGetCertTemplateEntityRequest(server string, objectId PathObjectId, params *GetCertTemplateEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/certtemplates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCertTemplateEntityControllersRequest generates requests for GetCertTemplateEntityControllers
func NewGetCertTemplateEntityControllersRequest(server string, objectId PathObjectId, params *GetCertTemplateEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/certtemplates/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteBloodHoundDatabaseRequest calls the generic DeleteBloodHoundDatabase builder with application/json body
func NewDeleteBloodHoundDatabaseRequest(server string, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteBloodHoundDatabaseRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteBloodHoundDatabaseRequestWithBody generates requests for DeleteBloodHoundDatabase with any type of body
func NewDeleteBloodHoundDatabaseRequestWithBody(server string, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clear-database")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientsRequest generates requests for ListClients
func NewListClientsRequest(server string, params *ListClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip_address", runtime.ParamLocationQuery, *params.IpAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostname", runtime.ParamLocationQuery, *params.Hostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConfiguredUser != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configured_user", runtime.ParamLocationQuery, *params.ConfiguredUser); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_sid", runtime.ParamLocationQuery, *params.UserSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastCheckin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_checkin", runtime.ParamLocationQuery, *params.LastCheckin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentJobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current_job_id", runtime.ParamLocationQuery, *params.CurrentJobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedJobCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_job_count", runtime.ParamLocationQuery, *params.CompletedJobCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientRequest calls the generic CreateClient builder with application/json body
func NewCreateClientRequest(server string, params *CreateClientParams, body CreateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateClientRequestWithBody generates requests for CreateClient with any type of body
func NewCreateClientRequestWithBody(server string, params *CreateClientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLogClientErrorRequest calls the generic LogClientError builder with application/json body
func NewLogClientErrorRequest(server string, params *LogClientErrorParams, body LogClientErrorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLogClientErrorRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLogClientErrorRequestWithBody generates requests for LogClientError with any type of body
func NewLogClientErrorRequestWithBody(server string, params *LogClientErrorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/error")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientInfoRequest calls the generic UpdateClientInfo builder with application/json body
func NewUpdateClientInfoRequest(server string, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientInfoRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateClientInfoRequestWithBody generates requests for UpdateClientInfo with any type of body
func NewUpdateClientInfoRequestWithBody(server string, params *UpdateClientInfoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteClientRequest generates requests for DeleteClient
func NewDeleteClientRequest(server string, clientId openapi_types.UUID, params *DeleteClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientRequest generates requests for GetClient
func NewGetClientRequest(server string, clientId openapi_types.UUID, params *GetClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientRequest calls the generic UpdateClient builder with application/json body
func NewUpdateClientRequest(server string, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewUpdateClientRequestWithBody generates requests for UpdateClient with any type of body
func NewUpdateClientRequestWithBody(server string, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientCompletedJobsRequest generates requests for ListClientCompletedJobs
func NewListClientCompletedJobsRequest(server string, clientId openapi_types.UUID, params *ListClientCompletedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/completed-jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientCompletedTasksRequest generates requests for ListClientCompletedTasks
func NewListClientCompletedTasksRequest(server string, clientId openapi_types.UUID, params *ListClientCompletedTasksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/completed-tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduledJobRequest calls the generic CreateClientScheduledJob builder with application/json body
func NewCreateClientScheduledJobRequest(server string, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduledJobRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewCreateClientScheduledJobRequestWithBody generates requests for CreateClientScheduledJob with any type of body
func NewCreateClientScheduledJobRequestWithBody(server string, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduledTaskRequest calls the generic CreateClientScheduledTask builder with application/json body
func NewCreateClientScheduledTaskRequest(server string, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduledTaskRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewCreateClientScheduledTaskRequestWithBody generates requests for CreateClientScheduledTask with any type of body
func NewCreateClientScheduledTaskRequestWithBody(server string, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewReplaceClientTokenRequest generates requests for ReplaceClientToken
func NewReplaceClientTokenRequest(server string, clientId openapi_types.UUID, params *ReplaceClientTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCollectorManifestRequest generates requests for GetCollectorManifest
func NewGetCollectorManifestRequest(server string, collectorType EnumClientType, params *GetCollectorManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDownloadCollectorRequest generates requests for DownloadCollector
func NewDownloadCollectorRequest(server string, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "release_tag", runtime.ParamLocationPath, releaseTag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCollectorChecksumRequest generates requests for GetCollectorChecksum
func NewGetCollectorChecksumRequest(server string, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "release_tag", runtime.ParamLocationPath, releaseTag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s/%s/checksum", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCompletenessStatsRequest generates requests for GetCompletenessStats
func NewGetCompletenessStatsRequest(server string, params *GetCompletenessStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/completeness")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRequest generates requests for GetComputerEntity
func NewGetComputerEntityRequest(server string, objectId PathObjectId, params *GetComputerEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityAdminRightsRequest generates requests for GetComputerEntityAdminRights
func NewGetComputerEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityAdminsRequest generates requests for GetComputerEntityAdmins
func NewGetComputerEntityAdminsRequest(server string, objectId PathObjectId, params *GetComputerEntityAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/admin-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityConstrainedDelegationRightsRequest generates requests for GetComputerEntityConstrainedDelegationRights
func NewGetComputerEntityConstrainedDelegationRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/constrained-delegation-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityConstrainedUsersRequest generates requests for GetComputerEntityConstrainedUsers
func NewGetComputerEntityConstrainedUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/constrained-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityControllablesRequest generates requests for GetComputerEntityControllables
func NewGetComputerEntityControllablesRequest(server string, objectId PathObjectId, params *GetComputerEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityControllersRequest generates requests for GetComputerEntityControllers
func NewGetComputerEntityControllersRequest(server string, objectId PathObjectId, params *GetComputerEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityDcomRightsRequest generates requests for GetComputerEntityDcomRights
func NewGetComputerEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityDcomUsersRequest generates requests for GetComputerEntityDcomUsers
func NewGetComputerEntityDcomUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityDcomUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/dcom-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityGroupMembershipRequest generates requests for GetComputerEntityGroupMembership
func NewGetComputerEntityGroupMembershipRequest(server string, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/group-membership", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityPsRemoteRightsRequest generates requests for GetComputerEntityPsRemoteRights
func NewGetComputerEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityPsRemoteUsersRequest generates requests for GetComputerEntityPsRemoteUsers
func NewGetComputerEntityPsRemoteUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/ps-remote-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRdpRightsRequest generates requests for GetComputerEntityRdpRights
func NewGetComputerEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRdpUsersRequest generates requests for GetComputerEntityRdpUsers
func NewGetComputerEntityRdpUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityRdpUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/rdp-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntitySessionsRequest generates requests for GetComputerEntitySessions
func NewGetComputerEntitySessionsRequest(server string, objectId PathObjectId, params *GetComputerEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntitySqlAdminsRequest generates requests for GetComputerEntitySqlAdmins
func NewGetComputerEntitySqlAdminsRequest(server string, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/sql-admins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAppConfigParamsRequest generates requests for ListAppConfigParams
func NewListAppConfigParamsRequest(server string, params *ListAppConfigParamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Parameter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parameter", runtime.ParamLocationQuery, *params.Parameter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewSetAppConfigParamRequest calls the generic SetAppConfigParam builder with application/json body
func NewSetAppConfigParamRequest(server string, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAppConfigParamRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSetAppConfigParamRequestWithBody generates requests for SetAppConfigParam with any type of body
func NewSetAppConfigParamRequestWithBody(server string, params *SetAppConfigParamParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetContainerEntityRequest generates requests for GetContainerEntity
func NewGetContainerEntityRequest(server string, objectId PathObjectId, params *GetContainerEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetContainerEntityControllersRequest generates requests for GetContainerEntityControllers
func NewGetContainerEntityControllersRequest(server string, objectId PathObjectId, params *GetContainerEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/containers/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDatapipeStatusRequest generates requests for GetDatapipeStatus
func NewGetDatapipeStatusRequest(server string, params *GetDatapipeStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/datapipe/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewExportAttackPathFindingsRequest generates requests for ExportAttackPathFindings
func NewExportAttackPathFindingsRequest(server string, domainId string, params *ExportAttackPathFindingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/attack-path-findings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FilterAccepted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterAccepted", runtime.ParamLocationQuery, *params.FilterAccepted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAvailableAttackPathTypesForDomainRequest generates requests for ListAvailableAttackPathTypesForDomain
func NewListAvailableAttackPathTypesForDomainRequest(server string, domainId string, params *ListAvailableAttackPathTypesForDomainParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/available-types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListDomainAttackPathsDetailsRequest generates requests for ListDomainAttackPathsDetails
func NewListDomainAttackPathsDetailsRequest(server string, domainId string, params *ListDomainAttackPathsDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/details", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FindingDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.FindingDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromPrincipalDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "FromPrincipal", runtime.ParamLocationQuery, *params.FromPrincipalDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToPrincipalDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ToPrincipal", runtime.ParamLocationQuery, *params.ToPrincipalDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromPrincipal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_principal", runtime.ParamLocationQuery, *params.FromPrincipal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToPrincipal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_principal", runtime.ParamLocationQuery, *params.ToPrincipal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrincipalsHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principals_hash", runtime.ParamLocationQuery, *params.PrincipalsHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accepted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Accepted", runtime.ParamLocationQuery, *params.Accepted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AcceptedUntilDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "AcceptedUntil", runtime.ParamLocationQuery, *params.AcceptedUntilDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AcceptedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepted_until", runtime.ParamLocationQuery, *params.AcceptedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Principal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Principal", runtime.ParamLocationQuery, *params.Principal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_sid", runtime.ParamLocationQuery, *params.DomainSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAttackPathSparklineValuesRequest generates requests for ListAttackPathSparklineValues
func NewListAttackPathSparklineValuesRequest(server string, domainId string, params *ListAttackPathSparklineValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/sparkline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityRequest generates requests for GetDomainEntity
func NewGetDomainEntityRequest(server string, objectId PathObjectId, params *GetDomainEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateDomainEntityRequest calls the generic UpdateDomainEntity builder with application/json body
func NewUpdateDomainEntityRequest(server string, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDomainEntityRequestWithBody(server, objectId, params, "application/json", bodyReader)
}

// NewUpdateDomainEntityRequestWithBody generates requests for UpdateDomainEntity with any type of body
func NewUpdateDomainEntityRequestWithBody(server string, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityComputersRequest generates requests for GetDomainEntityComputers
func NewGetDomainEntityComputersRequest(server string, objectId PathObjectId, params *GetDomainEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityControllersRequest generates requests for GetDomainEntityControllers
func NewGetDomainEntityControllersRequest(server string, objectId PathObjectId, params *GetDomainEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityDcSyncersRequest generates requests for GetDomainEntityDcSyncers
func NewGetDomainEntityDcSyncersRequest(server string, objectId PathObjectId, params *GetDomainEntityDcSyncersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/dc-syncers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignAdminsRequest generates requests for GetDomainEntityForeignAdmins
func NewGetDomainEntityForeignAdminsRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-admins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignGpoControllersRequest generates requests for GetDomainEntityForeignGpoControllers
func NewGetDomainEntityForeignGpoControllersRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-gpo-controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignGroupsRequest generates requests for GetDomainEntityForeignGroups
func NewGetDomainEntityForeignGroupsRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignUsersRequest generates requests for GetDomainEntityForeignUsers
func NewGetDomainEntityForeignUsersRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityGposRequest generates requests for GetDomainEntityGpos
func NewGetDomainEntityGposRequest(server string, objectId PathObjectId, params *GetDomainEntityGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityGroupsRequest generates requests for GetDomainEntityGroups
func NewGetDomainEntityGroupsRequest(server string, objectId PathObjectId, params *GetDomainEntityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityInboundTrustsRequest generates requests for GetDomainEntityInboundTrusts
func NewGetDomainEntityInboundTrustsRequest(server string, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/inbound-trusts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityLinkedGposRequest generates requests for GetDomainEntityLinkedGpos
func NewGetDomainEntityLinkedGposRequest(server string, objectId PathObjectId, params *GetDomainEntityLinkedGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/linked-gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityOusRequest generates requests for GetDomainEntityOus
func NewGetDomainEntityOusRequest(server string, objectId PathObjectId, params *GetDomainEntityOusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/ous", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityOutboundTrustsRequest generates requests for GetDomainEntityOutboundTrusts
func NewGetDomainEntityOutboundTrustsRequest(server string, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/outbound-trusts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityUsersRequest generates requests for GetDomainEntityUsers
func NewGetDomainEntityUsersRequest(server string, objectId PathObjectId, params *GetDomainEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEnterpriseCaEntityRequest generates requests for GetEnterpriseCaEntity
func NewGetEnterpriseCaEntityRequest(server string, objectId PathObjectId, params *GetEnterpriseCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/enterprisecas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEnterpriseCaEntityControllersRequest generates requests for GetEnterpriseCaEntityControllers
func NewGetEnterpriseCaEntityControllersRequest(server string, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/enterprisecas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientSchedulesRequest generates requests for ListClientSchedules
func NewListClientSchedulesRequest(server string, params *ListClientSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rrule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rrule", runtime.ParamLocationQuery, *params.Rrule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextScheduledAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_scheduled_at", runtime.ParamLocationQuery, *params.NextScheduledAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduleRequest calls the generic CreateClientSchedule builder with application/json body
func NewCreateClientScheduleRequest(server string, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateClientScheduleRequestWithBody generates requests for CreateClientSchedule with any type of body
func NewCreateClientScheduleRequestWithBody(server string, params *CreateClientScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteClientEventRequest generates requests for DeleteClientEvent
func NewDeleteClientEventRequest(server string, eventId int32, params *DeleteClientEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientScheduleRequest generates requests for GetClientSchedule
func NewGetClientScheduleRequest(server string, eventId int32, params *GetClientScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientEventRequest calls the generic UpdateClientEvent builder with application/json body
func NewUpdateClientEventRequest(server string, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientEventRequestWithBody(server, eventId, params, "application/json", bodyReader)
}

// NewUpdateClientEventRequestWithBody generates requests for UpdateClientEvent with any type of body
func NewUpdateClientEventRequestWithBody(server string, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListFeatureFlagsRequest generates requests for ListFeatureFlags
func NewListFeatureFlagsRequest(server string, params *ListFeatureFlagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewToggleFeatureFlagRequest generates requests for ToggleFeatureFlag
func NewToggleFeatureFlagRequest(server string, featureId int32, params *ToggleFeatureFlagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "feature_id", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/features/%s/toggle", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListFileUploadJobsRequest generates requests for ListFileUploadJobs
func NewListFileUploadJobsRequest(server string, params *ListFileUploadJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserEmailAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_email_address", runtime.ParamLocationQuery, *params.UserEmailAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusMessage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status_message", runtime.ParamLocationQuery, *params.StatusMessage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAcceptedFileUploadTypesRequest generates requests for ListAcceptedFileUploadTypes
func NewListAcceptedFileUploadTypesRequest(server string, params *ListAcceptedFileUploadTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/accepted-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateFileUploadJobRequest generates requests for CreateFileUploadJob
func NewCreateFileUploadJobRequest(server string, params *CreateFileUploadJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUploadFileToJobRequest calls the generic UploadFileToJob builder with application/json body
func NewUploadFileToJobRequest(server string, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadFileToJobRequestWithBody(server, fileUploadJobId, params, "application/json", bodyReader)
}

// NewUploadFileToJobRequestWithBody generates requests for UploadFileToJob with any type of body
func NewUploadFileToJobRequestWithBody(server string, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_upload_job_id", runtime.ParamLocationPath, fileUploadJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam1)

	}

	return req, nil
}

// NewEndFileUploadJobRequest generates requests for EndFileUploadJob
func NewEndFileUploadJobRequest(server string, fileUploadJobId int64, params *EndFileUploadJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_upload_job_id", runtime.ParamLocationPath, fileUploadJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/%s/end", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityRequest generates requests for GetGpoEntity
func NewGetGpoEntityRequest(server string, objectId PathObjectId, params *GetGpoEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityComputersRequest generates requests for GetGpoEntityComputers
func NewGetGpoEntityComputersRequest(server string, objectId PathObjectId, params *GetGpoEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityControllersRequest generates requests for GetGpoEntityControllers
func NewGetGpoEntityControllersRequest(server string, objectId PathObjectId, params *GetGpoEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityOusRequest generates requests for GetGpoEntityOus
func NewGetGpoEntityOusRequest(server string, objectId PathObjectId, params *GetGpoEntityOusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/ous", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityTierZeroRequest generates requests for GetGpoEntityTierZero
func NewGetGpoEntityTierZeroRequest(server string, objectId PathObjectId, params *GetGpoEntityTierZeroParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/tier-zero", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityUsersRequest generates requests for GetGpoEntityUsers
func NewGetGpoEntityUsersRequest(server string, objectId PathObjectId, params *GetGpoEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSearchResultRequest generates requests for GetSearchResult
func NewGetSearchResultRequest(server string, params *GetSearchResultParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graph-search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_query", runtime.ParamLocationQuery, params.SearchQuery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewRunCypherQueryRequest calls the generic RunCypherQuery builder with application/json body
func NewRunCypherQueryRequest(server string, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunCypherQueryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRunCypherQueryRequestWithBody generates requests for RunCypherQuery with any type of body
func NewRunCypherQueryRequestWithBody(server string, params *RunCypherQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/cypher")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPathCompositionRequest generates requests for GetPathComposition
func NewGetPathCompositionRequest(server string, params *GetPathCompositionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/edge-composition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_node", runtime.ParamLocationQuery, params.SourceNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_node", runtime.ParamLocationQuery, params.TargetNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "edge_type", runtime.ParamLocationQuery, params.EdgeType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetShortestPathRequest generates requests for GetShortestPath
func NewGetShortestPathRequest(server string, params *GetShortestPathParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/shortest-path")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_node", runtime.ParamLocationQuery, params.StartNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_node", runtime.ParamLocationQuery, params.EndNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RelationshipKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship_kinds", runtime.ParamLocationQuery, *params.RelationshipKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityRequest generates requests for GetGroupEntity
func NewGetGroupEntityRequest(server string, objectId PathObjectId, params *GetGroupEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityAdminRightsRequest generates requests for GetGroupEntityAdminRights
func NewGetGroupEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityControllablesRequest generates requests for GetGroupEntityControllables
func NewGetGroupEntityControllablesRequest(server string, objectId PathObjectId, params *GetGroupEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityControllersRequest generates requests for GetGroupEntityControllers
func NewGetGroupEntityControllersRequest(server string, objectId PathObjectId, params *GetGroupEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityDcomRightsRequest generates requests for GetGroupEntityDcomRights
func NewGetGroupEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityMembersRequest generates requests for GetGroupEntityMembers
func NewGetGroupEntityMembersRequest(server string, objectId PathObjectId, params *GetGroupEntityMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityMembershipsRequest generates requests for GetGroupEntityMemberships
func NewGetGroupEntityMembershipsRequest(server string, objectId PathObjectId, params *GetGroupEntityMembershipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityPsRemoteRightsRequest generates requests for GetGroupEntityPsRemoteRights
func NewGetGroupEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityRdpRightsRequest generates requests for GetGroupEntityRdpRights
func NewGetGroupEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntitySessionsRequest generates requests for GetGroupEntitySessions
func NewGetGroupEntitySessionsRequest(server string, objectId PathObjectId, params *GetGroupEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewIngestDataRequest generates requests for IngestData
func NewIngestDataRequest(server string, params *IngestDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ingest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobsRequest generates requests for GetClientJobs
func NewGetClientJobsRequest(server string, params *GetClientJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAvailableClientJobsRequest generates requests for ListAvailableClientJobs
func NewListAvailableClientJobsRequest(server string, params *ListAvailableClientJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/available")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientCurrentJobRequest generates requests for GetClientCurrentJob
func NewGetClientCurrentJobRequest(server string, params *GetClientCurrentJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewEndClientJobRequest generates requests for EndClientJob
func NewEndClientJobRequest(server string, params *EndClientJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/end")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientFinishedJobsRequest generates requests for ListClientFinishedJobs
func NewListClientFinishedJobsRequest(server string, params *ListClientFinishedJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/finished")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartClientJobRequest calls the generic StartClientJob builder with application/json body
func NewStartClientJobRequest(server string, params *StartClientJobParams, body StartClientJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartClientJobRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStartClientJobRequestWithBody generates requests for StartClientJob with any type of body
func NewStartClientJobRequestWithBody(server string, params *StartClientJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobRequest generates requests for GetClientJob
func NewGetClientJobRequest(server string, jobId int64, params *GetClientJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCancelClientJobRequest generates requests for CancelClientJob
func NewCancelClientJobRequest(server string, jobId int64, params *CancelClientJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobLogRequest generates requests for GetClientJobLog
func NewGetClientJobLogRequest(server string, jobId int64, params *GetClientJobLogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s/log", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, params *LoginParams, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, params *LoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string, params *LogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetLatestTierZeroComboNodeRequest generates requests for GetLatestTierZeroComboNode
func NewGetLatestTierZeroComboNodeRequest(server string, domainId string, params *GetLatestTierZeroComboNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta-nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComboTreeGraphRequest generates requests for GetComboTreeGraph
func NewGetComboTreeGraphRequest(server string, domainId string, params *GetComboTreeGraphParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta-trees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NodeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "node_id", runtime.ParamLocationQuery, *params.NodeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetMetaEntityRequest generates requests for GetMetaEntity
func NewGetMetaEntityRequest(server string, objectId PathObjectId, params *GetMetaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetNtAuthStoreEntityRequest generates requests for GetNtAuthStoreEntity
func NewGetNtAuthStoreEntityRequest(server string, objectId PathObjectId, params *GetNtAuthStoreEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ntauthstores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetNtAuthStoreEntityControllersRequest generates requests for GetNtAuthStoreEntityControllers
func NewGetNtAuthStoreEntityControllersRequest(server string, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ntauthstores/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityRequest generates requests for GetOuEntity
func NewGetOuEntityRequest(server string, objectId PathObjectId, params *GetOuEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityComputersRequest generates requests for GetOuEntityComputers
func NewGetOuEntityComputersRequest(server string, objectId PathObjectId, params *GetOuEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityGposRequest generates requests for GetOuEntityGpos
func NewGetOuEntityGposRequest(server string, objectId PathObjectId, params *GetOuEntityGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityGroupsRequest generates requests for GetOuEntityGroups
func NewGetOuEntityGroupsRequest(server string, objectId PathObjectId, params *GetOuEntityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityUsersRequest generates requests for GetOuEntityUsers
func NewGetOuEntityUsersRequest(server string, objectId PathObjectId, params *GetOuEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewPathfindingRequest generates requests for Pathfinding
func NewPathfindingRequest(server string, params *PathfindingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/pathfinding")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_node", runtime.ParamLocationQuery, params.StartNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_node", runtime.ParamLocationQuery, params.EndNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListPermissionsRequest generates requests for ListPermissions
func NewListPermissionsRequest(server string, params *ListPermissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authority", runtime.ParamLocationQuery, *params.Authority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPermissionRequest generates requests for GetPermission
func NewGetPermissionRequest(server string, permissionId int32, params *GetPermissionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPlatformDataQualityAggregateRequest generates requests for GetPlatformDataQualityAggregate
func NewGetPlatformDataQualityAggregateRequest(server string, platformId string, params *GetPlatformDataQualityAggregateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform_id", runtime.ParamLocationPath, platformId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/platform/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPostureStatsRequest generates requests for GetPostureStats
func NewGetPostureStatsRequest(server string, params *GetPostureStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/posture-stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.FromDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.ToDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_sid", runtime.ParamLocationQuery, *params.DomainSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExposureIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exposure_index", runtime.ParamLocationQuery, *params.ExposureIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TierZeroCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tier_zero_count", runtime.ParamLocationQuery, *params.TierZeroCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CriticalRiskCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "critical_risk_count", runtime.ParamLocationQuery, *params.CriticalRiskCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string, params *ListRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, roleId int32, params *GetRoleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRootCaEntityRequest generates requests for GetRootCaEntity
func NewGetRootCaEntityRequest(server string, objectId PathObjectId, params *GetRootCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/rootcas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRootCaEntityControllersRequest generates requests for GetRootCaEntityControllers
func NewGetRootCaEntityControllersRequest(server string, objectId PathObjectId, params *GetRootCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/rootcas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListSamlProvidersRequest generates requests for ListSamlProviders
func NewListSamlProvidersRequest(server string, params *ListSamlProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSamlProviderRequestWithBody generates requests for CreateSamlProvider with any type of body
func NewCreateSamlProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSamlProviderRequest generates requests for DeleteSamlProvider
func NewDeleteSamlProviderRequest(server string, samlProviderId int32, params *DeleteSamlProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saml_provider_id", runtime.ParamLocationPath, samlProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSamlProviderRequest generates requests for GetSamlProvider
func NewGetSamlProviderRequest(server string, samlProviderId int32, params *GetSamlProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saml_provider_id", runtime.ParamLocationPath, samlProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSamlSignSignOnEndpointsRequest generates requests for GetSamlSignSignOnEndpoints
func NewGetSamlSignSignOnEndpointsRequest(server string, params *GetSamlSignSignOnEndpointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/sso")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListSavedQueriesRequest generates requests for ListSavedQueries
func NewListSavedQueriesRequest(server string, params *ListSavedQueriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSavedQueryRequest calls the generic CreateSavedQuery builder with application/json body
func NewCreateSavedQueryRequest(server string, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSavedQueryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSavedQueryRequestWithBody generates requests for CreateSavedQuery with any type of body
func NewCreateSavedQueryRequestWithBody(server string, params *CreateSavedQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSavedQueryRequest generates requests for DeleteSavedQuery
func NewDeleteSavedQueryRequest(server string, savedQueryId int32, params *DeleteSavedQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSavedQueryRequest calls the generic UpdateSavedQuery builder with application/json body
func NewUpdateSavedQueryRequest(server string, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSavedQueryRequestWithBody(server, savedQueryId, params, "application/json", bodyReader)
}

// NewUpdateSavedQueryRequestWithBody generates requests for UpdateSavedQuery with any type of body
func NewUpdateSavedQueryRequestWithBody(server string, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSavedQueryPermissionsRequest calls the generic DeleteSavedQueryPermissions builder with application/json body
func NewDeleteSavedQueryPermissionsRequest(server string, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSavedQueryPermissionsRequestWithBody(server, savedQueryId, params, "application/json", bodyReader)
}

// NewDeleteSavedQueryPermissionsRequestWithBody generates requests for DeleteSavedQueryPermissions with any type of body
func NewDeleteSavedQueryPermissionsRequestWithBody(server string, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewShareSavedQueryRequest calls the generic ShareSavedQuery builder with application/json body
func NewShareSavedQueryRequest(server string, savedQueryId int32, params *ShareSavedQueryParams, body ShareSavedQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareSavedQueryRequestWithBody(server, savedQueryId, params, "application/json", bodyReader)
}

// NewShareSavedQueryRequestWithBody generates requests for ShareSavedQuery with any type of body
func NewShareSavedQueryRequestWithBody(server string, savedQueryId int32, params *ShareSavedQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSelfRequest generates requests for GetSelf
func NewGetSelfRequest(server string, params *GetSelfParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiSpecRequest generates requests for GetApiSpec
func NewGetApiSpecRequest(server string, params *GetApiSpecParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/spec/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAuthTokensRequest generates requests for ListAuthTokens
func NewListAuthTokensRequest(server string, params *ListAuthTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HmacMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hmac_method", runtime.ParamLocationQuery, *params.HmacMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastAccess != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_access", runtime.ParamLocationQuery, *params.LastAccess); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAuthTokenRequest calls the generic CreateAuthToken builder with application/json body
func NewCreateAuthTokenRequest(server string, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuthTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAuthTokenRequestWithBody generates requests for CreateAuthToken with any type of body
func NewCreateAuthTokenRequestWithBody(server string, params *CreateAuthTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAuthTokenRequest generates requests for DeleteAuthToken
func NewDeleteAuthTokenRequest(server string, tokenId openapi_types.UUID, params *DeleteAuthTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityRequest generates requests for GetUserEntity
func NewGetUserEntityRequest(server string, objectId PathObjectId, params *GetUserEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityAdminRightsRequest generates requests for GetUserEntityAdminRights
func NewGetUserEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetUserEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityConstrainedDelegationRightsRequest generates requests for GetUserEntityConstrainedDelegationRights
func NewGetUserEntityConstrainedDelegationRightsRequest(server string, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/constrained-delegation-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityControllablesRequest generates requests for GetUserEntityControllables
func NewGetUserEntityControllablesRequest(server string, objectId PathObjectId, params *GetUserEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityControllersRequest generates requests for GetUserEntityControllers
func NewGetUserEntityControllersRequest(server string, objectId PathObjectId, params *GetUserEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityDcomRightsRequest generates requests for GetUserEntityDcomRights
func NewGetUserEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetUserEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityMembershipRequest generates requests for GetUserEntityMembership
func NewGetUserEntityMembershipRequest(server string, objectId PathObjectId, params *GetUserEntityMembershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityPsRemoteRightsRequest generates requests for GetUserEntityPsRemoteRights
func NewGetUserEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityRdpRightsRequest generates requests for GetUserEntityRdpRights
func NewGetUserEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetUserEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntitySessionsRequest generates requests for GetUserEntitySessions
func NewGetUserEntitySessionsRequest(server string, objectId PathObjectId, params *GetUserEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntitySqlAdminRightsRequest generates requests for GetUserEntitySqlAdminRights
func NewGetUserEntitySqlAdminRightsRequest(server string, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/sql-admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiVersionRequest generates requests for GetApiVersion
func NewGetApiVersionRequest(server string, params *GetApiVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AcceptEulaWithResponse request
	AcceptEulaWithResponse(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*AcceptEulaResponse, error)

	// GetAdDomainDataQualityStatsWithResponse request
	GetAdDomainDataQualityStatsWithResponse(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAdDomainDataQualityStatsResponse, error)

	// GetAiaCaEntityWithResponse request
	GetAiaCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityResponse, error)

	// GetAiaCaEntityControllersWithResponse request
	GetAiaCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityControllersResponse, error)

	// StartAnalysisWithResponse request
	StartAnalysisWithResponse(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*StartAnalysisResponse, error)

	// ListAssetGroupsWithResponse request
	ListAssetGroupsWithResponse(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupsResponse, error)

	// CreateAssetGroupWithBodyWithResponse request with any body
	CreateAssetGroupWithBodyWithResponse(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error)

	CreateAssetGroupWithResponse(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error)

	// DeleteAssetGroupWithResponse request
	DeleteAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupResponse, error)

	// GetAssetGroupWithResponse request
	GetAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*GetAssetGroupResponse, error)

	// UpdateAssetGroupWithBodyWithResponse request with any body
	UpdateAssetGroupWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error)

	UpdateAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error)

	// ListAssetGroupCollectionsWithResponse request
	ListAssetGroupCollectionsWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupCollectionsResponse, error)

	// GetAssetGroupComboNodeWithResponse request
	GetAssetGroupComboNodeWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*GetAssetGroupComboNodeResponse, error)

	// GetAssetGroupCustomMemberCountWithResponse request
	GetAssetGroupCustomMemberCountWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*GetAssetGroupCustomMemberCountResponse, error)

	// ListAssetGroupMembersWithResponse request
	ListAssetGroupMembersWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMembersResponse, error)

	// ListAssetGroupMemberCountByKindWithResponse request
	ListAssetGroupMemberCountByKindWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMemberCountByKindResponse, error)

	// UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse request with any body
	UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error)

	UpdateAssetGroupSelectorsDeprecatedWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error)

	// UpdateAssetGroupSelectorsWithBodyWithResponse request with any body
	UpdateAssetGroupSelectorsWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error)

	UpdateAssetGroupSelectorsWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error)

	// DeleteAssetGroupSelectorWithResponse request
	DeleteAssetGroupSelectorWithResponse(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupSelectorResponse, error)

	// ListAttackPathTypesWithResponse request
	ListAttackPathTypesWithResponse(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*ListAttackPathTypesResponse, error)

	// StartAnalysisBheWithResponse request
	StartAnalysisBheWithResponse(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*StartAnalysisBheResponse, error)

	// UpdateAttackPathRiskWithBodyWithResponse request with any body
	UpdateAttackPathRiskWithBodyWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error)

	UpdateAttackPathRiskWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error)

	// ListAuditLogsWithResponse request
	ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)

	// GetAvailableDomainsWithResponse request
	GetAvailableDomainsWithResponse(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*GetAvailableDomainsResponse, error)

	// GetAzureTenantDataQualityStatsWithResponse request
	GetAzureTenantDataQualityStatsWithResponse(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAzureTenantDataQualityStatsResponse, error)

	// GetAzureEntityWithResponse request
	GetAzureEntityWithResponse(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*GetAzureEntityResponse, error)

	// GetEntityWithResponse request
	GetEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*GetEntityResponse, error)

	// GetEntityControllablesWithResponse request
	GetEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetEntityControllablesResponse, error)

	// GetEntityControllersWithResponse request
	GetEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEntityControllersResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// RemoveUserMfaWithBodyWithResponse request with any body
	RemoveUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error)

	RemoveUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error)

	// AddUserMfaWithBodyWithResponse request with any body
	AddUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error)

	AddUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error)

	// GetMfaActivationStatusWithResponse request
	GetMfaActivationStatusWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*GetMfaActivationStatusResponse, error)

	// ActivateUserMfaWithBodyWithResponse request with any body
	ActivateUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error)

	ActivateUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error)

	// DeleteUserSecretWithResponse request
	DeleteUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*DeleteUserSecretResponse, error)

	// CreateOrSetUserSecretWithBodyWithResponse request with any body
	CreateOrSetUserSecretWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error)

	CreateOrSetUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error)

	// GetCertTemplateEntityWithResponse request
	GetCertTemplateEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityResponse, error)

	// GetCertTemplateEntityControllersWithResponse request
	GetCertTemplateEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityControllersResponse, error)

	// DeleteBloodHoundDatabaseWithBodyWithResponse request with any body
	DeleteBloodHoundDatabaseWithBodyWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error)

	DeleteBloodHoundDatabaseWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error)

	// ListClientsWithResponse request
	ListClientsWithResponse(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*ListClientsResponse, error)

	// CreateClientWithBodyWithResponse request with any body
	CreateClientWithBodyWithResponse(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	CreateClientWithResponse(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	// LogClientErrorWithBodyWithResponse request with any body
	LogClientErrorWithBodyWithResponse(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error)

	LogClientErrorWithResponse(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error)

	// UpdateClientInfoWithBodyWithResponse request with any body
	UpdateClientInfoWithBodyWithResponse(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error)

	UpdateClientInfoWithResponse(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error)

	// DeleteClientWithResponse request
	DeleteClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*DeleteClientResponse, error)

	// GetClientWithResponse request
	GetClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error)

	// UpdateClientWithBodyWithResponse request with any body
	UpdateClientWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error)

	UpdateClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error)

	// ListClientCompletedJobsWithResponse request
	ListClientCompletedJobsWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListClientCompletedJobsResponse, error)

	// ListClientCompletedTasksWithResponse request
	ListClientCompletedTasksWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*ListClientCompletedTasksResponse, error)

	// CreateClientScheduledJobWithBodyWithResponse request with any body
	CreateClientScheduledJobWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error)

	CreateClientScheduledJobWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error)

	// CreateClientScheduledTaskWithBodyWithResponse request with any body
	CreateClientScheduledTaskWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error)

	CreateClientScheduledTaskWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error)

	// ReplaceClientTokenWithResponse request
	ReplaceClientTokenWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*ReplaceClientTokenResponse, error)

	// GetCollectorManifestWithResponse request
	GetCollectorManifestWithResponse(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*GetCollectorManifestResponse, error)

	// DownloadCollectorWithResponse request
	DownloadCollectorWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*DownloadCollectorResponse, error)

	// GetCollectorChecksumWithResponse request
	GetCollectorChecksumWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*GetCollectorChecksumResponse, error)

	// GetCompletenessStatsWithResponse request
	GetCompletenessStatsWithResponse(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*GetCompletenessStatsResponse, error)

	// GetComputerEntityWithResponse request
	GetComputerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*GetComputerEntityResponse, error)

	// GetComputerEntityAdminRightsWithResponse request
	GetComputerEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminRightsResponse, error)

	// GetComputerEntityAdminsWithResponse request
	GetComputerEntityAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminsResponse, error)

	// GetComputerEntityConstrainedDelegationRightsWithResponse request
	GetComputerEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedDelegationRightsResponse, error)

	// GetComputerEntityConstrainedUsersWithResponse request
	GetComputerEntityConstrainedUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedUsersResponse, error)

	// GetComputerEntityControllablesWithResponse request
	GetComputerEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllablesResponse, error)

	// GetComputerEntityControllersWithResponse request
	GetComputerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllersResponse, error)

	// GetComputerEntityDcomRightsWithResponse request
	GetComputerEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomRightsResponse, error)

	// GetComputerEntityDcomUsersWithResponse request
	GetComputerEntityDcomUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomUsersResponse, error)

	// GetComputerEntityGroupMembershipWithResponse request
	GetComputerEntityGroupMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*GetComputerEntityGroupMembershipResponse, error)

	// GetComputerEntityPsRemoteRightsWithResponse request
	GetComputerEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteRightsResponse, error)

	// GetComputerEntityPsRemoteUsersWithResponse request
	GetComputerEntityPsRemoteUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteUsersResponse, error)

	// GetComputerEntityRdpRightsWithResponse request
	GetComputerEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpRightsResponse, error)

	// GetComputerEntityRdpUsersWithResponse request
	GetComputerEntityRdpUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpUsersResponse, error)

	// GetComputerEntitySessionsWithResponse request
	GetComputerEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySessionsResponse, error)

	// GetComputerEntitySqlAdminsWithResponse request
	GetComputerEntitySqlAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySqlAdminsResponse, error)

	// ListAppConfigParamsWithResponse request
	ListAppConfigParamsWithResponse(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*ListAppConfigParamsResponse, error)

	// SetAppConfigParamWithBodyWithResponse request with any body
	SetAppConfigParamWithBodyWithResponse(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error)

	SetAppConfigParamWithResponse(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error)

	// GetContainerEntityWithResponse request
	GetContainerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*GetContainerEntityResponse, error)

	// GetContainerEntityControllersWithResponse request
	GetContainerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetContainerEntityControllersResponse, error)

	// GetDatapipeStatusWithResponse request
	GetDatapipeStatusWithResponse(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*GetDatapipeStatusResponse, error)

	// ExportAttackPathFindingsWithResponse request
	ExportAttackPathFindingsWithResponse(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*ExportAttackPathFindingsResponse, error)

	// ListAvailableAttackPathTypesForDomainWithResponse request
	ListAvailableAttackPathTypesForDomainWithResponse(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*ListAvailableAttackPathTypesForDomainResponse, error)

	// ListDomainAttackPathsDetailsWithResponse request
	ListDomainAttackPathsDetailsWithResponse(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*ListDomainAttackPathsDetailsResponse, error)

	// ListAttackPathSparklineValuesWithResponse request
	ListAttackPathSparklineValuesWithResponse(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*ListAttackPathSparklineValuesResponse, error)

	// GetDomainEntityWithResponse request
	GetDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*GetDomainEntityResponse, error)

	// UpdateDomainEntityWithBodyWithResponse request with any body
	UpdateDomainEntityWithBodyWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error)

	UpdateDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error)

	// GetDomainEntityComputersWithResponse request
	GetDomainEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityComputersResponse, error)

	// GetDomainEntityControllersWithResponse request
	GetDomainEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityControllersResponse, error)

	// GetDomainEntityDcSyncersWithResponse request
	GetDomainEntityDcSyncersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityDcSyncersResponse, error)

	// GetDomainEntityForeignAdminsWithResponse request
	GetDomainEntityForeignAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignAdminsResponse, error)

	// GetDomainEntityForeignGpoControllersWithResponse request
	GetDomainEntityForeignGpoControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGpoControllersResponse, error)

	// GetDomainEntityForeignGroupsWithResponse request
	GetDomainEntityForeignGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGroupsResponse, error)

	// GetDomainEntityForeignUsersWithResponse request
	GetDomainEntityForeignUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignUsersResponse, error)

	// GetDomainEntityGposWithResponse request
	GetDomainEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGposResponse, error)

	// GetDomainEntityGroupsWithResponse request
	GetDomainEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGroupsResponse, error)

	// GetDomainEntityInboundTrustsWithResponse request
	GetDomainEntityInboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityInboundTrustsResponse, error)

	// GetDomainEntityLinkedGposWithResponse request
	GetDomainEntityLinkedGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityLinkedGposResponse, error)

	// GetDomainEntityOusWithResponse request
	GetDomainEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOusResponse, error)

	// GetDomainEntityOutboundTrustsWithResponse request
	GetDomainEntityOutboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOutboundTrustsResponse, error)

	// GetDomainEntityUsersWithResponse request
	GetDomainEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityUsersResponse, error)

	// GetEnterpriseCaEntityWithResponse request
	GetEnterpriseCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityResponse, error)

	// GetEnterpriseCaEntityControllersWithResponse request
	GetEnterpriseCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityControllersResponse, error)

	// ListClientSchedulesWithResponse request
	ListClientSchedulesWithResponse(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*ListClientSchedulesResponse, error)

	// CreateClientScheduleWithBodyWithResponse request with any body
	CreateClientScheduleWithBodyWithResponse(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error)

	CreateClientScheduleWithResponse(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error)

	// DeleteClientEventWithResponse request
	DeleteClientEventWithResponse(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*DeleteClientEventResponse, error)

	// GetClientScheduleWithResponse request
	GetClientScheduleWithResponse(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*GetClientScheduleResponse, error)

	// UpdateClientEventWithBodyWithResponse request with any body
	UpdateClientEventWithBodyWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error)

	UpdateClientEventWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error)

	// ListFeatureFlagsWithResponse request
	ListFeatureFlagsWithResponse(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*ListFeatureFlagsResponse, error)

	// ToggleFeatureFlagWithResponse request
	ToggleFeatureFlagWithResponse(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*ToggleFeatureFlagResponse, error)

	// ListFileUploadJobsWithResponse request
	ListFileUploadJobsWithResponse(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*ListFileUploadJobsResponse, error)

	// ListAcceptedFileUploadTypesWithResponse request
	ListAcceptedFileUploadTypesWithResponse(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*ListAcceptedFileUploadTypesResponse, error)

	// CreateFileUploadJobWithResponse request
	CreateFileUploadJobWithResponse(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*CreateFileUploadJobResponse, error)

	// UploadFileToJobWithBodyWithResponse request with any body
	UploadFileToJobWithBodyWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error)

	UploadFileToJobWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error)

	// EndFileUploadJobWithResponse request
	EndFileUploadJobWithResponse(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*EndFileUploadJobResponse, error)

	// GetGpoEntityWithResponse request
	GetGpoEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*GetGpoEntityResponse, error)

	// GetGpoEntityComputersWithResponse request
	GetGpoEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityComputersResponse, error)

	// GetGpoEntityControllersWithResponse request
	GetGpoEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityControllersResponse, error)

	// GetGpoEntityOusWithResponse request
	GetGpoEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*GetGpoEntityOusResponse, error)

	// GetGpoEntityTierZeroWithResponse request
	GetGpoEntityTierZeroWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*GetGpoEntityTierZeroResponse, error)

	// GetGpoEntityUsersWithResponse request
	GetGpoEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityUsersResponse, error)

	// GetSearchResultWithResponse request
	GetSearchResultWithResponse(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*GetSearchResultResponse, error)

	// RunCypherQueryWithBodyWithResponse request with any body
	RunCypherQueryWithBodyWithResponse(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error)

	RunCypherQueryWithResponse(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error)

	// GetPathCompositionWithResponse request
	GetPathCompositionWithResponse(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*GetPathCompositionResponse, error)

	// GetShortestPathWithResponse request
	GetShortestPathWithResponse(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*GetShortestPathResponse, error)

	// GetGroupEntityWithResponse request
	GetGroupEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*GetGroupEntityResponse, error)

	// GetGroupEntityAdminRightsWithResponse request
	GetGroupEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityAdminRightsResponse, error)

	// GetGroupEntityControllablesWithResponse request
	GetGroupEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllablesResponse, error)

	// GetGroupEntityControllersWithResponse request
	GetGroupEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllersResponse, error)

	// GetGroupEntityDcomRightsWithResponse request
	GetGroupEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityDcomRightsResponse, error)

	// GetGroupEntityMembersWithResponse request
	GetGroupEntityMembersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembersResponse, error)

	// GetGroupEntityMembershipsWithResponse request
	GetGroupEntityMembershipsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembershipsResponse, error)

	// GetGroupEntityPsRemoteRightsWithResponse request
	GetGroupEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityPsRemoteRightsResponse, error)

	// GetGroupEntityRdpRightsWithResponse request
	GetGroupEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityRdpRightsResponse, error)

	// GetGroupEntitySessionsWithResponse request
	GetGroupEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetGroupEntitySessionsResponse, error)

	// IngestDataWithResponse request
	IngestDataWithResponse(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*IngestDataResponse, error)

	// GetClientJobsWithResponse request
	GetClientJobsWithResponse(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*GetClientJobsResponse, error)

	// ListAvailableClientJobsWithResponse request
	ListAvailableClientJobsWithResponse(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*ListAvailableClientJobsResponse, error)

	// GetClientCurrentJobWithResponse request
	GetClientCurrentJobWithResponse(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*GetClientCurrentJobResponse, error)

	// EndClientJobWithResponse request
	EndClientJobWithResponse(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*EndClientJobResponse, error)

	// ListClientFinishedJobsWithResponse request
	ListClientFinishedJobsWithResponse(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*ListClientFinishedJobsResponse, error)

	// StartClientJobWithBodyWithResponse request with any body
	StartClientJobWithBodyWithResponse(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error)

	StartClientJobWithResponse(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error)

	// GetClientJobWithResponse request
	GetClientJobWithResponse(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*GetClientJobResponse, error)

	// CancelClientJobWithResponse request
	CancelClientJobWithResponse(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*CancelClientJobResponse, error)

	// GetClientJobLogWithResponse request
	GetClientJobLogWithResponse(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*GetClientJobLogResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// GetLatestTierZeroComboNodeWithResponse request
	GetLatestTierZeroComboNodeWithResponse(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*GetLatestTierZeroComboNodeResponse, error)

	// GetComboTreeGraphWithResponse request
	GetComboTreeGraphWithResponse(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*GetComboTreeGraphResponse, error)

	// GetMetaEntityWithResponse request
	GetMetaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*GetMetaEntityResponse, error)

	// GetNtAuthStoreEntityWithResponse request
	GetNtAuthStoreEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityResponse, error)

	// GetNtAuthStoreEntityControllersWithResponse request
	GetNtAuthStoreEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityControllersResponse, error)

	// GetOuEntityWithResponse request
	GetOuEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*GetOuEntityResponse, error)

	// GetOuEntityComputersWithResponse request
	GetOuEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*GetOuEntityComputersResponse, error)

	// GetOuEntityGposWithResponse request
	GetOuEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*GetOuEntityGposResponse, error)

	// GetOuEntityGroupsWithResponse request
	GetOuEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetOuEntityGroupsResponse, error)

	// GetOuEntityUsersWithResponse request
	GetOuEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*GetOuEntityUsersResponse, error)

	// PathfindingWithResponse request
	PathfindingWithResponse(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*PathfindingResponse, error)

	// ListPermissionsWithResponse request
	ListPermissionsWithResponse(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*ListPermissionsResponse, error)

	// GetPermissionWithResponse request
	GetPermissionWithResponse(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*GetPermissionResponse, error)

	// GetPlatformDataQualityAggregateWithResponse request
	GetPlatformDataQualityAggregateWithResponse(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*GetPlatformDataQualityAggregateResponse, error)

	// GetPostureStatsWithResponse request
	GetPostureStatsWithResponse(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*GetPostureStatsResponse, error)

	// ListRolesWithResponse request
	ListRolesWithResponse(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// GetRootCaEntityWithResponse request
	GetRootCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityResponse, error)

	// GetRootCaEntityControllersWithResponse request
	GetRootCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityControllersResponse, error)

	// ListSamlProvidersWithResponse request
	ListSamlProvidersWithResponse(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*ListSamlProvidersResponse, error)

	// CreateSamlProviderWithBodyWithResponse request with any body
	CreateSamlProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSamlProviderResponse, error)

	// DeleteSamlProviderWithResponse request
	DeleteSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*DeleteSamlProviderResponse, error)

	// GetSamlProviderWithResponse request
	GetSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*GetSamlProviderResponse, error)

	// GetSamlSignSignOnEndpointsWithResponse request
	GetSamlSignSignOnEndpointsWithResponse(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*GetSamlSignSignOnEndpointsResponse, error)

	// ListSavedQueriesWithResponse request
	ListSavedQueriesWithResponse(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*ListSavedQueriesResponse, error)

	// CreateSavedQueryWithBodyWithResponse request with any body
	CreateSavedQueryWithBodyWithResponse(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error)

	CreateSavedQueryWithResponse(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error)

	// DeleteSavedQueryWithResponse request
	DeleteSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*DeleteSavedQueryResponse, error)

	// UpdateSavedQueryWithBodyWithResponse request with any body
	UpdateSavedQueryWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error)

	UpdateSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error)

	// DeleteSavedQueryPermissionsWithBodyWithResponse request with any body
	DeleteSavedQueryPermissionsWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error)

	DeleteSavedQueryPermissionsWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error)

	// ShareSavedQueryWithBodyWithResponse request with any body
	ShareSavedQueryWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *ShareSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareSavedQueryResponse, error)

	ShareSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *ShareSavedQueryParams, body ShareSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareSavedQueryResponse, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// GetSelfWithResponse request
	GetSelfWithResponse(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*GetSelfResponse, error)

	// GetApiSpecWithResponse request
	GetApiSpecWithResponse(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*GetApiSpecResponse, error)

	// ListAuthTokensWithResponse request
	ListAuthTokensWithResponse(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*ListAuthTokensResponse, error)

	// CreateAuthTokenWithBodyWithResponse request with any body
	CreateAuthTokenWithBodyWithResponse(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error)

	CreateAuthTokenWithResponse(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error)

	// DeleteAuthTokenWithResponse request
	DeleteAuthTokenWithResponse(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*DeleteAuthTokenResponse, error)

	// GetUserEntityWithResponse request
	GetUserEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*GetUserEntityResponse, error)

	// GetUserEntityAdminRightsWithResponse request
	GetUserEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityAdminRightsResponse, error)

	// GetUserEntityConstrainedDelegationRightsWithResponse request
	GetUserEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityConstrainedDelegationRightsResponse, error)

	// GetUserEntityControllablesWithResponse request
	GetUserEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllablesResponse, error)

	// GetUserEntityControllersWithResponse request
	GetUserEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllersResponse, error)

	// GetUserEntityDcomRightsWithResponse request
	GetUserEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityDcomRightsResponse, error)

	// GetUserEntityMembershipWithResponse request
	GetUserEntityMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*GetUserEntityMembershipResponse, error)

	// GetUserEntityPsRemoteRightsWithResponse request
	GetUserEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityPsRemoteRightsResponse, error)

	// GetUserEntityRdpRightsWithResponse request
	GetUserEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityRdpRightsResponse, error)

	// GetUserEntitySessionsWithResponse request
	GetUserEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySessionsResponse, error)

	// GetUserEntitySqlAdminRightsWithResponse request
	GetUserEntitySqlAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySqlAdminRightsResponse, error)

	// GetApiVersionWithResponse request
	GetApiVersionWithResponse(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*GetApiVersionResponse, error)
}

type AcceptEulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AcceptEulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptEulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdDomainDataQualityStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                      `json:"count,omitempty"`
		Data  *[]ModelAdDataQualityStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAdDomainDataQualityStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdDomainDataQualityStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiaCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiaCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiaCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiaCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiaCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiaCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartAnalysisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r StartAnalysisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartAnalysisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AssetGroups *[]ModelAssetGroup `json:"asset_groups,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *ApiErrorWrapper
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelAssetGroupCollection `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupComboNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupComboNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupComboNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupCustomMemberCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CustomMemberCount *int `json:"custom_member_count,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupCustomMemberCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupCustomMemberCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int `json:"count,omitempty"`
		Data  *struct {
			Members *[]ModelAssetGroupMember `json:"members,omitempty"`
		} `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupMemberCountByKindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Counts     *map[string]int `json:"counts,omitempty"`
			TotalCount *int            `json:"total_count,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupMemberCountByKindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupMemberCountByKindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupSelectorsDeprecatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
			RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupSelectorsDeprecatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupSelectorsDeprecatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupSelectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
			RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupSelectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupSelectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetGroupSelectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *ApiErrorWrapper
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAssetGroupSelectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetGroupSelectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttackPathTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAttackPathTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttackPathTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartAnalysisBheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartAnalysisBheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartAnalysisBheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttackPathRiskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseFinding
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAttackPathRiskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttackPathRiskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Logs *[]ModelAuditLog `json:"logs,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelDomainSelector `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAvailableDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAzureTenantDataQualityStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                         `json:"count,omitempty"`
		Data  *[]ModelAzureDataQualityStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAzureTenantDataQualityStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAzureTenantDataQualityStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAzureEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAzureEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAzureEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Users *[]ModelUser `json:"users,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUser `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUser `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RemoveUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			QrCode     *string `json:"qr_code,omitempty"`
			TotpSecret *string `json:"totp_secret,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMfaActivationStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMfaActivationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMfaActivationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ActivateUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrSetUserSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateOrSetUserSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrSetUserSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertTemplateEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertTemplateEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertTemplateEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertTemplateEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertTemplateEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertTemplateEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBloodHoundDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBloodHoundDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBloodHoundDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                  `json:"count,omitempty"`
		Data  *[]ModelClientDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogClientErrorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LogClientErrorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogClientErrorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientCompletedTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientCompletedTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientCompletedTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduledJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduledJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduledJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduledTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduledTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduledTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceClientTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAuthToken `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ReplaceClientTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceClientTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelCollectorManifest `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCollectorManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadCollectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DownloadCollectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadCollectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorChecksumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCollectorChecksumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorChecksumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletenessStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]float64 `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCompletenessStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletenessStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityConstrainedDelegationRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityConstrainedDelegationRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityConstrainedDelegationRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityConstrainedUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityConstrainedUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityConstrainedUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityDcomUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityDcomUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityDcomUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityPsRemoteUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityPsRemoteUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityPsRemoteUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityRdpUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityRdpUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityRdpUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntitySqlAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntitySqlAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntitySqlAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppConfigParamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelAppConfigParam `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAppConfigParamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppConfigParamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAppConfigParamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Key   *string                 `json:"key,omitempty"`
			Value *map[string]interface{} `json:"value,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SetAppConfigParamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAppConfigParamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetContainerEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetContainerEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatapipeStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			LastCompleteAnalysisAt *time.Time          `json:"last_complete_analysis_at,omitempty"`
			Status                 *EnumDatapipeStatus `json:"status,omitempty"`
			UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetDatapipeStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatapipeStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportAttackPathFindingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportAttackPathFindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportAttackPathFindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableAttackPathTypesForDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAvailableAttackPathTypesForDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableAttackPathTypesForDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDomainAttackPathsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListDomainAttackPathsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDomainAttackPathsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttackPathSparklineValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelRiskCounts `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAttackPathSparklineValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttackPathSparklineValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDomainEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Collected *bool `json:"collected,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateDomainEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDomainEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityDcSyncersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityDcSyncersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityDcSyncersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignGpoControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignGpoControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignGpoControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityInboundTrustsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityInboundTrustsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityInboundTrustsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityLinkedGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityLinkedGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityLinkedGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityOusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityOusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityOusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityOutboundTrustsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityOutboundTrustsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityOutboundTrustsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnterpriseCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEnterpriseCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnterpriseCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnterpriseCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEnterpriseCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnterpriseCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                          `json:"count,omitempty"`
		Data  *[]ModelClientScheduleDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteClientEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFeatureFlagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelFeatureFlag `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFeatureFlagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFeatureFlagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleFeatureFlagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ToggleFeatureFlagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleFeatureFlagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFileUploadJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                  `json:"count,omitempty"`
		Data  *[]ModelFileUploadJob `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFileUploadJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFileUploadJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAcceptedFileUploadTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r ListAcceptedFileUploadTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAcceptedFileUploadTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFileUploadJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *ModelFileUploadJob `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateFileUploadJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFileUploadJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFileToJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UploadFileToJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFileToJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndFileUploadJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EndFileUploadJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndFileUploadJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityOusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityOusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityOusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityTierZeroResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityTierZeroResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityTierZeroResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSearchResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunCypherQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RunCypherQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunCypherQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPathCompositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPathCompositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPathCompositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShortestPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetShortestPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShortestPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IngestDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r IngestDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IngestDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableClientJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAvailableClientJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableClientJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientCurrentJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientCurrentJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientCurrentJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EndClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientFinishedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientFinishedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientFinishedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CancelClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Log *string `json:"log,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AuthExpired  *bool               `json:"auth_expired,omitempty"`
			SessionToken *string             `json:"session_token,omitempty"`
			UserId       *openapi_types.UUID `json:"user_id,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestTierZeroComboNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetLatestTierZeroComboNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestTierZeroComboNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComboTreeGraphResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComboTreeGraphResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComboTreeGraphResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Props *map[string]map[string]interface{} `json:"props,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMetaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNtAuthStoreEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNtAuthStoreEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNtAuthStoreEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNtAuthStoreEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNtAuthStoreEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNtAuthStoreEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PathfindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PathfindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PathfindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Permissions *[]ModelPermission `json:"permissions,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelPermission `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformDataQualityAggregateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseDataQualityPlatformAggregate
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPlatformDataQualityAggregateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformDataQualityAggregateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostureStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                    `json:"count,omitempty"`
		Data  *[]ModelRiskPostureStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPostureStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostureStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Roles *[]ModelRole `json:"roles,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelRole `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRootCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRootCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSamlProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			SamlProviders *[]ModelSamlProvider `json:"saml_providers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSamlProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSamlProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSamlProvider `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AffectedUser *[]ModelUser `json:"affected_user,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON409 *ApiErrorWrapper
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSamlProvider `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlSignSignOnEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Endpoints *[]ModelSamlSignOnEndpoint `json:"endpoints,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSamlSignSignOnEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlSignSignOnEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSavedQueriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int               `json:"count,omitempty"`
		Data  *[]ModelSavedQuery `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSavedQueriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSavedQueriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *ModelSavedQuery `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSavedQuery `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSavedQueryPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSavedQueryPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSavedQueryPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *[]ModelSavedQueriesPermissions `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShareSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelSearchResult `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseAuthenticatedRequester
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetSelfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML200      *openapi_types.File
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetApiSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuthTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Tokens *[]ModelAuthToken `json:"tokens,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAuthTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuthTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAuthToken `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityConstrainedDelegationRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityConstrainedDelegationRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityConstrainedDelegationRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntitySqlAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntitySqlAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntitySqlAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			API *struct {
				CurrentVersion    *string `json:"current_version,omitempty"`
				DeprecatedVersion *string `json:"deprecated_version,omitempty"`
			} `json:"API,omitempty"`
			ServerVersion *string `json:"server_version,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetApiVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AcceptEulaWithResponse request returning *AcceptEulaResponse
func (c *ClientWithResponses) AcceptEulaWithResponse(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*AcceptEulaResponse, error) {
	rsp, err := c.AcceptEula(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEulaResponse(rsp)
}

// GetAdDomainDataQualityStatsWithResponse request returning *GetAdDomainDataQualityStatsResponse
func (c *ClientWithResponses) GetAdDomainDataQualityStatsWithResponse(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAdDomainDataQualityStatsResponse, error) {
	rsp, err := c.GetAdDomainDataQualityStats(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdDomainDataQualityStatsResponse(rsp)
}

// GetAiaCaEntityWithResponse request returning *GetAiaCaEntityResponse
func (c *ClientWithResponses) GetAiaCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityResponse, error) {
	rsp, err := c.GetAiaCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiaCaEntityResponse(rsp)
}

// GetAiaCaEntityControllersWithResponse request returning *GetAiaCaEntityControllersResponse
func (c *ClientWithResponses) GetAiaCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityControllersResponse, error) {
	rsp, err := c.GetAiaCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiaCaEntityControllersResponse(rsp)
}

// StartAnalysisWithResponse request returning *StartAnalysisResponse
func (c *ClientWithResponses) StartAnalysisWithResponse(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*StartAnalysisResponse, error) {
	rsp, err := c.StartAnalysis(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartAnalysisResponse(rsp)
}

// ListAssetGroupsWithResponse request returning *ListAssetGroupsResponse
func (c *ClientWithResponses) ListAssetGroupsWithResponse(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupsResponse, error) {
	rsp, err := c.ListAssetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupsResponse(rsp)
}

// CreateAssetGroupWithBodyWithResponse request with arbitrary body returning *CreateAssetGroupResponse
func (c *ClientWithResponses) CreateAssetGroupWithBodyWithResponse(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error) {
	rsp, err := c.CreateAssetGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateAssetGroupWithResponse(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error) {
	rsp, err := c.CreateAssetGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetGroupResponse(rsp)
}

// DeleteAssetGroupWithResponse request returning *DeleteAssetGroupResponse
func (c *ClientWithResponses) DeleteAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupResponse, error) {
	rsp, err := c.DeleteAssetGroup(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetGroupResponse(rsp)
}

// GetAssetGroupWithResponse request returning *GetAssetGroupResponse
func (c *ClientWithResponses) GetAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*GetAssetGroupResponse, error) {
	rsp, err := c.GetAssetGroup(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupResponse(rsp)
}

// UpdateAssetGroupWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupResponse
func (c *ClientWithResponses) UpdateAssetGroupWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error) {
	rsp, err := c.UpdateAssetGroupWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error) {
	rsp, err := c.UpdateAssetGroup(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupResponse(rsp)
}

// ListAssetGroupCollectionsWithResponse request returning *ListAssetGroupCollectionsResponse
func (c *ClientWithResponses) ListAssetGroupCollectionsWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupCollectionsResponse, error) {
	rsp, err := c.ListAssetGroupCollections(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupCollectionsResponse(rsp)
}

// GetAssetGroupComboNodeWithResponse request returning *GetAssetGroupComboNodeResponse
func (c *ClientWithResponses) GetAssetGroupComboNodeWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*GetAssetGroupComboNodeResponse, error) {
	rsp, err := c.GetAssetGroupComboNode(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupComboNodeResponse(rsp)
}

// GetAssetGroupCustomMemberCountWithResponse request returning *GetAssetGroupCustomMemberCountResponse
func (c *ClientWithResponses) GetAssetGroupCustomMemberCountWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*GetAssetGroupCustomMemberCountResponse, error) {
	rsp, err := c.GetAssetGroupCustomMemberCount(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupCustomMemberCountResponse(rsp)
}

// ListAssetGroupMembersWithResponse request returning *ListAssetGroupMembersResponse
func (c *ClientWithResponses) ListAssetGroupMembersWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMembersResponse, error) {
	rsp, err := c.ListAssetGroupMembers(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupMembersResponse(rsp)
}

// ListAssetGroupMemberCountByKindWithResponse request returning *ListAssetGroupMemberCountByKindResponse
func (c *ClientWithResponses) ListAssetGroupMemberCountByKindWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMemberCountByKindResponse, error) {
	rsp, err := c.ListAssetGroupMemberCountByKind(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupMemberCountByKindResponse(rsp)
}

// UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupSelectorsDeprecatedResponse
func (c *ClientWithResponses) UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsDeprecatedWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupSelectorsDeprecatedWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsDeprecated(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp)
}

// UpdateAssetGroupSelectorsWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupSelectorsResponse
func (c *ClientWithResponses) UpdateAssetGroupSelectorsWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupSelectorsWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectors(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsResponse(rsp)
}

// DeleteAssetGroupSelectorWithResponse request returning *DeleteAssetGroupSelectorResponse
func (c *ClientWithResponses) DeleteAssetGroupSelectorWithResponse(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupSelectorResponse, error) {
	rsp, err := c.DeleteAssetGroupSelector(ctx, assetGroupId, assetGroupSelectorId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetGroupSelectorResponse(rsp)
}

// ListAttackPathTypesWithResponse request returning *ListAttackPathTypesResponse
func (c *ClientWithResponses) ListAttackPathTypesWithResponse(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*ListAttackPathTypesResponse, error) {
	rsp, err := c.ListAttackPathTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttackPathTypesResponse(rsp)
}

// StartAnalysisBheWithResponse request returning *StartAnalysisBheResponse
func (c *ClientWithResponses) StartAnalysisBheWithResponse(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*StartAnalysisBheResponse, error) {
	rsp, err := c.StartAnalysisBhe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartAnalysisBheResponse(rsp)
}

// UpdateAttackPathRiskWithBodyWithResponse request with arbitrary body returning *UpdateAttackPathRiskResponse
func (c *ClientWithResponses) UpdateAttackPathRiskWithBodyWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error) {
	rsp, err := c.UpdateAttackPathRiskWithBody(ctx, attackPathId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttackPathRiskResponse(rsp)
}

func (c *ClientWithResponses) UpdateAttackPathRiskWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error) {
	rsp, err := c.UpdateAttackPathRisk(ctx, attackPathId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttackPathRiskResponse(rsp)
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// GetAvailableDomainsWithResponse request returning *GetAvailableDomainsResponse
func (c *ClientWithResponses) GetAvailableDomainsWithResponse(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*GetAvailableDomainsResponse, error) {
	rsp, err := c.GetAvailableDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableDomainsResponse(rsp)
}

// GetAzureTenantDataQualityStatsWithResponse request returning *GetAzureTenantDataQualityStatsResponse
func (c *ClientWithResponses) GetAzureTenantDataQualityStatsWithResponse(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAzureTenantDataQualityStatsResponse, error) {
	rsp, err := c.GetAzureTenantDataQualityStats(ctx, tenantId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAzureTenantDataQualityStatsResponse(rsp)
}

// GetAzureEntityWithResponse request returning *GetAzureEntityResponse
func (c *ClientWithResponses) GetAzureEntityWithResponse(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*GetAzureEntityResponse, error) {
	rsp, err := c.GetAzureEntity(ctx, entityType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAzureEntityResponse(rsp)
}

// GetEntityWithResponse request returning *GetEntityResponse
func (c *ClientWithResponses) GetEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*GetEntityResponse, error) {
	rsp, err := c.GetEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityResponse(rsp)
}

// GetEntityControllablesWithResponse request returning *GetEntityControllablesResponse
func (c *ClientWithResponses) GetEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetEntityControllablesResponse, error) {
	rsp, err := c.GetEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityControllablesResponse(rsp)
}

// GetEntityControllersWithResponse request returning *GetEntityControllersResponse
func (c *ClientWithResponses) GetEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEntityControllersResponse, error) {
	rsp, err := c.GetEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityControllersResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// RemoveUserMfaWithBodyWithResponse request with arbitrary body returning *RemoveUserMfaResponse
func (c *ClientWithResponses) RemoveUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error) {
	rsp, err := c.RemoveUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserMfaResponse(rsp)
}

func (c *ClientWithResponses) RemoveUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error) {
	rsp, err := c.RemoveUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserMfaResponse(rsp)
}

// AddUserMfaWithBodyWithResponse request with arbitrary body returning *AddUserMfaResponse
func (c *ClientWithResponses) AddUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error) {
	rsp, err := c.AddUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserMfaResponse(rsp)
}

func (c *ClientWithResponses) AddUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error) {
	rsp, err := c.AddUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserMfaResponse(rsp)
}

// GetMfaActivationStatusWithResponse request returning *GetMfaActivationStatusResponse
func (c *ClientWithResponses) GetMfaActivationStatusWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*GetMfaActivationStatusResponse, error) {
	rsp, err := c.GetMfaActivationStatus(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMfaActivationStatusResponse(rsp)
}

// ActivateUserMfaWithBodyWithResponse request with arbitrary body returning *ActivateUserMfaResponse
func (c *ClientWithResponses) ActivateUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error) {
	rsp, err := c.ActivateUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateUserMfaResponse(rsp)
}

func (c *ClientWithResponses) ActivateUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error) {
	rsp, err := c.ActivateUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateUserMfaResponse(rsp)
}

// DeleteUserSecretWithResponse request returning *DeleteUserSecretResponse
func (c *ClientWithResponses) DeleteUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*DeleteUserSecretResponse, error) {
	rsp, err := c.DeleteUserSecret(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserSecretResponse(rsp)
}

// CreateOrSetUserSecretWithBodyWithResponse request with arbitrary body returning *CreateOrSetUserSecretResponse
func (c *ClientWithResponses) CreateOrSetUserSecretWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error) {
	rsp, err := c.CreateOrSetUserSecretWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrSetUserSecretResponse(rsp)
}

func (c *ClientWithResponses) CreateOrSetUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error) {
	rsp, err := c.CreateOrSetUserSecret(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrSetUserSecretResponse(rsp)
}

// GetCertTemplateEntityWithResponse request returning *GetCertTemplateEntityResponse
func (c *ClientWithResponses) GetCertTemplateEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityResponse, error) {
	rsp, err := c.GetCertTemplateEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertTemplateEntityResponse(rsp)
}

// GetCertTemplateEntityControllersWithResponse request returning *GetCertTemplateEntityControllersResponse
func (c *ClientWithResponses) GetCertTemplateEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityControllersResponse, error) {
	rsp, err := c.GetCertTemplateEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertTemplateEntityControllersResponse(rsp)
}

// DeleteBloodHoundDatabaseWithBodyWithResponse request with arbitrary body returning *DeleteBloodHoundDatabaseResponse
func (c *ClientWithResponses) DeleteBloodHoundDatabaseWithBodyWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error) {
	rsp, err := c.DeleteBloodHoundDatabaseWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBloodHoundDatabaseResponse(rsp)
}

func (c *ClientWithResponses) DeleteBloodHoundDatabaseWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error) {
	rsp, err := c.DeleteBloodHoundDatabase(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBloodHoundDatabaseResponse(rsp)
}

// ListClientsWithResponse request returning *ListClientsResponse
func (c *ClientWithResponses) ListClientsWithResponse(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*ListClientsResponse, error) {
	rsp, err := c.ListClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientsResponse(rsp)
}

// CreateClientWithBodyWithResponse request with arbitrary body returning *CreateClientResponse
func (c *ClientWithResponses) CreateClientWithBodyWithResponse(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClientWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

func (c *ClientWithResponses) CreateClientWithResponse(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClient(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

// LogClientErrorWithBodyWithResponse request with arbitrary body returning *LogClientErrorResponse
func (c *ClientWithResponses) LogClientErrorWithBodyWithResponse(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error) {
	rsp, err := c.LogClientErrorWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogClientErrorResponse(rsp)
}

func (c *ClientWithResponses) LogClientErrorWithResponse(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error) {
	rsp, err := c.LogClientError(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogClientErrorResponse(rsp)
}

// UpdateClientInfoWithBodyWithResponse request with arbitrary body returning *UpdateClientInfoResponse
func (c *ClientWithResponses) UpdateClientInfoWithBodyWithResponse(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error) {
	rsp, err := c.UpdateClientInfoWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientInfoResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientInfoWithResponse(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error) {
	rsp, err := c.UpdateClientInfo(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientInfoResponse(rsp)
}

// DeleteClientWithResponse request returning *DeleteClientResponse
func (c *ClientWithResponses) DeleteClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*DeleteClientResponse, error) {
	rsp, err := c.DeleteClient(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientResponse(rsp)
}

// GetClientWithResponse request returning *GetClientResponse
func (c *ClientWithResponses) GetClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error) {
	rsp, err := c.GetClient(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientResponse(rsp)
}

// UpdateClientWithBodyWithResponse request with arbitrary body returning *UpdateClientResponse
func (c *ClientWithResponses) UpdateClientWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error) {
	rsp, err := c.UpdateClientWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error) {
	rsp, err := c.UpdateClient(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientResponse(rsp)
}

// ListClientCompletedJobsWithResponse request returning *ListClientCompletedJobsResponse
func (c *ClientWithResponses) ListClientCompletedJobsWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListClientCompletedJobsResponse, error) {
	rsp, err := c.ListClientCompletedJobs(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientCompletedJobsResponse(rsp)
}

// ListClientCompletedTasksWithResponse request returning *ListClientCompletedTasksResponse
func (c *ClientWithResponses) ListClientCompletedTasksWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*ListClientCompletedTasksResponse, error) {
	rsp, err := c.ListClientCompletedTasks(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientCompletedTasksResponse(rsp)
}

// CreateClientScheduledJobWithBodyWithResponse request with arbitrary body returning *CreateClientScheduledJobResponse
func (c *ClientWithResponses) CreateClientScheduledJobWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error) {
	rsp, err := c.CreateClientScheduledJobWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledJobResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduledJobWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error) {
	rsp, err := c.CreateClientScheduledJob(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledJobResponse(rsp)
}

// CreateClientScheduledTaskWithBodyWithResponse request with arbitrary body returning *CreateClientScheduledTaskResponse
func (c *ClientWithResponses) CreateClientScheduledTaskWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error) {
	rsp, err := c.CreateClientScheduledTaskWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledTaskResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduledTaskWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error) {
	rsp, err := c.CreateClientScheduledTask(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledTaskResponse(rsp)
}

// ReplaceClientTokenWithResponse request returning *ReplaceClientTokenResponse
func (c *ClientWithResponses) ReplaceClientTokenWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*ReplaceClientTokenResponse, error) {
	rsp, err := c.ReplaceClientToken(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceClientTokenResponse(rsp)
}

// GetCollectorManifestWithResponse request returning *GetCollectorManifestResponse
func (c *ClientWithResponses) GetCollectorManifestWithResponse(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*GetCollectorManifestResponse, error) {
	rsp, err := c.GetCollectorManifest(ctx, collectorType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorManifestResponse(rsp)
}

// DownloadCollectorWithResponse request returning *DownloadCollectorResponse
func (c *ClientWithResponses) DownloadCollectorWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*DownloadCollectorResponse, error) {
	rsp, err := c.DownloadCollector(ctx, collectorType, releaseTag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadCollectorResponse(rsp)
}

// GetCollectorChecksumWithResponse request returning *GetCollectorChecksumResponse
func (c *ClientWithResponses) GetCollectorChecksumWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*GetCollectorChecksumResponse, error) {
	rsp, err := c.GetCollectorChecksum(ctx, collectorType, releaseTag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorChecksumResponse(rsp)
}

// GetCompletenessStatsWithResponse request returning *GetCompletenessStatsResponse
func (c *ClientWithResponses) GetCompletenessStatsWithResponse(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*GetCompletenessStatsResponse, error) {
	rsp, err := c.GetCompletenessStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletenessStatsResponse(rsp)
}

// GetComputerEntityWithResponse request returning *GetComputerEntityResponse
func (c *ClientWithResponses) GetComputerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*GetComputerEntityResponse, error) {
	rsp, err := c.GetComputerEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityResponse(rsp)
}

// GetComputerEntityAdminRightsWithResponse request returning *GetComputerEntityAdminRightsResponse
func (c *ClientWithResponses) GetComputerEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminRightsResponse, error) {
	rsp, err := c.GetComputerEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityAdminRightsResponse(rsp)
}

// GetComputerEntityAdminsWithResponse request returning *GetComputerEntityAdminsResponse
func (c *ClientWithResponses) GetComputerEntityAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminsResponse, error) {
	rsp, err := c.GetComputerEntityAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityAdminsResponse(rsp)
}

// GetComputerEntityConstrainedDelegationRightsWithResponse request returning *GetComputerEntityConstrainedDelegationRightsResponse
func (c *ClientWithResponses) GetComputerEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedDelegationRightsResponse, error) {
	rsp, err := c.GetComputerEntityConstrainedDelegationRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityConstrainedDelegationRightsResponse(rsp)
}

// GetComputerEntityConstrainedUsersWithResponse request returning *GetComputerEntityConstrainedUsersResponse
func (c *ClientWithResponses) GetComputerEntityConstrainedUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedUsersResponse, error) {
	rsp, err := c.GetComputerEntityConstrainedUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityConstrainedUsersResponse(rsp)
}

// GetComputerEntityControllablesWithResponse request returning *GetComputerEntityControllablesResponse
func (c *ClientWithResponses) GetComputerEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllablesResponse, error) {
	rsp, err := c.GetComputerEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityControllablesResponse(rsp)
}

// GetComputerEntityControllersWithResponse request returning *GetComputerEntityControllersResponse
func (c *ClientWithResponses) GetComputerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllersResponse, error) {
	rsp, err := c.GetComputerEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityControllersResponse(rsp)
}

// GetComputerEntityDcomRightsWithResponse request returning *GetComputerEntityDcomRightsResponse
func (c *ClientWithResponses) GetComputerEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomRightsResponse, error) {
	rsp, err := c.GetComputerEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityDcomRightsResponse(rsp)
}

// GetComputerEntityDcomUsersWithResponse request returning *GetComputerEntityDcomUsersResponse
func (c *ClientWithResponses) GetComputerEntityDcomUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomUsersResponse, error) {
	rsp, err := c.GetComputerEntityDcomUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityDcomUsersResponse(rsp)
}

// GetComputerEntityGroupMembershipWithResponse request returning *GetComputerEntityGroupMembershipResponse
func (c *ClientWithResponses) GetComputerEntityGroupMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*GetComputerEntityGroupMembershipResponse, error) {
	rsp, err := c.GetComputerEntityGroupMembership(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityGroupMembershipResponse(rsp)
}

// GetComputerEntityPsRemoteRightsWithResponse request returning *GetComputerEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetComputerEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetComputerEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityPsRemoteRightsResponse(rsp)
}

// GetComputerEntityPsRemoteUsersWithResponse request returning *GetComputerEntityPsRemoteUsersResponse
func (c *ClientWithResponses) GetComputerEntityPsRemoteUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteUsersResponse, error) {
	rsp, err := c.GetComputerEntityPsRemoteUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityPsRemoteUsersResponse(rsp)
}

// GetComputerEntityRdpRightsWithResponse request returning *GetComputerEntityRdpRightsResponse
func (c *ClientWithResponses) GetComputerEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpRightsResponse, error) {
	rsp, err := c.GetComputerEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityRdpRightsResponse(rsp)
}

// GetComputerEntityRdpUsersWithResponse request returning *GetComputerEntityRdpUsersResponse
func (c *ClientWithResponses) GetComputerEntityRdpUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpUsersResponse, error) {
	rsp, err := c.GetComputerEntityRdpUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityRdpUsersResponse(rsp)
}

// GetComputerEntitySessionsWithResponse request returning *GetComputerEntitySessionsResponse
func (c *ClientWithResponses) GetComputerEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySessionsResponse, error) {
	rsp, err := c.GetComputerEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntitySessionsResponse(rsp)
}

// GetComputerEntitySqlAdminsWithResponse request returning *GetComputerEntitySqlAdminsResponse
func (c *ClientWithResponses) GetComputerEntitySqlAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySqlAdminsResponse, error) {
	rsp, err := c.GetComputerEntitySqlAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntitySqlAdminsResponse(rsp)
}

// ListAppConfigParamsWithResponse request returning *ListAppConfigParamsResponse
func (c *ClientWithResponses) ListAppConfigParamsWithResponse(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*ListAppConfigParamsResponse, error) {
	rsp, err := c.ListAppConfigParams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppConfigParamsResponse(rsp)
}

// SetAppConfigParamWithBodyWithResponse request with arbitrary body returning *SetAppConfigParamResponse
func (c *ClientWithResponses) SetAppConfigParamWithBodyWithResponse(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error) {
	rsp, err := c.SetAppConfigParamWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppConfigParamResponse(rsp)
}

func (c *ClientWithResponses) SetAppConfigParamWithResponse(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error) {
	rsp, err := c.SetAppConfigParam(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppConfigParamResponse(rsp)
}

// GetContainerEntityWithResponse request returning *GetContainerEntityResponse
func (c *ClientWithResponses) GetContainerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*GetContainerEntityResponse, error) {
	rsp, err := c.GetContainerEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerEntityResponse(rsp)
}

// GetContainerEntityControllersWithResponse request returning *GetContainerEntityControllersResponse
func (c *ClientWithResponses) GetContainerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetContainerEntityControllersResponse, error) {
	rsp, err := c.GetContainerEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerEntityControllersResponse(rsp)
}

// GetDatapipeStatusWithResponse request returning *GetDatapipeStatusResponse
func (c *ClientWithResponses) GetDatapipeStatusWithResponse(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*GetDatapipeStatusResponse, error) {
	rsp, err := c.GetDatapipeStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatapipeStatusResponse(rsp)
}

// ExportAttackPathFindingsWithResponse request returning *ExportAttackPathFindingsResponse
func (c *ClientWithResponses) ExportAttackPathFindingsWithResponse(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*ExportAttackPathFindingsResponse, error) {
	rsp, err := c.ExportAttackPathFindings(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAttackPathFindingsResponse(rsp)
}

// ListAvailableAttackPathTypesForDomainWithResponse request returning *ListAvailableAttackPathTypesForDomainResponse
func (c *ClientWithResponses) ListAvailableAttackPathTypesForDomainWithResponse(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*ListAvailableAttackPathTypesForDomainResponse, error) {
	rsp, err := c.ListAvailableAttackPathTypesForDomain(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableAttackPathTypesForDomainResponse(rsp)
}

// ListDomainAttackPathsDetailsWithResponse request returning *ListDomainAttackPathsDetailsResponse
func (c *ClientWithResponses) ListDomainAttackPathsDetailsWithResponse(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*ListDomainAttackPathsDetailsResponse, error) {
	rsp, err := c.ListDomainAttackPathsDetails(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDomainAttackPathsDetailsResponse(rsp)
}

// ListAttackPathSparklineValuesWithResponse request returning *ListAttackPathSparklineValuesResponse
func (c *ClientWithResponses) ListAttackPathSparklineValuesWithResponse(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*ListAttackPathSparklineValuesResponse, error) {
	rsp, err := c.ListAttackPathSparklineValues(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttackPathSparklineValuesResponse(rsp)
}

// GetDomainEntityWithResponse request returning *GetDomainEntityResponse
func (c *ClientWithResponses) GetDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*GetDomainEntityResponse, error) {
	rsp, err := c.GetDomainEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityResponse(rsp)
}

// UpdateDomainEntityWithBodyWithResponse request with arbitrary body returning *UpdateDomainEntityResponse
func (c *ClientWithResponses) UpdateDomainEntityWithBodyWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error) {
	rsp, err := c.UpdateDomainEntityWithBody(ctx, objectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainEntityResponse(rsp)
}

func (c *ClientWithResponses) UpdateDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error) {
	rsp, err := c.UpdateDomainEntity(ctx, objectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainEntityResponse(rsp)
}

// GetDomainEntityComputersWithResponse request returning *GetDomainEntityComputersResponse
func (c *ClientWithResponses) GetDomainEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityComputersResponse, error) {
	rsp, err := c.GetDomainEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityComputersResponse(rsp)
}

// GetDomainEntityControllersWithResponse request returning *GetDomainEntityControllersResponse
func (c *ClientWithResponses) GetDomainEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityControllersResponse, error) {
	rsp, err := c.GetDomainEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityControllersResponse(rsp)
}

// GetDomainEntityDcSyncersWithResponse request returning *GetDomainEntityDcSyncersResponse
func (c *ClientWithResponses) GetDomainEntityDcSyncersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityDcSyncersResponse, error) {
	rsp, err := c.GetDomainEntityDcSyncers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityDcSyncersResponse(rsp)
}

// GetDomainEntityForeignAdminsWithResponse request returning *GetDomainEntityForeignAdminsResponse
func (c *ClientWithResponses) GetDomainEntityForeignAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignAdminsResponse, error) {
	rsp, err := c.GetDomainEntityForeignAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignAdminsResponse(rsp)
}

// GetDomainEntityForeignGpoControllersWithResponse request returning *GetDomainEntityForeignGpoControllersResponse
func (c *ClientWithResponses) GetDomainEntityForeignGpoControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGpoControllersResponse, error) {
	rsp, err := c.GetDomainEntityForeignGpoControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignGpoControllersResponse(rsp)
}

// GetDomainEntityForeignGroupsWithResponse request returning *GetDomainEntityForeignGroupsResponse
func (c *ClientWithResponses) GetDomainEntityForeignGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGroupsResponse, error) {
	rsp, err := c.GetDomainEntityForeignGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignGroupsResponse(rsp)
}

// GetDomainEntityForeignUsersWithResponse request returning *GetDomainEntityForeignUsersResponse
func (c *ClientWithResponses) GetDomainEntityForeignUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignUsersResponse, error) {
	rsp, err := c.GetDomainEntityForeignUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignUsersResponse(rsp)
}

// GetDomainEntityGposWithResponse request returning *GetDomainEntityGposResponse
func (c *ClientWithResponses) GetDomainEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGposResponse, error) {
	rsp, err := c.GetDomainEntityGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityGposResponse(rsp)
}

// GetDomainEntityGroupsWithResponse request returning *GetDomainEntityGroupsResponse
func (c *ClientWithResponses) GetDomainEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGroupsResponse, error) {
	rsp, err := c.GetDomainEntityGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityGroupsResponse(rsp)
}

// GetDomainEntityInboundTrustsWithResponse request returning *GetDomainEntityInboundTrustsResponse
func (c *ClientWithResponses) GetDomainEntityInboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityInboundTrustsResponse, error) {
	rsp, err := c.GetDomainEntityInboundTrusts(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityInboundTrustsResponse(rsp)
}

// GetDomainEntityLinkedGposWithResponse request returning *GetDomainEntityLinkedGposResponse
func (c *ClientWithResponses) GetDomainEntityLinkedGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityLinkedGposResponse, error) {
	rsp, err := c.GetDomainEntityLinkedGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityLinkedGposResponse(rsp)
}

// GetDomainEntityOusWithResponse request returning *GetDomainEntityOusResponse
func (c *ClientWithResponses) GetDomainEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOusResponse, error) {
	rsp, err := c.GetDomainEntityOus(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityOusResponse(rsp)
}

// GetDomainEntityOutboundTrustsWithResponse request returning *GetDomainEntityOutboundTrustsResponse
func (c *ClientWithResponses) GetDomainEntityOutboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOutboundTrustsResponse, error) {
	rsp, err := c.GetDomainEntityOutboundTrusts(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityOutboundTrustsResponse(rsp)
}

// GetDomainEntityUsersWithResponse request returning *GetDomainEntityUsersResponse
func (c *ClientWithResponses) GetDomainEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityUsersResponse, error) {
	rsp, err := c.GetDomainEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityUsersResponse(rsp)
}

// GetEnterpriseCaEntityWithResponse request returning *GetEnterpriseCaEntityResponse
func (c *ClientWithResponses) GetEnterpriseCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityResponse, error) {
	rsp, err := c.GetEnterpriseCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnterpriseCaEntityResponse(rsp)
}

// GetEnterpriseCaEntityControllersWithResponse request returning *GetEnterpriseCaEntityControllersResponse
func (c *ClientWithResponses) GetEnterpriseCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityControllersResponse, error) {
	rsp, err := c.GetEnterpriseCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnterpriseCaEntityControllersResponse(rsp)
}

// ListClientSchedulesWithResponse request returning *ListClientSchedulesResponse
func (c *ClientWithResponses) ListClientSchedulesWithResponse(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*ListClientSchedulesResponse, error) {
	rsp, err := c.ListClientSchedules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientSchedulesResponse(rsp)
}

// CreateClientScheduleWithBodyWithResponse request with arbitrary body returning *CreateClientScheduleResponse
func (c *ClientWithResponses) CreateClientScheduleWithBodyWithResponse(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error) {
	rsp, err := c.CreateClientScheduleWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduleResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduleWithResponse(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error) {
	rsp, err := c.CreateClientSchedule(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduleResponse(rsp)
}

// DeleteClientEventWithResponse request returning *DeleteClientEventResponse
func (c *ClientWithResponses) DeleteClientEventWithResponse(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*DeleteClientEventResponse, error) {
	rsp, err := c.DeleteClientEvent(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientEventResponse(rsp)
}

// GetClientScheduleWithResponse request returning *GetClientScheduleResponse
func (c *ClientWithResponses) GetClientScheduleWithResponse(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*GetClientScheduleResponse, error) {
	rsp, err := c.GetClientSchedule(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientScheduleResponse(rsp)
}

// UpdateClientEventWithBodyWithResponse request with arbitrary body returning *UpdateClientEventResponse
func (c *ClientWithResponses) UpdateClientEventWithBodyWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error) {
	rsp, err := c.UpdateClientEventWithBody(ctx, eventId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientEventResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientEventWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error) {
	rsp, err := c.UpdateClientEvent(ctx, eventId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientEventResponse(rsp)
}

// ListFeatureFlagsWithResponse request returning *ListFeatureFlagsResponse
func (c *ClientWithResponses) ListFeatureFlagsWithResponse(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*ListFeatureFlagsResponse, error) {
	rsp, err := c.ListFeatureFlags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFeatureFlagsResponse(rsp)
}

// ToggleFeatureFlagWithResponse request returning *ToggleFeatureFlagResponse
func (c *ClientWithResponses) ToggleFeatureFlagWithResponse(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*ToggleFeatureFlagResponse, error) {
	rsp, err := c.ToggleFeatureFlag(ctx, featureId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleFeatureFlagResponse(rsp)
}

// ListFileUploadJobsWithResponse request returning *ListFileUploadJobsResponse
func (c *ClientWithResponses) ListFileUploadJobsWithResponse(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*ListFileUploadJobsResponse, error) {
	rsp, err := c.ListFileUploadJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFileUploadJobsResponse(rsp)
}

// ListAcceptedFileUploadTypesWithResponse request returning *ListAcceptedFileUploadTypesResponse
func (c *ClientWithResponses) ListAcceptedFileUploadTypesWithResponse(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*ListAcceptedFileUploadTypesResponse, error) {
	rsp, err := c.ListAcceptedFileUploadTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAcceptedFileUploadTypesResponse(rsp)
}

// CreateFileUploadJobWithResponse request returning *CreateFileUploadJobResponse
func (c *ClientWithResponses) CreateFileUploadJobWithResponse(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*CreateFileUploadJobResponse, error) {
	rsp, err := c.CreateFileUploadJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFileUploadJobResponse(rsp)
}

// UploadFileToJobWithBodyWithResponse request with arbitrary body returning *UploadFileToJobResponse
func (c *ClientWithResponses) UploadFileToJobWithBodyWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error) {
	rsp, err := c.UploadFileToJobWithBody(ctx, fileUploadJobId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileToJobResponse(rsp)
}

func (c *ClientWithResponses) UploadFileToJobWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error) {
	rsp, err := c.UploadFileToJob(ctx, fileUploadJobId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileToJobResponse(rsp)
}

// EndFileUploadJobWithResponse request returning *EndFileUploadJobResponse
func (c *ClientWithResponses) EndFileUploadJobWithResponse(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*EndFileUploadJobResponse, error) {
	rsp, err := c.EndFileUploadJob(ctx, fileUploadJobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndFileUploadJobResponse(rsp)
}

// GetGpoEntityWithResponse request returning *GetGpoEntityResponse
func (c *ClientWithResponses) GetGpoEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*GetGpoEntityResponse, error) {
	rsp, err := c.GetGpoEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityResponse(rsp)
}

// GetGpoEntityComputersWithResponse request returning *GetGpoEntityComputersResponse
func (c *ClientWithResponses) GetGpoEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityComputersResponse, error) {
	rsp, err := c.GetGpoEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityComputersResponse(rsp)
}

// GetGpoEntityControllersWithResponse request returning *GetGpoEntityControllersResponse
func (c *ClientWithResponses) GetGpoEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityControllersResponse, error) {
	rsp, err := c.GetGpoEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityControllersResponse(rsp)
}

// GetGpoEntityOusWithResponse request returning *GetGpoEntityOusResponse
func (c *ClientWithResponses) GetGpoEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*GetGpoEntityOusResponse, error) {
	rsp, err := c.GetGpoEntityOus(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityOusResponse(rsp)
}

// GetGpoEntityTierZeroWithResponse request returning *GetGpoEntityTierZeroResponse
func (c *ClientWithResponses) GetGpoEntityTierZeroWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*GetGpoEntityTierZeroResponse, error) {
	rsp, err := c.GetGpoEntityTierZero(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityTierZeroResponse(rsp)
}

// GetGpoEntityUsersWithResponse request returning *GetGpoEntityUsersResponse
func (c *ClientWithResponses) GetGpoEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityUsersResponse, error) {
	rsp, err := c.GetGpoEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityUsersResponse(rsp)
}

// GetSearchResultWithResponse request returning *GetSearchResultResponse
func (c *ClientWithResponses) GetSearchResultWithResponse(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*GetSearchResultResponse, error) {
	rsp, err := c.GetSearchResult(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultResponse(rsp)
}

// RunCypherQueryWithBodyWithResponse request with arbitrary body returning *RunCypherQueryResponse
func (c *ClientWithResponses) RunCypherQueryWithBodyWithResponse(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error) {
	rsp, err := c.RunCypherQueryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunCypherQueryResponse(rsp)
}

func (c *ClientWithResponses) RunCypherQueryWithResponse(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error) {
	rsp, err := c.RunCypherQuery(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunCypherQueryResponse(rsp)
}

// GetPathCompositionWithResponse request returning *GetPathCompositionResponse
func (c *ClientWithResponses) GetPathCompositionWithResponse(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*GetPathCompositionResponse, error) {
	rsp, err := c.GetPathComposition(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPathCompositionResponse(rsp)
}

// GetShortestPathWithResponse request returning *GetShortestPathResponse
func (c *ClientWithResponses) GetShortestPathWithResponse(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*GetShortestPathResponse, error) {
	rsp, err := c.GetShortestPath(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShortestPathResponse(rsp)
}

// GetGroupEntityWithResponse request returning *GetGroupEntityResponse
func (c *ClientWithResponses) GetGroupEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*GetGroupEntityResponse, error) {
	rsp, err := c.GetGroupEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityResponse(rsp)
}

// GetGroupEntityAdminRightsWithResponse request returning *GetGroupEntityAdminRightsResponse
func (c *ClientWithResponses) GetGroupEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityAdminRightsResponse, error) {
	rsp, err := c.GetGroupEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityAdminRightsResponse(rsp)
}

// GetGroupEntityControllablesWithResponse request returning *GetGroupEntityControllablesResponse
func (c *ClientWithResponses) GetGroupEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllablesResponse, error) {
	rsp, err := c.GetGroupEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityControllablesResponse(rsp)
}

// GetGroupEntityControllersWithResponse request returning *GetGroupEntityControllersResponse
func (c *ClientWithResponses) GetGroupEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllersResponse, error) {
	rsp, err := c.GetGroupEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityControllersResponse(rsp)
}

// GetGroupEntityDcomRightsWithResponse request returning *GetGroupEntityDcomRightsResponse
func (c *ClientWithResponses) GetGroupEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityDcomRightsResponse, error) {
	rsp, err := c.GetGroupEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityDcomRightsResponse(rsp)
}

// GetGroupEntityMembersWithResponse request returning *GetGroupEntityMembersResponse
func (c *ClientWithResponses) GetGroupEntityMembersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembersResponse, error) {
	rsp, err := c.GetGroupEntityMembers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityMembersResponse(rsp)
}

// GetGroupEntityMembershipsWithResponse request returning *GetGroupEntityMembershipsResponse
func (c *ClientWithResponses) GetGroupEntityMembershipsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembershipsResponse, error) {
	rsp, err := c.GetGroupEntityMemberships(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityMembershipsResponse(rsp)
}

// GetGroupEntityPsRemoteRightsWithResponse request returning *GetGroupEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetGroupEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetGroupEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityPsRemoteRightsResponse(rsp)
}

// GetGroupEntityRdpRightsWithResponse request returning *GetGroupEntityRdpRightsResponse
func (c *ClientWithResponses) GetGroupEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityRdpRightsResponse, error) {
	rsp, err := c.GetGroupEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityRdpRightsResponse(rsp)
}

// GetGroupEntitySessionsWithResponse request returning *GetGroupEntitySessionsResponse
func (c *ClientWithResponses) GetGroupEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetGroupEntitySessionsResponse, error) {
	rsp, err := c.GetGroupEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntitySessionsResponse(rsp)
}

// IngestDataWithResponse request returning *IngestDataResponse
func (c *ClientWithResponses) IngestDataWithResponse(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*IngestDataResponse, error) {
	rsp, err := c.IngestData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestDataResponse(rsp)
}

// GetClientJobsWithResponse request returning *GetClientJobsResponse
func (c *ClientWithResponses) GetClientJobsWithResponse(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*GetClientJobsResponse, error) {
	rsp, err := c.GetClientJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobsResponse(rsp)
}

// ListAvailableClientJobsWithResponse request returning *ListAvailableClientJobsResponse
func (c *ClientWithResponses) ListAvailableClientJobsWithResponse(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*ListAvailableClientJobsResponse, error) {
	rsp, err := c.ListAvailableClientJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableClientJobsResponse(rsp)
}

// GetClientCurrentJobWithResponse request returning *GetClientCurrentJobResponse
func (c *ClientWithResponses) GetClientCurrentJobWithResponse(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*GetClientCurrentJobResponse, error) {
	rsp, err := c.GetClientCurrentJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientCurrentJobResponse(rsp)
}

// EndClientJobWithResponse request returning *EndClientJobResponse
func (c *ClientWithResponses) EndClientJobWithResponse(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*EndClientJobResponse, error) {
	rsp, err := c.EndClientJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndClientJobResponse(rsp)
}

// ListClientFinishedJobsWithResponse request returning *ListClientFinishedJobsResponse
func (c *ClientWithResponses) ListClientFinishedJobsWithResponse(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*ListClientFinishedJobsResponse, error) {
	rsp, err := c.ListClientFinishedJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientFinishedJobsResponse(rsp)
}

// StartClientJobWithBodyWithResponse request with arbitrary body returning *StartClientJobResponse
func (c *ClientWithResponses) StartClientJobWithBodyWithResponse(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error) {
	rsp, err := c.StartClientJobWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartClientJobResponse(rsp)
}

func (c *ClientWithResponses) StartClientJobWithResponse(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error) {
	rsp, err := c.StartClientJob(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartClientJobResponse(rsp)
}

// GetClientJobWithResponse request returning *GetClientJobResponse
func (c *ClientWithResponses) GetClientJobWithResponse(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*GetClientJobResponse, error) {
	rsp, err := c.GetClientJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobResponse(rsp)
}

// CancelClientJobWithResponse request returning *CancelClientJobResponse
func (c *ClientWithResponses) CancelClientJobWithResponse(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*CancelClientJobResponse, error) {
	rsp, err := c.CancelClientJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelClientJobResponse(rsp)
}

// GetClientJobLogWithResponse request returning *GetClientJobLogResponse
func (c *ClientWithResponses) GetClientJobLogWithResponse(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*GetClientJobLogResponse, error) {
	rsp, err := c.GetClientJobLog(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobLogResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// GetLatestTierZeroComboNodeWithResponse request returning *GetLatestTierZeroComboNodeResponse
func (c *ClientWithResponses) GetLatestTierZeroComboNodeWithResponse(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*GetLatestTierZeroComboNodeResponse, error) {
	rsp, err := c.GetLatestTierZeroComboNode(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestTierZeroComboNodeResponse(rsp)
}

// GetComboTreeGraphWithResponse request returning *GetComboTreeGraphResponse
func (c *ClientWithResponses) GetComboTreeGraphWithResponse(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*GetComboTreeGraphResponse, error) {
	rsp, err := c.GetComboTreeGraph(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComboTreeGraphResponse(rsp)
}

// GetMetaEntityWithResponse request returning *GetMetaEntityResponse
func (c *ClientWithResponses) GetMetaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*GetMetaEntityResponse, error) {
	rsp, err := c.GetMetaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetaEntityResponse(rsp)
}

// GetNtAuthStoreEntityWithResponse request returning *GetNtAuthStoreEntityResponse
func (c *ClientWithResponses) GetNtAuthStoreEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityResponse, error) {
	rsp, err := c.GetNtAuthStoreEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNtAuthStoreEntityResponse(rsp)
}

// GetNtAuthStoreEntityControllersWithResponse request returning *GetNtAuthStoreEntityControllersResponse
func (c *ClientWithResponses) GetNtAuthStoreEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityControllersResponse, error) {
	rsp, err := c.GetNtAuthStoreEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNtAuthStoreEntityControllersResponse(rsp)
}

// GetOuEntityWithResponse request returning *GetOuEntityResponse
func (c *ClientWithResponses) GetOuEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*GetOuEntityResponse, error) {
	rsp, err := c.GetOuEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityResponse(rsp)
}

// GetOuEntityComputersWithResponse request returning *GetOuEntityComputersResponse
func (c *ClientWithResponses) GetOuEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*GetOuEntityComputersResponse, error) {
	rsp, err := c.GetOuEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityComputersResponse(rsp)
}

// GetOuEntityGposWithResponse request returning *GetOuEntityGposResponse
func (c *ClientWithResponses) GetOuEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*GetOuEntityGposResponse, error) {
	rsp, err := c.GetOuEntityGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityGposResponse(rsp)
}

// GetOuEntityGroupsWithResponse request returning *GetOuEntityGroupsResponse
func (c *ClientWithResponses) GetOuEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetOuEntityGroupsResponse, error) {
	rsp, err := c.GetOuEntityGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityGroupsResponse(rsp)
}

// GetOuEntityUsersWithResponse request returning *GetOuEntityUsersResponse
func (c *ClientWithResponses) GetOuEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*GetOuEntityUsersResponse, error) {
	rsp, err := c.GetOuEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityUsersResponse(rsp)
}

// PathfindingWithResponse request returning *PathfindingResponse
func (c *ClientWithResponses) PathfindingWithResponse(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*PathfindingResponse, error) {
	rsp, err := c.Pathfinding(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePathfindingResponse(rsp)
}

// ListPermissionsWithResponse request returning *ListPermissionsResponse
func (c *ClientWithResponses) ListPermissionsWithResponse(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*ListPermissionsResponse, error) {
	rsp, err := c.ListPermissions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsResponse(rsp)
}

// GetPermissionWithResponse request returning *GetPermissionResponse
func (c *ClientWithResponses) GetPermissionWithResponse(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*GetPermissionResponse, error) {
	rsp, err := c.GetPermission(ctx, permissionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionResponse(rsp)
}

// GetPlatformDataQualityAggregateWithResponse request returning *GetPlatformDataQualityAggregateResponse
func (c *ClientWithResponses) GetPlatformDataQualityAggregateWithResponse(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*GetPlatformDataQualityAggregateResponse, error) {
	rsp, err := c.GetPlatformDataQualityAggregate(ctx, platformId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformDataQualityAggregateResponse(rsp)
}

// GetPostureStatsWithResponse request returning *GetPostureStatsResponse
func (c *ClientWithResponses) GetPostureStatsWithResponse(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*GetPostureStatsResponse, error) {
	rsp, err := c.GetPostureStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostureStatsResponse(rsp)
}

// ListRolesWithResponse request returning *ListRolesResponse
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error) {
	rsp, err := c.ListRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, roleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// GetRootCaEntityWithResponse request returning *GetRootCaEntityResponse
func (c *ClientWithResponses) GetRootCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityResponse, error) {
	rsp, err := c.GetRootCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootCaEntityResponse(rsp)
}

// GetRootCaEntityControllersWithResponse request returning *GetRootCaEntityControllersResponse
func (c *ClientWithResponses) GetRootCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityControllersResponse, error) {
	rsp, err := c.GetRootCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootCaEntityControllersResponse(rsp)
}

// ListSamlProvidersWithResponse request returning *ListSamlProvidersResponse
func (c *ClientWithResponses) ListSamlProvidersWithResponse(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*ListSamlProvidersResponse, error) {
	rsp, err := c.ListSamlProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSamlProvidersResponse(rsp)
}

// CreateSamlProviderWithBodyWithResponse request with arbitrary body returning *CreateSamlProviderResponse
func (c *ClientWithResponses) CreateSamlProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSamlProviderResponse, error) {
	rsp, err := c.CreateSamlProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSamlProviderResponse(rsp)
}

// DeleteSamlProviderWithResponse request returning *DeleteSamlProviderResponse
func (c *ClientWithResponses) DeleteSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*DeleteSamlProviderResponse, error) {
	rsp, err := c.DeleteSamlProvider(ctx, samlProviderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSamlProviderResponse(rsp)
}

// GetSamlProviderWithResponse request returning *GetSamlProviderResponse
func (c *ClientWithResponses) GetSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*GetSamlProviderResponse, error) {
	rsp, err := c.GetSamlProvider(ctx, samlProviderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlProviderResponse(rsp)
}

// GetSamlSignSignOnEndpointsWithResponse request returning *GetSamlSignSignOnEndpointsResponse
func (c *ClientWithResponses) GetSamlSignSignOnEndpointsWithResponse(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*GetSamlSignSignOnEndpointsResponse, error) {
	rsp, err := c.GetSamlSignSignOnEndpoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlSignSignOnEndpointsResponse(rsp)
}

// ListSavedQueriesWithResponse request returning *ListSavedQueriesResponse
func (c *ClientWithResponses) ListSavedQueriesWithResponse(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*ListSavedQueriesResponse, error) {
	rsp, err := c.ListSavedQueries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSavedQueriesResponse(rsp)
}

// CreateSavedQueryWithBodyWithResponse request with arbitrary body returning *CreateSavedQueryResponse
func (c *ClientWithResponses) CreateSavedQueryWithBodyWithResponse(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error) {
	rsp, err := c.CreateSavedQueryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSavedQueryResponse(rsp)
}

func (c *ClientWithResponses) CreateSavedQueryWithResponse(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error) {
	rsp, err := c.CreateSavedQuery(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSavedQueryResponse(rsp)
}

// DeleteSavedQueryWithResponse request returning *DeleteSavedQueryResponse
func (c *ClientWithResponses) DeleteSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*DeleteSavedQueryResponse, error) {
	rsp, err := c.DeleteSavedQuery(ctx, savedQueryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryResponse(rsp)
}

// UpdateSavedQueryWithBodyWithResponse request with arbitrary body returning *UpdateSavedQueryResponse
func (c *ClientWithResponses) UpdateSavedQueryWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error) {
	rsp, err := c.UpdateSavedQueryWithBody(ctx, savedQueryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSavedQueryResponse(rsp)
}

func (c *ClientWithResponses) UpdateSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error) {
	rsp, err := c.UpdateSavedQuery(ctx, savedQueryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSavedQueryResponse(rsp)
}

// DeleteSavedQueryPermissionsWithBodyWithResponse request with arbitrary body returning *DeleteSavedQueryPermissionsResponse
func (c *ClientWithResponses) DeleteSavedQueryPermissionsWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error) {
	rsp, err := c.DeleteSavedQueryPermissionsWithBody(ctx, savedQueryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryPermissionsResponse(rsp)
}

func (c *ClientWithResponses) DeleteSavedQueryPermissionsWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error) {
	rsp, err := c.DeleteSavedQueryPermissions(ctx, savedQueryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryPermissionsResponse(rsp)
}

// ShareSavedQueryWithBodyWithResponse request with arbitrary body returning *ShareSavedQueryResponse
func (c *ClientWithResponses) ShareSavedQueryWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *ShareSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShareSavedQueryResponse, error) {
	rsp, err := c.ShareSavedQueryWithBody(ctx, savedQueryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareSavedQueryResponse(rsp)
}

func (c *ClientWithResponses) ShareSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *ShareSavedQueryParams, body ShareSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*ShareSavedQueryResponse, error) {
	rsp, err := c.ShareSavedQuery(ctx, savedQueryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShareSavedQueryResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// GetSelfWithResponse request returning *GetSelfResponse
func (c *ClientWithResponses) GetSelfWithResponse(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*GetSelfResponse, error) {
	rsp, err := c.GetSelf(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfResponse(rsp)
}

// GetApiSpecWithResponse request returning *GetApiSpecResponse
func (c *ClientWithResponses) GetApiSpecWithResponse(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*GetApiSpecResponse, error) {
	rsp, err := c.GetApiSpec(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiSpecResponse(rsp)
}

// ListAuthTokensWithResponse request returning *ListAuthTokensResponse
func (c *ClientWithResponses) ListAuthTokensWithResponse(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*ListAuthTokensResponse, error) {
	rsp, err := c.ListAuthTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuthTokensResponse(rsp)
}

// CreateAuthTokenWithBodyWithResponse request with arbitrary body returning *CreateAuthTokenResponse
func (c *ClientWithResponses) CreateAuthTokenWithBodyWithResponse(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error) {
	rsp, err := c.CreateAuthTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateAuthTokenWithResponse(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error) {
	rsp, err := c.CreateAuthToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenResponse(rsp)
}

// DeleteAuthTokenWithResponse request returning *DeleteAuthTokenResponse
func (c *ClientWithResponses) DeleteAuthTokenWithResponse(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*DeleteAuthTokenResponse, error) {
	rsp, err := c.DeleteAuthToken(ctx, tokenId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthTokenResponse(rsp)
}

// GetUserEntityWithResponse request returning *GetUserEntityResponse
func (c *ClientWithResponses) GetUserEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*GetUserEntityResponse, error) {
	rsp, err := c.GetUserEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityResponse(rsp)
}

// GetUserEntityAdminRightsWithResponse request returning *GetUserEntityAdminRightsResponse
func (c *ClientWithResponses) GetUserEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityAdminRightsResponse, error) {
	rsp, err := c.GetUserEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityAdminRightsResponse(rsp)
}

// GetUserEntityConstrainedDelegationRightsWithResponse request returning *GetUserEntityConstrainedDelegationRightsResponse
func (c *ClientWithResponses) GetUserEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityConstrainedDelegationRightsResponse, error) {
	rsp, err := c.GetUserEntityConstrainedDelegationRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityConstrainedDelegationRightsResponse(rsp)
}

// GetUserEntityControllablesWithResponse request returning *GetUserEntityControllablesResponse
func (c *ClientWithResponses) GetUserEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllablesResponse, error) {
	rsp, err := c.GetUserEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityControllablesResponse(rsp)
}

// GetUserEntityControllersWithResponse request returning *GetUserEntityControllersResponse
func (c *ClientWithResponses) GetUserEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllersResponse, error) {
	rsp, err := c.GetUserEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityControllersResponse(rsp)
}

// GetUserEntityDcomRightsWithResponse request returning *GetUserEntityDcomRightsResponse
func (c *ClientWithResponses) GetUserEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityDcomRightsResponse, error) {
	rsp, err := c.GetUserEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityDcomRightsResponse(rsp)
}

// GetUserEntityMembershipWithResponse request returning *GetUserEntityMembershipResponse
func (c *ClientWithResponses) GetUserEntityMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*GetUserEntityMembershipResponse, error) {
	rsp, err := c.GetUserEntityMembership(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityMembershipResponse(rsp)
}

// GetUserEntityPsRemoteRightsWithResponse request returning *GetUserEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetUserEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetUserEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityPsRemoteRightsResponse(rsp)
}

// GetUserEntityRdpRightsWithResponse request returning *GetUserEntityRdpRightsResponse
func (c *ClientWithResponses) GetUserEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityRdpRightsResponse, error) {
	rsp, err := c.GetUserEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityRdpRightsResponse(rsp)
}

// GetUserEntitySessionsWithResponse request returning *GetUserEntitySessionsResponse
func (c *ClientWithResponses) GetUserEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySessionsResponse, error) {
	rsp, err := c.GetUserEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntitySessionsResponse(rsp)
}

// GetUserEntitySqlAdminRightsWithResponse request returning *GetUserEntitySqlAdminRightsResponse
func (c *ClientWithResponses) GetUserEntitySqlAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySqlAdminRightsResponse, error) {
	rsp, err := c.GetUserEntitySqlAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntitySqlAdminRightsResponse(rsp)
}

// GetApiVersionWithResponse request returning *GetApiVersionResponse
func (c *ClientWithResponses) GetApiVersionWithResponse(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*GetApiVersionResponse, error) {
	rsp, err := c.GetApiVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiVersionResponse(rsp)
}

// ParseAcceptEulaResponse parses an HTTP response from a AcceptEulaWithResponse call
func ParseAcceptEulaResponse(rsp *http.Response) (*AcceptEulaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptEulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAdDomainDataQualityStatsResponse parses an HTTP response from a GetAdDomainDataQualityStatsWithResponse call
func ParseGetAdDomainDataQualityStatsResponse(rsp *http.Response) (*GetAdDomainDataQualityStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdDomainDataQualityStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                      `json:"count,omitempty"`
			Data  *[]ModelAdDataQualityStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiaCaEntityResponse parses an HTTP response from a GetAiaCaEntityWithResponse call
func ParseGetAiaCaEntityResponse(rsp *http.Response) (*GetAiaCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiaCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiaCaEntityControllersResponse parses an HTTP response from a GetAiaCaEntityControllersWithResponse call
func ParseGetAiaCaEntityControllersResponse(rsp *http.Response) (*GetAiaCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiaCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartAnalysisResponse parses an HTTP response from a StartAnalysisWithResponse call
func ParseStartAnalysisResponse(rsp *http.Response) (*StartAnalysisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartAnalysisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListAssetGroupsResponse parses an HTTP response from a ListAssetGroupsWithResponse call
func ParseListAssetGroupsResponse(rsp *http.Response) (*ListAssetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AssetGroups *[]ModelAssetGroup `json:"asset_groups,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAssetGroupResponse parses an HTTP response from a CreateAssetGroupWithResponse call
func ParseCreateAssetGroupResponse(rsp *http.Response) (*CreateAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAssetGroupResponse parses an HTTP response from a DeleteAssetGroupWithResponse call
func ParseDeleteAssetGroupResponse(rsp *http.Response) (*DeleteAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupResponse parses an HTTP response from a GetAssetGroupWithResponse call
func ParseGetAssetGroupResponse(rsp *http.Response) (*GetAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupResponse parses an HTTP response from a UpdateAssetGroupWithResponse call
func ParseUpdateAssetGroupResponse(rsp *http.Response) (*UpdateAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupCollectionsResponse parses an HTTP response from a ListAssetGroupCollectionsWithResponse call
func ParseListAssetGroupCollectionsResponse(rsp *http.Response) (*ListAssetGroupCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelAssetGroupCollection `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupComboNodeResponse parses an HTTP response from a GetAssetGroupComboNodeWithResponse call
func ParseGetAssetGroupComboNodeResponse(rsp *http.Response) (*GetAssetGroupComboNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupComboNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupCustomMemberCountResponse parses an HTTP response from a GetAssetGroupCustomMemberCountWithResponse call
func ParseGetAssetGroupCustomMemberCountResponse(rsp *http.Response) (*GetAssetGroupCustomMemberCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupCustomMemberCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CustomMemberCount *int `json:"custom_member_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupMembersResponse parses an HTTP response from a ListAssetGroupMembersWithResponse call
func ParseListAssetGroupMembersResponse(rsp *http.Response) (*ListAssetGroupMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int `json:"count,omitempty"`
			Data  *struct {
				Members *[]ModelAssetGroupMember `json:"members,omitempty"`
			} `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupMemberCountByKindResponse parses an HTTP response from a ListAssetGroupMemberCountByKindWithResponse call
func ParseListAssetGroupMemberCountByKindResponse(rsp *http.Response) (*ListAssetGroupMemberCountByKindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupMemberCountByKindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Counts     *map[string]int `json:"counts,omitempty"`
				TotalCount *int            `json:"total_count,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupSelectorsDeprecatedResponse parses an HTTP response from a UpdateAssetGroupSelectorsDeprecatedWithResponse call
func ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp *http.Response) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupSelectorsDeprecatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
				RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupSelectorsResponse parses an HTTP response from a UpdateAssetGroupSelectorsWithResponse call
func ParseUpdateAssetGroupSelectorsResponse(rsp *http.Response) (*UpdateAssetGroupSelectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupSelectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
				RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAssetGroupSelectorResponse parses an HTTP response from a DeleteAssetGroupSelectorWithResponse call
func ParseDeleteAssetGroupSelectorResponse(rsp *http.Response) (*DeleteAssetGroupSelectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetGroupSelectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttackPathTypesResponse parses an HTTP response from a ListAttackPathTypesWithResponse call
func ParseListAttackPathTypesResponse(rsp *http.Response) (*ListAttackPathTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttackPathTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartAnalysisBheResponse parses an HTTP response from a StartAnalysisBheWithResponse call
func ParseStartAnalysisBheResponse(rsp *http.Response) (*StartAnalysisBheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartAnalysisBheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAttackPathRiskResponse parses an HTTP response from a UpdateAttackPathRiskWithResponse call
func ParseUpdateAttackPathRiskResponse(rsp *http.Response) (*UpdateAttackPathRiskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttackPathRiskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseFinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Logs *[]ModelAuditLog `json:"logs,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAvailableDomainsResponse parses an HTTP response from a GetAvailableDomainsWithResponse call
func ParseGetAvailableDomainsResponse(rsp *http.Response) (*GetAvailableDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelDomainSelector `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAzureTenantDataQualityStatsResponse parses an HTTP response from a GetAzureTenantDataQualityStatsWithResponse call
func ParseGetAzureTenantDataQualityStatsResponse(rsp *http.Response) (*GetAzureTenantDataQualityStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAzureTenantDataQualityStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                         `json:"count,omitempty"`
			Data  *[]ModelAzureDataQualityStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAzureEntityResponse parses an HTTP response from a GetAzureEntityWithResponse call
func ParseGetAzureEntityResponse(rsp *http.Response) (*GetAzureEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAzureEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityResponse parses an HTTP response from a GetEntityWithResponse call
func ParseGetEntityResponse(rsp *http.Response) (*GetEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityControllablesResponse parses an HTTP response from a GetEntityControllablesWithResponse call
func ParseGetEntityControllablesResponse(rsp *http.Response) (*GetEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityControllersResponse parses an HTTP response from a GetEntityControllersWithResponse call
func ParseGetEntityControllersResponse(rsp *http.Response) (*GetEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Users *[]ModelUser `json:"users,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUser `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUser `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveUserMfaResponse parses an HTTP response from a RemoveUserMfaWithResponse call
func ParseRemoveUserMfaResponse(rsp *http.Response) (*RemoveUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddUserMfaResponse parses an HTTP response from a AddUserMfaWithResponse call
func ParseAddUserMfaResponse(rsp *http.Response) (*AddUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				QrCode     *string `json:"qr_code,omitempty"`
				TotpSecret *string `json:"totp_secret,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMfaActivationStatusResponse parses an HTTP response from a GetMfaActivationStatusWithResponse call
func ParseGetMfaActivationStatusResponse(rsp *http.Response) (*GetMfaActivationStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMfaActivationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseActivateUserMfaResponse parses an HTTP response from a ActivateUserMfaWithResponse call
func ParseActivateUserMfaResponse(rsp *http.Response) (*ActivateUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserSecretResponse parses an HTTP response from a DeleteUserSecretWithResponse call
func ParseDeleteUserSecretResponse(rsp *http.Response) (*DeleteUserSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrSetUserSecretResponse parses an HTTP response from a CreateOrSetUserSecretWithResponse call
func ParseCreateOrSetUserSecretResponse(rsp *http.Response) (*CreateOrSetUserSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrSetUserSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertTemplateEntityResponse parses an HTTP response from a GetCertTemplateEntityWithResponse call
func ParseGetCertTemplateEntityResponse(rsp *http.Response) (*GetCertTemplateEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertTemplateEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertTemplateEntityControllersResponse parses an HTTP response from a GetCertTemplateEntityControllersWithResponse call
func ParseGetCertTemplateEntityControllersResponse(rsp *http.Response) (*GetCertTemplateEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertTemplateEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBloodHoundDatabaseResponse parses an HTTP response from a DeleteBloodHoundDatabaseWithResponse call
func ParseDeleteBloodHoundDatabaseResponse(rsp *http.Response) (*DeleteBloodHoundDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBloodHoundDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientsResponse parses an HTTP response from a ListClientsWithResponse call
func ParseListClientsResponse(rsp *http.Response) (*ListClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                  `json:"count,omitempty"`
			Data  *[]ModelClientDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientResponse parses an HTTP response from a CreateClientWithResponse call
func ParseCreateClientResponse(rsp *http.Response) (*CreateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogClientErrorResponse parses an HTTP response from a LogClientErrorWithResponse call
func ParseLogClientErrorResponse(rsp *http.Response) (*LogClientErrorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogClientErrorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientInfoResponse parses an HTTP response from a UpdateClientInfoWithResponse call
func ParseUpdateClientInfoResponse(rsp *http.Response) (*UpdateClientInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientResponse parses an HTTP response from a DeleteClientWithResponse call
func ParseDeleteClientResponse(rsp *http.Response) (*DeleteClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientResponse parses an HTTP response from a GetClientWithResponse call
func ParseGetClientResponse(rsp *http.Response) (*GetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientResponse parses an HTTP response from a UpdateClientWithResponse call
func ParseUpdateClientResponse(rsp *http.Response) (*UpdateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientCompletedJobsResponse parses an HTTP response from a ListClientCompletedJobsWithResponse call
func ParseListClientCompletedJobsResponse(rsp *http.Response) (*ListClientCompletedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientCompletedTasksResponse parses an HTTP response from a ListClientCompletedTasksWithResponse call
func ParseListClientCompletedTasksResponse(rsp *http.Response) (*ListClientCompletedTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientCompletedTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduledJobResponse parses an HTTP response from a CreateClientScheduledJobWithResponse call
func ParseCreateClientScheduledJobResponse(rsp *http.Response) (*CreateClientScheduledJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduledJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduledTaskResponse parses an HTTP response from a CreateClientScheduledTaskWithResponse call
func ParseCreateClientScheduledTaskResponse(rsp *http.Response) (*CreateClientScheduledTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduledTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReplaceClientTokenResponse parses an HTTP response from a ReplaceClientTokenWithResponse call
func ParseReplaceClientTokenResponse(rsp *http.Response) (*ReplaceClientTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceClientTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAuthToken `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorManifestResponse parses an HTTP response from a GetCollectorManifestWithResponse call
func ParseGetCollectorManifestResponse(rsp *http.Response) (*GetCollectorManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelCollectorManifest `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadCollectorResponse parses an HTTP response from a DownloadCollectorWithResponse call
func ParseDownloadCollectorResponse(rsp *http.Response) (*DownloadCollectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadCollectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorChecksumResponse parses an HTTP response from a GetCollectorChecksumWithResponse call
func ParseGetCollectorChecksumResponse(rsp *http.Response) (*GetCollectorChecksumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorChecksumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCompletenessStatsResponse parses an HTTP response from a GetCompletenessStatsWithResponse call
func ParseGetCompletenessStatsResponse(rsp *http.Response) (*GetCompletenessStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletenessStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]float64 `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityResponse parses an HTTP response from a GetComputerEntityWithResponse call
func ParseGetComputerEntityResponse(rsp *http.Response) (*GetComputerEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityAdminRightsResponse parses an HTTP response from a GetComputerEntityAdminRightsWithResponse call
func ParseGetComputerEntityAdminRightsResponse(rsp *http.Response) (*GetComputerEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityAdminsResponse parses an HTTP response from a GetComputerEntityAdminsWithResponse call
func ParseGetComputerEntityAdminsResponse(rsp *http.Response) (*GetComputerEntityAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityConstrainedDelegationRightsResponse parses an HTTP response from a GetComputerEntityConstrainedDelegationRightsWithResponse call
func ParseGetComputerEntityConstrainedDelegationRightsResponse(rsp *http.Response) (*GetComputerEntityConstrainedDelegationRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityConstrainedDelegationRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityConstrainedUsersResponse parses an HTTP response from a GetComputerEntityConstrainedUsersWithResponse call
func ParseGetComputerEntityConstrainedUsersResponse(rsp *http.Response) (*GetComputerEntityConstrainedUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityConstrainedUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityControllablesResponse parses an HTTP response from a GetComputerEntityControllablesWithResponse call
func ParseGetComputerEntityControllablesResponse(rsp *http.Response) (*GetComputerEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityControllersResponse parses an HTTP response from a GetComputerEntityControllersWithResponse call
func ParseGetComputerEntityControllersResponse(rsp *http.Response) (*GetComputerEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityDcomRightsResponse parses an HTTP response from a GetComputerEntityDcomRightsWithResponse call
func ParseGetComputerEntityDcomRightsResponse(rsp *http.Response) (*GetComputerEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityDcomUsersResponse parses an HTTP response from a GetComputerEntityDcomUsersWithResponse call
func ParseGetComputerEntityDcomUsersResponse(rsp *http.Response) (*GetComputerEntityDcomUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityDcomUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityGroupMembershipResponse parses an HTTP response from a GetComputerEntityGroupMembershipWithResponse call
func ParseGetComputerEntityGroupMembershipResponse(rsp *http.Response) (*GetComputerEntityGroupMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityPsRemoteRightsResponse parses an HTTP response from a GetComputerEntityPsRemoteRightsWithResponse call
func ParseGetComputerEntityPsRemoteRightsResponse(rsp *http.Response) (*GetComputerEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityPsRemoteUsersResponse parses an HTTP response from a GetComputerEntityPsRemoteUsersWithResponse call
func ParseGetComputerEntityPsRemoteUsersResponse(rsp *http.Response) (*GetComputerEntityPsRemoteUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityPsRemoteUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityRdpRightsResponse parses an HTTP response from a GetComputerEntityRdpRightsWithResponse call
func ParseGetComputerEntityRdpRightsResponse(rsp *http.Response) (*GetComputerEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityRdpUsersResponse parses an HTTP response from a GetComputerEntityRdpUsersWithResponse call
func ParseGetComputerEntityRdpUsersResponse(rsp *http.Response) (*GetComputerEntityRdpUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityRdpUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntitySessionsResponse parses an HTTP response from a GetComputerEntitySessionsWithResponse call
func ParseGetComputerEntitySessionsResponse(rsp *http.Response) (*GetComputerEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntitySqlAdminsResponse parses an HTTP response from a GetComputerEntitySqlAdminsWithResponse call
func ParseGetComputerEntitySqlAdminsResponse(rsp *http.Response) (*GetComputerEntitySqlAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntitySqlAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAppConfigParamsResponse parses an HTTP response from a ListAppConfigParamsWithResponse call
func ParseListAppConfigParamsResponse(rsp *http.Response) (*ListAppConfigParamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppConfigParamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelAppConfigParam `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetAppConfigParamResponse parses an HTTP response from a SetAppConfigParamWithResponse call
func ParseSetAppConfigParamResponse(rsp *http.Response) (*SetAppConfigParamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAppConfigParamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Key   *string                 `json:"key,omitempty"`
				Value *map[string]interface{} `json:"value,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContainerEntityResponse parses an HTTP response from a GetContainerEntityWithResponse call
func ParseGetContainerEntityResponse(rsp *http.Response) (*GetContainerEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContainerEntityControllersResponse parses an HTTP response from a GetContainerEntityControllersWithResponse call
func ParseGetContainerEntityControllersResponse(rsp *http.Response) (*GetContainerEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatapipeStatusResponse parses an HTTP response from a GetDatapipeStatusWithResponse call
func ParseGetDatapipeStatusResponse(rsp *http.Response) (*GetDatapipeStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatapipeStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				LastCompleteAnalysisAt *time.Time          `json:"last_complete_analysis_at,omitempty"`
				Status                 *EnumDatapipeStatus `json:"status,omitempty"`
				UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseExportAttackPathFindingsResponse parses an HTTP response from a ExportAttackPathFindingsWithResponse call
func ParseExportAttackPathFindingsResponse(rsp *http.Response) (*ExportAttackPathFindingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportAttackPathFindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableAttackPathTypesForDomainResponse parses an HTTP response from a ListAvailableAttackPathTypesForDomainWithResponse call
func ParseListAvailableAttackPathTypesForDomainResponse(rsp *http.Response) (*ListAvailableAttackPathTypesForDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableAttackPathTypesForDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDomainAttackPathsDetailsResponse parses an HTTP response from a ListDomainAttackPathsDetailsWithResponse call
func ParseListDomainAttackPathsDetailsResponse(rsp *http.Response) (*ListDomainAttackPathsDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDomainAttackPathsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttackPathSparklineValuesResponse parses an HTTP response from a ListAttackPathSparklineValuesWithResponse call
func ParseListAttackPathSparklineValuesResponse(rsp *http.Response) (*ListAttackPathSparklineValuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttackPathSparklineValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelRiskCounts `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityResponse parses an HTTP response from a GetDomainEntityWithResponse call
func ParseGetDomainEntityResponse(rsp *http.Response) (*GetDomainEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDomainEntityResponse parses an HTTP response from a UpdateDomainEntityWithResponse call
func ParseUpdateDomainEntityResponse(rsp *http.Response) (*UpdateDomainEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDomainEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Collected *bool `json:"collected,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityComputersResponse parses an HTTP response from a GetDomainEntityComputersWithResponse call
func ParseGetDomainEntityComputersResponse(rsp *http.Response) (*GetDomainEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityControllersResponse parses an HTTP response from a GetDomainEntityControllersWithResponse call
func ParseGetDomainEntityControllersResponse(rsp *http.Response) (*GetDomainEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityDcSyncersResponse parses an HTTP response from a GetDomainEntityDcSyncersWithResponse call
func ParseGetDomainEntityDcSyncersResponse(rsp *http.Response) (*GetDomainEntityDcSyncersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityDcSyncersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignAdminsResponse parses an HTTP response from a GetDomainEntityForeignAdminsWithResponse call
func ParseGetDomainEntityForeignAdminsResponse(rsp *http.Response) (*GetDomainEntityForeignAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignGpoControllersResponse parses an HTTP response from a GetDomainEntityForeignGpoControllersWithResponse call
func ParseGetDomainEntityForeignGpoControllersResponse(rsp *http.Response) (*GetDomainEntityForeignGpoControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignGpoControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignGroupsResponse parses an HTTP response from a GetDomainEntityForeignGroupsWithResponse call
func ParseGetDomainEntityForeignGroupsResponse(rsp *http.Response) (*GetDomainEntityForeignGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignUsersResponse parses an HTTP response from a GetDomainEntityForeignUsersWithResponse call
func ParseGetDomainEntityForeignUsersResponse(rsp *http.Response) (*GetDomainEntityForeignUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityGposResponse parses an HTTP response from a GetDomainEntityGposWithResponse call
func ParseGetDomainEntityGposResponse(rsp *http.Response) (*GetDomainEntityGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityGroupsResponse parses an HTTP response from a GetDomainEntityGroupsWithResponse call
func ParseGetDomainEntityGroupsResponse(rsp *http.Response) (*GetDomainEntityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityInboundTrustsResponse parses an HTTP response from a GetDomainEntityInboundTrustsWithResponse call
func ParseGetDomainEntityInboundTrustsResponse(rsp *http.Response) (*GetDomainEntityInboundTrustsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityInboundTrustsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityLinkedGposResponse parses an HTTP response from a GetDomainEntityLinkedGposWithResponse call
func ParseGetDomainEntityLinkedGposResponse(rsp *http.Response) (*GetDomainEntityLinkedGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityLinkedGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityOusResponse parses an HTTP response from a GetDomainEntityOusWithResponse call
func ParseGetDomainEntityOusResponse(rsp *http.Response) (*GetDomainEntityOusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityOusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityOutboundTrustsResponse parses an HTTP response from a GetDomainEntityOutboundTrustsWithResponse call
func ParseGetDomainEntityOutboundTrustsResponse(rsp *http.Response) (*GetDomainEntityOutboundTrustsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityOutboundTrustsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityUsersResponse parses an HTTP response from a GetDomainEntityUsersWithResponse call
func ParseGetDomainEntityUsersResponse(rsp *http.Response) (*GetDomainEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEnterpriseCaEntityResponse parses an HTTP response from a GetEnterpriseCaEntityWithResponse call
func ParseGetEnterpriseCaEntityResponse(rsp *http.Response) (*GetEnterpriseCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnterpriseCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEnterpriseCaEntityControllersResponse parses an HTTP response from a GetEnterpriseCaEntityControllersWithResponse call
func ParseGetEnterpriseCaEntityControllersResponse(rsp *http.Response) (*GetEnterpriseCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnterpriseCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientSchedulesResponse parses an HTTP response from a ListClientSchedulesWithResponse call
func ParseListClientSchedulesResponse(rsp *http.Response) (*ListClientSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                          `json:"count,omitempty"`
			Data  *[]ModelClientScheduleDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduleResponse parses an HTTP response from a CreateClientScheduleWithResponse call
func ParseCreateClientScheduleResponse(rsp *http.Response) (*CreateClientScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientEventResponse parses an HTTP response from a DeleteClientEventWithResponse call
func ParseDeleteClientEventResponse(rsp *http.Response) (*DeleteClientEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientScheduleResponse parses an HTTP response from a GetClientScheduleWithResponse call
func ParseGetClientScheduleResponse(rsp *http.Response) (*GetClientScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientEventResponse parses an HTTP response from a UpdateClientEventWithResponse call
func ParseUpdateClientEventResponse(rsp *http.Response) (*UpdateClientEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFeatureFlagsResponse parses an HTTP response from a ListFeatureFlagsWithResponse call
func ParseListFeatureFlagsResponse(rsp *http.Response) (*ListFeatureFlagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFeatureFlagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelFeatureFlag `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseToggleFeatureFlagResponse parses an HTTP response from a ToggleFeatureFlagWithResponse call
func ParseToggleFeatureFlagResponse(rsp *http.Response) (*ToggleFeatureFlagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleFeatureFlagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFileUploadJobsResponse parses an HTTP response from a ListFileUploadJobsWithResponse call
func ParseListFileUploadJobsResponse(rsp *http.Response) (*ListFileUploadJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFileUploadJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                  `json:"count,omitempty"`
			Data  *[]ModelFileUploadJob `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAcceptedFileUploadTypesResponse parses an HTTP response from a ListAcceptedFileUploadTypesWithResponse call
func ParseListAcceptedFileUploadTypesResponse(rsp *http.Response) (*ListAcceptedFileUploadTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAcceptedFileUploadTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateFileUploadJobResponse parses an HTTP response from a CreateFileUploadJobWithResponse call
func ParseCreateFileUploadJobResponse(rsp *http.Response) (*CreateFileUploadJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFileUploadJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *ModelFileUploadJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadFileToJobResponse parses an HTTP response from a UploadFileToJobWithResponse call
func ParseUploadFileToJobResponse(rsp *http.Response) (*UploadFileToJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFileToJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEndFileUploadJobResponse parses an HTTP response from a EndFileUploadJobWithResponse call
func ParseEndFileUploadJobResponse(rsp *http.Response) (*EndFileUploadJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndFileUploadJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityResponse parses an HTTP response from a GetGpoEntityWithResponse call
func ParseGetGpoEntityResponse(rsp *http.Response) (*GetGpoEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityComputersResponse parses an HTTP response from a GetGpoEntityComputersWithResponse call
func ParseGetGpoEntityComputersResponse(rsp *http.Response) (*GetGpoEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityControllersResponse parses an HTTP response from a GetGpoEntityControllersWithResponse call
func ParseGetGpoEntityControllersResponse(rsp *http.Response) (*GetGpoEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityOusResponse parses an HTTP response from a GetGpoEntityOusWithResponse call
func ParseGetGpoEntityOusResponse(rsp *http.Response) (*GetGpoEntityOusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityOusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityTierZeroResponse parses an HTTP response from a GetGpoEntityTierZeroWithResponse call
func ParseGetGpoEntityTierZeroResponse(rsp *http.Response) (*GetGpoEntityTierZeroResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityTierZeroResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityUsersResponse parses an HTTP response from a GetGpoEntityUsersWithResponse call
func ParseGetGpoEntityUsersResponse(rsp *http.Response) (*GetGpoEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultResponse parses an HTTP response from a GetSearchResultWithResponse call
func ParseGetSearchResultResponse(rsp *http.Response) (*GetSearchResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRunCypherQueryResponse parses an HTTP response from a RunCypherQueryWithResponse call
func ParseRunCypherQueryResponse(rsp *http.Response) (*RunCypherQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunCypherQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPathCompositionResponse parses an HTTP response from a GetPathCompositionWithResponse call
func ParseGetPathCompositionResponse(rsp *http.Response) (*GetPathCompositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPathCompositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShortestPathResponse parses an HTTP response from a GetShortestPathWithResponse call
func ParseGetShortestPathResponse(rsp *http.Response) (*GetShortestPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShortestPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityResponse parses an HTTP response from a GetGroupEntityWithResponse call
func ParseGetGroupEntityResponse(rsp *http.Response) (*GetGroupEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityAdminRightsResponse parses an HTTP response from a GetGroupEntityAdminRightsWithResponse call
func ParseGetGroupEntityAdminRightsResponse(rsp *http.Response) (*GetGroupEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityControllablesResponse parses an HTTP response from a GetGroupEntityControllablesWithResponse call
func ParseGetGroupEntityControllablesResponse(rsp *http.Response) (*GetGroupEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityControllersResponse parses an HTTP response from a GetGroupEntityControllersWithResponse call
func ParseGetGroupEntityControllersResponse(rsp *http.Response) (*GetGroupEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityDcomRightsResponse parses an HTTP response from a GetGroupEntityDcomRightsWithResponse call
func ParseGetGroupEntityDcomRightsResponse(rsp *http.Response) (*GetGroupEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityMembersResponse parses an HTTP response from a GetGroupEntityMembersWithResponse call
func ParseGetGroupEntityMembersResponse(rsp *http.Response) (*GetGroupEntityMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityMembershipsResponse parses an HTTP response from a GetGroupEntityMembershipsWithResponse call
func ParseGetGroupEntityMembershipsResponse(rsp *http.Response) (*GetGroupEntityMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityPsRemoteRightsResponse parses an HTTP response from a GetGroupEntityPsRemoteRightsWithResponse call
func ParseGetGroupEntityPsRemoteRightsResponse(rsp *http.Response) (*GetGroupEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityRdpRightsResponse parses an HTTP response from a GetGroupEntityRdpRightsWithResponse call
func ParseGetGroupEntityRdpRightsResponse(rsp *http.Response) (*GetGroupEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntitySessionsResponse parses an HTTP response from a GetGroupEntitySessionsWithResponse call
func ParseGetGroupEntitySessionsResponse(rsp *http.Response) (*GetGroupEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIngestDataResponse parses an HTTP response from a IngestDataWithResponse call
func ParseIngestDataResponse(rsp *http.Response) (*IngestDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IngestDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobsResponse parses an HTTP response from a GetClientJobsWithResponse call
func ParseGetClientJobsResponse(rsp *http.Response) (*GetClientJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableClientJobsResponse parses an HTTP response from a ListAvailableClientJobsWithResponse call
func ParseListAvailableClientJobsResponse(rsp *http.Response) (*ListAvailableClientJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableClientJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientCurrentJobResponse parses an HTTP response from a GetClientCurrentJobWithResponse call
func ParseGetClientCurrentJobResponse(rsp *http.Response) (*GetClientCurrentJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientCurrentJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEndClientJobResponse parses an HTTP response from a EndClientJobWithResponse call
func ParseEndClientJobResponse(rsp *http.Response) (*EndClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientFinishedJobsResponse parses an HTTP response from a ListClientFinishedJobsWithResponse call
func ParseListClientFinishedJobsResponse(rsp *http.Response) (*ListClientFinishedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientFinishedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartClientJobResponse parses an HTTP response from a StartClientJobWithResponse call
func ParseStartClientJobResponse(rsp *http.Response) (*StartClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobResponse parses an HTTP response from a GetClientJobWithResponse call
func ParseGetClientJobResponse(rsp *http.Response) (*GetClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelClientJobResponse parses an HTTP response from a CancelClientJobWithResponse call
func ParseCancelClientJobResponse(rsp *http.Response) (*CancelClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobLogResponse parses an HTTP response from a GetClientJobLogWithResponse call
func ParseGetClientJobLogResponse(rsp *http.Response) (*GetClientJobLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Log *string `json:"log,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AuthExpired  *bool               `json:"auth_expired,omitempty"`
				SessionToken *string             `json:"session_token,omitempty"`
				UserId       *openapi_types.UUID `json:"user_id,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetLatestTierZeroComboNodeResponse parses an HTTP response from a GetLatestTierZeroComboNodeWithResponse call
func ParseGetLatestTierZeroComboNodeResponse(rsp *http.Response) (*GetLatestTierZeroComboNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestTierZeroComboNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComboTreeGraphResponse parses an HTTP response from a GetComboTreeGraphWithResponse call
func ParseGetComboTreeGraphResponse(rsp *http.Response) (*GetComboTreeGraphResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComboTreeGraphResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMetaEntityResponse parses an HTTP response from a GetMetaEntityWithResponse call
func ParseGetMetaEntityResponse(rsp *http.Response) (*GetMetaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Props *map[string]map[string]interface{} `json:"props,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNtAuthStoreEntityResponse parses an HTTP response from a GetNtAuthStoreEntityWithResponse call
func ParseGetNtAuthStoreEntityResponse(rsp *http.Response) (*GetNtAuthStoreEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNtAuthStoreEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNtAuthStoreEntityControllersResponse parses an HTTP response from a GetNtAuthStoreEntityControllersWithResponse call
func ParseGetNtAuthStoreEntityControllersResponse(rsp *http.Response) (*GetNtAuthStoreEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNtAuthStoreEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityResponse parses an HTTP response from a GetOuEntityWithResponse call
func ParseGetOuEntityResponse(rsp *http.Response) (*GetOuEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityComputersResponse parses an HTTP response from a GetOuEntityComputersWithResponse call
func ParseGetOuEntityComputersResponse(rsp *http.Response) (*GetOuEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityGposResponse parses an HTTP response from a GetOuEntityGposWithResponse call
func ParseGetOuEntityGposResponse(rsp *http.Response) (*GetOuEntityGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityGroupsResponse parses an HTTP response from a GetOuEntityGroupsWithResponse call
func ParseGetOuEntityGroupsResponse(rsp *http.Response) (*GetOuEntityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityUsersResponse parses an HTTP response from a GetOuEntityUsersWithResponse call
func ParseGetOuEntityUsersResponse(rsp *http.Response) (*GetOuEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePathfindingResponse parses an HTTP response from a PathfindingWithResponse call
func ParsePathfindingResponse(rsp *http.Response) (*PathfindingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PathfindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsResponse parses an HTTP response from a ListPermissionsWithResponse call
func ParseListPermissionsResponse(rsp *http.Response) (*ListPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Permissions *[]ModelPermission `json:"permissions,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionResponse parses an HTTP response from a GetPermissionWithResponse call
func ParseGetPermissionResponse(rsp *http.Response) (*GetPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelPermission `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlatformDataQualityAggregateResponse parses an HTTP response from a GetPlatformDataQualityAggregateWithResponse call
func ParseGetPlatformDataQualityAggregateResponse(rsp *http.Response) (*GetPlatformDataQualityAggregateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformDataQualityAggregateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseDataQualityPlatformAggregate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPostureStatsResponse parses an HTTP response from a GetPostureStatsWithResponse call
func ParseGetPostureStatsResponse(rsp *http.Response) (*GetPostureStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostureStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                    `json:"count,omitempty"`
			Data  *[]ModelRiskPostureStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRolesResponse parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResponse(rsp *http.Response) (*ListRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Roles *[]ModelRole `json:"roles,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelRole `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRootCaEntityResponse parses an HTTP response from a GetRootCaEntityWithResponse call
func ParseGetRootCaEntityResponse(rsp *http.Response) (*GetRootCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRootCaEntityControllersResponse parses an HTTP response from a GetRootCaEntityControllersWithResponse call
func ParseGetRootCaEntityControllersResponse(rsp *http.Response) (*GetRootCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSamlProvidersResponse parses an HTTP response from a ListSamlProvidersWithResponse call
func ParseListSamlProvidersResponse(rsp *http.Response) (*ListSamlProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSamlProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				SamlProviders *[]ModelSamlProvider `json:"saml_providers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSamlProviderResponse parses an HTTP response from a CreateSamlProviderWithResponse call
func ParseCreateSamlProviderResponse(rsp *http.Response) (*CreateSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSamlProvider `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSamlProviderResponse parses an HTTP response from a DeleteSamlProviderWithResponse call
func ParseDeleteSamlProviderResponse(rsp *http.Response) (*DeleteSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AffectedUser *[]ModelUser `json:"affected_user,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSamlProviderResponse parses an HTTP response from a GetSamlProviderWithResponse call
func ParseGetSamlProviderResponse(rsp *http.Response) (*GetSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSamlProvider `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSamlSignSignOnEndpointsResponse parses an HTTP response from a GetSamlSignSignOnEndpointsWithResponse call
func ParseGetSamlSignSignOnEndpointsResponse(rsp *http.Response) (*GetSamlSignSignOnEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlSignSignOnEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Endpoints *[]ModelSamlSignOnEndpoint `json:"endpoints,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSavedQueriesResponse parses an HTTP response from a ListSavedQueriesWithResponse call
func ParseListSavedQueriesResponse(rsp *http.Response) (*ListSavedQueriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSavedQueriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int               `json:"count,omitempty"`
			Data  *[]ModelSavedQuery `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSavedQueryResponse parses an HTTP response from a CreateSavedQueryWithResponse call
func ParseCreateSavedQueryResponse(rsp *http.Response) (*CreateSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *ModelSavedQuery `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSavedQueryResponse parses an HTTP response from a DeleteSavedQueryWithResponse call
func ParseDeleteSavedQueryResponse(rsp *http.Response) (*DeleteSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSavedQueryResponse parses an HTTP response from a UpdateSavedQueryWithResponse call
func ParseUpdateSavedQueryResponse(rsp *http.Response) (*UpdateSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSavedQuery `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSavedQueryPermissionsResponse parses an HTTP response from a DeleteSavedQueryPermissionsWithResponse call
func ParseDeleteSavedQueryPermissionsResponse(rsp *http.Response) (*DeleteSavedQueryPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSavedQueryPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShareSavedQueryResponse parses an HTTP response from a ShareSavedQueryWithResponse call
func ParseShareSavedQueryResponse(rsp *http.Response) (*ShareSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShareSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *[]ModelSavedQueriesPermissions `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelSearchResult `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSelfResponse parses an HTTP response from a GetSelfWithResponse call
func ParseGetSelfResponse(rsp *http.Response) (*GetSelfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseAuthenticatedRequester
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetApiSpecResponse parses an HTTP response from a GetApiSpecWithResponse call
func ParseGetApiSpecResponse(rsp *http.Response) (*GetApiSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseListAuthTokensResponse parses an HTTP response from a ListAuthTokensWithResponse call
func ParseListAuthTokensResponse(rsp *http.Response) (*ListAuthTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuthTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Tokens *[]ModelAuthToken `json:"tokens,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAuthTokenResponse parses an HTTP response from a CreateAuthTokenWithResponse call
func ParseCreateAuthTokenResponse(rsp *http.Response) (*CreateAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAuthToken `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthTokenResponse parses an HTTP response from a DeleteAuthTokenWithResponse call
func ParseDeleteAuthTokenResponse(rsp *http.Response) (*DeleteAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityResponse parses an HTTP response from a GetUserEntityWithResponse call
func ParseGetUserEntityResponse(rsp *http.Response) (*GetUserEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityAdminRightsResponse parses an HTTP response from a GetUserEntityAdminRightsWithResponse call
func ParseGetUserEntityAdminRightsResponse(rsp *http.Response) (*GetUserEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityConstrainedDelegationRightsResponse parses an HTTP response from a GetUserEntityConstrainedDelegationRightsWithResponse call
func ParseGetUserEntityConstrainedDelegationRightsResponse(rsp *http.Response) (*GetUserEntityConstrainedDelegationRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityConstrainedDelegationRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityControllablesResponse parses an HTTP response from a GetUserEntityControllablesWithResponse call
func ParseGetUserEntityControllablesResponse(rsp *http.Response) (*GetUserEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityControllersResponse parses an HTTP response from a GetUserEntityControllersWithResponse call
func ParseGetUserEntityControllersResponse(rsp *http.Response) (*GetUserEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityDcomRightsResponse parses an HTTP response from a GetUserEntityDcomRightsWithResponse call
func ParseGetUserEntityDcomRightsResponse(rsp *http.Response) (*GetUserEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityMembershipResponse parses an HTTP response from a GetUserEntityMembershipWithResponse call
func ParseGetUserEntityMembershipResponse(rsp *http.Response) (*GetUserEntityMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityPsRemoteRightsResponse parses an HTTP response from a GetUserEntityPsRemoteRightsWithResponse call
func ParseGetUserEntityPsRemoteRightsResponse(rsp *http.Response) (*GetUserEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityRdpRightsResponse parses an HTTP response from a GetUserEntityRdpRightsWithResponse call
func ParseGetUserEntityRdpRightsResponse(rsp *http.Response) (*GetUserEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntitySessionsResponse parses an HTTP response from a GetUserEntitySessionsWithResponse call
func ParseGetUserEntitySessionsResponse(rsp *http.Response) (*GetUserEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntitySqlAdminRightsResponse parses an HTTP response from a GetUserEntitySqlAdminRightsWithResponse call
func ParseGetUserEntitySqlAdminRightsResponse(rsp *http.Response) (*GetUserEntitySqlAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntitySqlAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApiVersionResponse parses an HTTP response from a GetApiVersionWithResponse call
func ParseGetApiVersionResponse(rsp *http.Response) (*GetApiVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				API *struct {
					CurrentVersion    *string `json:"current_version,omitempty"`
					DeprecatedVersion *string `json:"deprecated_version,omitempty"`
				} `json:"API,omitempty"`
				ServerVersion *string `json:"server_version,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9+3PbOLI/+q/gq7NV8ziinMSZ7ManturrsZOMZyeJ13Z29uw4V4ZISEJMARwAtKPJ",
	"nfu330ID4EMkJVIP+hH+MBNLwhv96W40Gt1fej6fRZwRpmTv4EsvwgLPiCICPk0JDogYRIKMidBfBET6",
	"gkaKctY76J3C98iU6qNYkgApjmREfDqeI4z8WCo+Q4rOCI8VogxJ4nMWSBRLyiZITQm6xVShpFuEJYqI",
	"QGevj/767PmTQa/fo7or00ev32N4RpKue/2e9Kdkhs3YxjgOVe/gSb83o4zO4hn8reaRrkGZIhMien/+",
	"2e9FWE0HfPSJ+MqjQXFiF1OCzM+IBoiPYaCEKarmaET0yHlEBFYkQJwlY9StpiM09Yc06PV7gvweU0GC",
	"3oESMckPerHfmNHf40z3utsxhbnamUglKJvARH6PiZgP/JDq/RtM54EelBfwGaZMFtv/dUoYwugGh7qH",
	"MbrSw7lCVKIIS0mCPsJsjo5NdYSl5D6FWd5SNUV61EEckgBhFqAxZVROSYA+8ZFEYy4Qwf4UmbGgWxqG",
	"aIpvCCKfI8wCEqBI6EVTlEhEmR/GgV7HK71aV9DglZ7e1QAVBjnGocyPUk2JJEjiGUkGCx1yFs6RICoW",
	"TBMSRiGVCtowy0mDK5lsF6xdul928YZu8UpJy2yf3YcR5yHBbMlG8HjtTXj/4YFsgB7o1hZfL9gmC/+J",
	"jwY48KQSsa9iQTyfh6HuW6/8l9KucTBMig8zxbPD+Isg495B77/2Uma5Z36VeziiA2BfUvPJgPpYkcGY",
	"hoqIwfKB+tgTZEKlEvMa4/Tx0JVueZhEKE8ScUN9IusMlAg1dOVbHir8bVl66diggGHKmw8mjmlQMZLA",
	"b7K3gX9He2uYnedzpoTuV1SOEAoOMwW3MbhKSabHRljgac2hakiEBUP4fRsjgYYqxnGznKbg922RVFZL",
	"qRqKoioky0djiux+iz4TP9akunyjXKlWtivEUnmUTYhUVQPSRYa2yK5Hw30cehPB46gGH4DSQyjdLh8I",
	"+cQD9bVyYJOhVW93TFKSSKkJavVi2ZLtLpRUWKil1A4lWqF0qbAyCmbFONSCNrW9DRNEa6UeVkX19jXU",
	"QYLIOFQSjeboyhYfYnVltMoBOicEmdaRGQEKiMI0NIrsDQ6p1lftOCrVxrThXax1QELSYJa2+PZnmTa8",
	"i1maY+0gpDOqyk+kLJ6NiNCaPGFK6OOD4gjK6xO9PhoLIiPOJBmg9/oQgG8wDfEoJDBNOFb8XR8Grqpm",
	"aDovVfyfrj7N5+Yhr2nUYBq6OIwywhPKsC6+7iSg5zUNEvkpcKG80bw4i3MulCY1n4fxjA3QEWZoRIzd",
	"ZRaHikYhAWOL/B9NVhFhAcJoOo/0gU7PQjdHGJz7uAiIGKAjaEqms71kuqAegi6FBUEBNKTPlJxlDSHW",
	"QnFNWTC4ZFWLwoUajubrEK5ZE7cYhVUyq1i20foXvc32LBpghZEgv8dEKhIM0MkYMW4K6ROt4Dc00Gda",
	"aN0cZe3OaQK5Mnt+ycAmpAlDxlHEhT6UuzZMmT4axQrFLP39aiJwNLWHa5/HTF0hP92zwSU7ZIgywweg",
	"MejdMBWNLZxUM1NH53yWrL8ZL2FBxClTEgUcMa4uXf+wVW4EuvHqTYKlLKXcnp5Zr98jTNPub+4jtNrr",
	"92BwvY/VlilnCIGCJbaQE7BDEGR+N5sWgsEDJkmJHKBjuxnGHqGXGwwmlTLBdLWOFaGSB1JpVzu1U1Jp",
	"cAdoIcqghaE4ioiwzJGPLUakJUUS6E21nIYECduU9fliI+yY6un8qnjjiukF+hvNwKzFNmWkbnqOkaaz",
	"oxm76Co+2Ywf6NrplOIoaKKJ2OLbl9Fpw9uU0X/2ewmN6OZGOPAsJ9Mf9WmcMPgTR1GoW6Cc7X2SRmkm",
	"n/EsMidFIgQXsnfwm630WSXGEA2VGZEST4jlnz+fv3+HIjwPOQ40MsNAMxbgWmyGhZziMCTBoPfnx35v",
	"qlQ0dIro8ydPjK2bSDgQH/T2x/hvP4xfPPd++OvTv3rPf3jxzBvtj33vmf/yxf74xQs8xi96/R7ILIVn",
	"Ue+g9+zJs+fek2fe05cXT18ePPvrwfP9wd9evPhP788mCwsT9m4F1ng0K5knju+//xEH6MwM9vvvNX+n",
	"0s52RFAQE03VnBFn/h/zMOS3GgOCYMmZPLhkXn6tqEQzKqURr2iGwzEXMxLocqdYTfWXCziTIGEzlaw0",
	"2MtV1psCUkxqKUwlbIehzG/JZ09/DTIdoyvDga9AeDB0ZXWMKzSmJAy+u2R6FUeUYTH3HGUtoSTuK6I8",
	"qQTBsxxF9X5TernsXqMp2HtNuwlX+5hDgp6NBqntveQ2o2SL3v8j2RnXqhGReryYMtelHb6RcOaqCPBy",
	"ZL73jqmMuKTuNJmOqjCGP/s9X95UrY0Gzp4vb/JrYTp82jf/PrP/7l8yn4Th077+/zP4v/3qOXz4Af7/",
	"4pINBmbcS0a1xsr48gbp4WbX5k8tyLXu4FE25h7QomfZYw1+kg4wvUkArotVybf6E/yBgwBWHoenuQJ2",
	"lkaG6LEtfFHrm8qlWVwcrerxcD7jIppSH1Qyo9hKp9aqjOqYu+vT60TtpcvtlKgpEZcMtCurnAGcdQ9a",
	"v9AoZlwN0GEYIsYD06h0qp25HkFXsDwWl+Z2R7cIihXUumTpcoLOajr7u7ksyh66TMs4lNxe6xCULrnp",
	"QJoeLDew2pajCOCUNZhBkQw2ZsKasUmFWYBFgKB0Zlam2kCPcczFiAYBYTuSev/LY6s+myuzSOs7YF3S",
	"QgD7PpESWY4neSx8Uib89h+Q8HvtVjRhI1p4can5xWwG5xwfgwY4mmtJgmM11aDwQXG1d4xKzEEn5JfM",
	"rhFOFgipKVaIKhRwIktXdsyFJUFNl4LhEG6ZiPBg/DtUcJzYyuk2U8yCkARO8mtdnpHPEfH1hDWLG2FJ",
	"DJGWqD4/PCjV58QuODqHBUevdJUsJcQyxmE4d3xGH780V6Sa91UtDRcos0l2pcy52dLLDM81zaAZD+h4",
	"bjUeQZz6otKtMWdpMDYAV6AShfSahHPYLXdGVByKmNYvWcB1K5LPiJrqv24FZxNLYox7GWJaFOlRiClb",
	"peAwnjInPemPTWX2O46sQrJCdmd7GvFgnsxBeWMes2D30EgxnsMI9F6q+D9/QNT/jiv0Ws8k2QZDZGoe",
	"UR/I3uczItFY8Jl19KGcSS37BTGOETRAJ8foFjuPCEeKdg0umeIo5PwaxZGGi1MnHE2bjyVLazba0rdn",
	"lbX19TQchu/HsPOrli2x4Kbn996f/SpNjyoyk0WVL8QjEpaAwZ2SS34witzJcRmENHnATWcvwhMSeFot",
	"8kIqlV6Y7BGioEJiIfA814I1XC1U+LhagXT2Nau6WREHa9XPmEbjiDN0O6X+1Ol4zjiYImpk+Klxs0nP",
	"gOW2xcVSqZ1xcMl+ndKQ2I+gd66u30dZjZWLxDSYOYtmbJOXDLTdRXNkQMdjIggsh2VQifOM7oChgPvx",
	"jDA9BA2XwSV7raE15VoH12LHrAVlGRfAmGVqGRUYVm9h8EmXbmnNxo1Mc7qEoehLNuMBCQejqQeNDcz/",
	"DbYU594Ms7mzo8gtMNMZDYKQ3GJB8vyUc6S7ciQgB+g0JFpUaiGIJ5rVa6CX6RPPn718QBxVz/Stnqm1",
	"p0jDWRPBr8Un2C7U4pLAwQRIyycChJ+eALqlLOC3hgiVoFGkWawmAayIsa5q2knX3W5uzLSeygX9g2xD",
	"SIZ8QlluSz9kOygRg08f0KZl55JKQsfuxpgaR8Os6q/1OuvLqtE6QK+MRphqYXq3jDg0J4JLhlEkuDK6",
	"YtK63nUeK3vAzh0u+qBImm6NqDX92gGBwctayS6ZLwg4yOJQ6mrkc0QFdH9N2HdAFMmqGVtEsjTGyFuU",
	"Ycnul90s2R81uzG8PtVQlZb2UYh9UjRtZShosdVDNI1nmHmC4AAuGzM/J47HcBwqu2QpyL/i1hcm6Ci9",
	"bH7w27fyO3N4474fC72coAhFgusNXVDUe/1UGahHk3bhC8J6AUtlw/vp4uIUmQLI5wFwW/zZ3Ku+eJK9",
	"ZX36pOSeNY/NJb7XqdO12wJ3DoB1MZTY66c2TXAELNn2DK7Lujt7feTt7++/REm5MspKzwiWi2Z7DrAi",
	"nnU2qUkfqxxfatyjmAtoZGu4m5R/gV5s71LSKxMwcV+R36/66IqR36+MtXPxEm752OzJSFbDEpzAk3rI",
	"nxL/WitrlvitvJVGAYcBS6PSTOgNYWD1wEgSPQDNqbRqNbhkHrqi7Mq1Rg0xJE3OsPKneoIMkRA4olNE",
	"ljaKEDR7cGSH3X9D1NEUswmRh2HYf0tmIyLej6+ge7ak/8S0AgNZaxiMsoNfuI/DC37EZ1GslS03APj+",
	"jeBxdAVbFmGliNCL/v98S9n/yyj77uDby8vb//7u2/7lpfwe/vz+L2VAqOPyWJ/unB2zGd310dVEmf8T",
	"/U+ozP9JniIz7KKGT1T9QZsKDcb8/1VApt6qOhe1mqNLOZC5ZjcMRlMLBvpOWJXpfXDJtrTqdTjZ8pkC",
	"8226D146QV1/LRa2kv1XXMiX8rDEZcCNuHBuNArWoLfcmaik1zouUSDEs/f4uMRPYZ2+2/NlumTnJHNm",
	"zGlS1o0BrvXxSGueRsr6zv1JEPB50irYErAlB7lYahZAlCeJL4gqalmMkEAOIyzlLRfBUBBpShXFXtpC",
	"TfmdH4RxPChR82aYhkMcBIJImbuAhV/KZjimQqphpamGymFApV6hoHwm4FZdWT0SlPk0wuUGIsFDM+5E",
	"m0zGS5naf1bKnxcVSIln4dA6dAmr5NVeVEviubOIMxKU6dHOFsYZqWFjMxYJvWNgVltd1KAdTFSrhqxH",
	"4v0e45CquReFWOml8/BkIsjE0sbmhsDa9TRmPXN+r2NBbLJ8OPByc3VTrDNG28IfsSBLGvlYakNcNBou",
	"rP+YAhvaDomAfdO1WG9SYC6mnMkpjdKqNQgns8Ul5+CYVYgqxRUOM7LDSqzV0iERf+t4sfV7To6t5y+2",
	"fCmyVFvkpSyofYBTPDFLWls/PCDGxq4ltJZfW+uBpwRr9zwiE8rAaW+9/svWjLB4NsBxQJUX8omXHtad",
	"gyg1Brd+T8Zg/9F9YRrGgpS4idr27Ku9KodesErFs2RyxtxtX31wkRie5hEoKG4kcopFNIXrsn4PcG8+",
	"VA5DozWiESmbVQCvqcyTIV2n38MMh/M/9N+VDX7iI6/anFExrViAed1aOWDnfuYj0Exjo4iC39mV9/QK",
	"nTgzmIeunlyhM4KDOXx4eoXOYth7+PjsCunDXUgUgc/7V1rd8klo3Muunl+hCzojAXofK/jihyv0Gowc",
	"8OmF7snOHL746xU6dNOHL/52hU6xUBQuz9Ku0t3wnvaf9J/2n/X3+8/7P/Rf9P/a/9vHMhYBCzcbYw/7",
	"it4Ab/KWmYTSYpklA/3RG2MgjwXzJdeq7Y8h58FPmhwQKFEZsrENgn0nINlPkdE2q/dbUHntYd8nkdKr",
	"myUg8y00E7PMBxxqTay0ydUir7ZctxpF8sMAVKoBDerqImnNhN3IEuGO/TDr2ZU9F1Ds44rffCKUIjOt",
	"uJCqItY0UfkzGFIqf8/EQyijOEVEJKgklSOcRLzqF8HjqOK3/GM+gwm2qIyPQ44zF5NGqMKNqdKEKxUX",
	"VYtigwuUWTlTfaCqCOeqcroiZlZ5XnnCTd/gNZ2frVkxBI3K0p/K1bFyrGiG0IGkGUiGsvTYdNcwCXg8",
	"Cskjxkn1BHcBlCjyfM7GdOKBrnz/QJIT9F96guDgPQvnCy940vW9JvOlficrGwD7X4lX8tJllJIo87b7",
	"/q3gDIz4w+QYV7ECGVKqtNxIYjTtvH2mxmE7XR/PtWFwVzqU1Iwzl4rMhsnCVpTPWJ4UntSy9ZTu3cJT",
	"8/W38cXz7W+jfaq6wcqns7NuUyt3oPm62Zbv3erBaAvxFBaZNnReNDD2e7eCKpKuE7hgBmSYuLmt5Cpp",
	"DLA6pfNjryjekDF5hg8UbRrZpcmJ/KzKAOHbhmkTReQRdkMFZzMbAqVcc0iLXFNWXkj/kKfy4mX6AptY",
	"4VNYNZxI0BkW86qhlFk9lrCz+6deFva1hiF9Jesv/9Hw6ZIy2ae1tajUteHJiPglxJpw5+RAHZi4ejN+",
	"U25Zci1WX0hI2nD/ndlrW3yuao4rGQUYNobmHqfsZqdmA+W6a83KtTUrn89mVK3bWSbCR05dzpgtV7Zh",
	"nkDV4KmLDkKNR2uevgxpVHrxRqOb57VaSexd9ais3Cj758fFrpajMVbTzG3mPTsO0InelRlRU14hZMDz",
	"Ty6jk6JA4Soapha+puxLLxg4Gm6wXiaC3FbXajrDfmal6h6dVpaD213j1Lk+FB3XqLdcLA7DJPhQkZzN",
	"6dditUGLZtEbwmP5xeH9UwOiKpNGQCAwY3NDzTWZD2+we4NS/H2GGZ6A+9lwWTN1rC72DeHydppYXyAY",
	"5TBxQahoUsajxOxQUUQRhplqaozp925mza00RZK7pxbNjtZ2SGs1+90u7SVPZ0gwIU0pLqmsz3KlNo3g",
	"aT07RtJSSNm1R1hgzpPBsw2qj8OyK/4bEnKfqnm9her3qJlC0UnKjK1EelqbQZNRQx3wm2DkXM3D8nPM",
	"LQ1M4Ma1NnjMmfKoX+4CElac/HSl13hGw3Krq3tAUftolb7UCufRtOT8xya5yWeIe6T3ttw2MQK/wIaL",
	"rmnWszXh9LJsDU7sujVoP11vTS0z+yhku/SSjXVS9LTDAa26EZH0D1IXAWVv7JaF+8Bs3pyDMB6QmtIq",
	"z7KynlyVYwb+1IDsnT9X+RQrjpRjHJBy+gRib2raXYBKDX+10ml7KTjqzb5GuwnN5lsc8bDCYfQOGEwi",
	"CYo8RggjGEoYCfav34/HVfeqVZPYyf5uxBpqLBAgbssCvymtbVHi6f3hIgBH9tIX66riVppNancQKx5X",
	"OHdvQ0hMccjlklf31au4jNU3WsNFEqwhtxYoAPvXWsFmwVHlaJfwCXA+2DIP0T+fV8i7RhxGTnFUZWGu",
	"K05Txcz6fd8rk5LzWgiGn/govVIuXCysvmM2XgexIMEQfOFrGZCNS6Tuu/GyGM/SJG+Kp9sotSRlOmlu",
	"UDIXiKXtFvMmbM/6BaH+m8qXhSWpcx8/5VI5w12y58mXNax+G9rDwfIITyBNkJ7NTI8rC65l081Yg0v3",
	"yjk3N7DoZ92iq62fsjG1LiOpGyJkvVuo1TzMC6iMQjzfBi9bjx+V+8iZmgrL64ZVC6xrFataj0El61bK",
	"luoyo7Sunul2RwNr13Q4pZywNrFuh9tlJ7OMyzXkYOtxrPpBkhKO1IwPpVynGa/Jc5YGW5ThHs25RSKR",
	"7p99uyJDWKk+isNwqEQsNY8p+p1nFdfyfF4VCnBFSq3y0kmSq3XusCtyUZX2lJlgfb+diiQ3pR0w8lkN",
	"E360kReAdQOuP04h4rDKK6aQeabh5XEVX9oS7T9i+t06va5eZZskzb4f35SkF+lwdf88XtZ3i2Rqzk/3",
	"z8vzq+LPtnbt40xzfKyvo9n6mVCVzWGW8So27dQ5otYSRKsaSRIKri1jklSAje0H+8+WnPGHSca/emfl",
	"NPvdetNows6SzHDbO4SulNQrHxDUYnz9bKq2tddqLWe9zMvg0hUwv71Ng8ZtfhgvP9TtxpP1UesbC/x3",
	"+/y22OKuuGodLroN9WglY13KSOuyz/5iotHavd2l+rZFXrWENzXiSK7iMBO1sgnDcZEZvBlmdGwlUeHe",
	"zX5ffIlnjAiNLT1Jr84K0eBqvFi5GMuFRIL4VY7CcAv07IcXMp4tm1SjO+sMsx1hSTzsAoKXBCj5TKWq",
	"4Jsrnsk0fARRduIsDKc8vKbJLKBKw2yOIUY0lTaj2CAboqTu7VLdQRuxtftBv3i+rUFnTj/F298tPJDI",
	"JBhtpsWZNGWldxNpPrQ1h1VrZVzsv11uZb2DWfVwKyXw/TtIU+zjYUXkp0OTNghC0kCgAghfQ4SNjrI8",
	"ZEGNRnMRDla2bWMd1GnXhUVY3aYNkFCrURdMYVWrDlur27Qlk6SKqxo2WqFj7/lm3+FZkrjOFDShi28r",
	"tq08zkONQefCQqwa8iTiNZqcRHx1S1ZXW9kWOHWvai29XVv1Jnh5KG8bgciWAKaC3fK7IZgQ6oD/siug",
	"NJpFjdllY1+smiOPazTI45XtmIgYNdqyoTNWtefihJU0lQsvjSiDYKyQ2MckYctSd3Z5oUkSZDvM6ENw",
	"t7V6+OBPv3zwy5TghUPR+qx+QfUrMm13x9dAQ7eDyz7cLbiUhRCxv174hZrv2+t7YNgprS1yxwSrWBBv",
	"HOLJww9uQlgSdHX1XtR9zld7MwAvoM7pUdQZxDLSG9OQeHEUcnxPLxOa2yrqmFzLQzvem+O83eU1YgZn",
	"XmCusJwto4pc0NN7h9djYJfnpUmq+r3X6bALv50ujXmc/PqPqqgYp5vmUO0nkQeHMVML4QIaxf5MNytj",
	"z9qhWAsoxJuMqZySoNozprnwSzNQ3kNPE5OQR22VhS9bjNLQwfduWQ4tDX9oQsL93hGfjfgbgaPpmZ2m",
	"gXB9n7X1kf9a8Nly9OdKVHKAXKktsIOkrZ+wnJb2eEa20c8FXz77zO+Vc8+UOd1+MukMCKi89kxO5Pun",
	"jxzpcpIqckaNG2eNkIEbkK357cgdj4rntZNZhPXJ4FBKoirLrVzuiEvQ0Dd/0b6LRfcFVdTH4VCPNT0s",
	"Ng+a+TniMhZkSFlAPtfcPUWJGP5BBC93Ty41Syxdb34fnSqbHoJqn1dS+d70CimjGWwUI0/iWei5NBT3",
	"MZgO3P3X9yCiQTSkUsb6HCho7SpS8trl6++ukwhDrJSgo1iR4QxHEWWTTZ1GoiH2Ze0Ry8ZrIqPhjCis",
	"D9JN6tRfxpU0KemEeRCt0aRhLLs5iYaxCHerfqZjuiEBZDemRHoLuL1fAiGKRyH1yy9YIc9EffuxnGJB",
	"gqHiw/aiF6UrfQ+DdC5IgvrPIpL5NLFKbIIhgoU/zdze1Tixbo/zZa/rV/MNE5pR4Ylsx+IaMzqmJFiI",
	"GpNfoMrgn9V5w0Ms1TkhDR7RLLqirXuAMVGByo0OWExIs/gD+eVJYmUsmB6DSeNIvyXrXhYqlQfL16Np",
	"RzYux+pTVvkCuCADC8JHXlAi/kMErwwRu3Pysfnoq0LHboO2liyS3Ehf3MHL78NYTc/XCgqZjSdZ7tm8",
	"aGze1qvoOMTDJMVKrTuTfOK7LY1jIV3e6lHAPYJJOb6+53Y2BV8Dx/1Ura4tj4oZ+2pkKuP1XpyXJfLb",
	"hj99uXTP1CnyJPd1jRfCkIypeKlscopSifQQEB2jK2jiSn/FuEJXuv+rQa/ORVo62BfPSwdrvq6hhjYZ",
	"7Ivnmww2zZSbH236fVk2hnqDM1WuFobXZHTuCm7hUr00e+5hJg9umj/WDrtuUrfac9MNbLLu5b5x7tuV",
	"fu61x6kbWGucJvlpLKian2v4mgH+9Pbw6JxOGNzgF/u/Sn47QH/58fD81Yvnr94dvT9+dTzUNYfnJ2/e",
	"HV58OHtlclZrZtqbEhxAQH/D3Hpp8ynrieg/CPCen3+9+JFgQcSFe3U9go+v3YL9/OsF5AbLjerQ3Nz8",
	"AdcMB8i0gP7y868Xw4v3/3j1zowGuBSsCvyedj9VKjLGd4g/fWzTdi50kvn1AP3l7PWRpsTh8eHFq4uT",
	"t8smnG22ZMp6PUhgC5X0uzC50ZRIt4LoLzC94cnxku5z9YsD0IRA2ZgbzxOmsK+SDLaaJOMo4kL9XxkR",
	"XxHBIzmgPG08k8vtVeKMhs5NpV6/B+YMWGB5sLdnGxuMdC1ICJh6sA0o3zMue1WOo4enJ8aPLhD0hkhU",
	"3jdmATris1nMqJqjV0ZLHFyyV9bsgvANpiEe0VD/TiUKCOOQiVpSNoGOrpL6V9DcVdr8FdKnusElu2RH",
	"ZrGQXjxNnJQzSO5OAKBjLioGaPI6ECEH6IKjCVFoSsII3VI1vWSZKoVJ9FEUEiwJ+sQpQzwWl+y38xD7",
	"15BjHop+/NYt9WQq1SCc7/34ExTZ+w7G/F//hQ5zGfn0lxdTkh2qXma7URKpW44gOwR4nuaqHqCff71A",
	"BksIgh5IWC1Dz+jMJUq+ZK+5QL/H1L9GSn+DuECcGR6NfByGsg/LrpuDDNSjOZrzWKCR4LeSCDTDc2TT",
	"ako6i0IiFRI8VmSAXnNxyWZcEATMzGx/yNkEhfSGmMmA3DXeabYnQfSKERaQAHGTo5pKJM3ARTpwvWD/",
	"BeOyLAW4klsz3fYtDUNk9F0zlQwZjXkY8lv9yUASJe+yEHiEEvTTxcWp6+/gkl1dXV2yVbzMFjsZ6zVC",
	"PCKmqXdE3XJxjRQeASlRllvDPpSG0UpiVx3hCaZMqgRcMxwQFCsaUpNbEnyyk0EPyvZbL7yhlTRVep6W",
	"+mjKb8kNEYgqvcqZtdc9kDniLJwn2cfBF5zMIi6wmCMT8dz0bLs0seYRHisiEEaSKIRnzm8QSEqTgF5U",
	"KsglE8RbyEFpNsgcjpAvCPih4zDd7wUC1l+f50kD5r1ISJoLFFFindsXV2WA3nFlZo71MBdoD42IUtYz",
	"PkPNBUqeIxxKjqyyjlIgaLZhe9ZrkLRqps7UAF3o2q7iYprOcSbnfR9hiW6JpnOJboig40wx2/QlM0PT",
	"3d5OCdMLQ2DIliYkETeQJb64lj5nkkqzfVNBCAKX0ggLJQ/0KJMUs3r/0cmxgzBUTzPw9mHf8SUbYUle",
	"PEeE+Vxvi9ZLUCIxYd6S2J4iSnwCrC3LxIGodY8aR7nOgHSAapeA+0BPsgzK5ZL7ki1XLMyC1dG5bK+X",
	"7IJrLC3yswwLYIQESGnhw8C/FmFmpKte4gF6hf1p+jkpFVi2lZNSupjPZ0Ta1brl2a27SPbMZPyn0qDc",
	"8r+8bnNll7J/yfRWqqT+P8h8sQEsoRtHqbDJUyynekMiwQ3XMOmyzQiQnPI4DNCIXDKguIAI2w7cLqBv",
	"Q3pNEAbXY63cfIfcIEwT12SetoEyTVhOYutfsghLectF8N0AvWd+fm31+JPlNBviYwa7pXvSfSgOG5cX",
	"Q1qCArgD7sczwpSl1BGPleavuhawf9iEBTTbxQZeTJkfxoFeJfIZgyi9ZHzsmiilB1c/s+kfThJdRJAx",
	"iAPzgMfKAj3Mg0v2269cXIPLuANSnnBSbWWVYjj19wjzYrmHhaJ+SOTe06f7T58++WF///mzF09ferYn",
	"T/fkqSnx0p68w9MTp/0UuDs6lSQOuKd5BXpllgQWnAqpOR8yyU/0vlFGFQUYwHQ0yXnnPx16z354kRH6",
	"KbFgo7XaBq7J3Ej4aK6mWu8y3xOB/o6mM+wPGLn91jxj7CMc0SE0NLwm8+8SXL+PrJP9P8jcKcVgPTP0",
	"b3sKKbt2e5byG3+KKdOQoBJFwoTzQoJEIZ4jrBT2ryUo15dMEnKtN3TGAzqe5/ifSWyi9bcPZycDdALr",
	"AnYgjUnzMsfHijDzUqCkKmZG6ifffzg7MevJOAoIZJvXcp0F9umQayc7w5WrrSehQZlf8f9yG3yA3ry6",
	"QHs4ons3z/a0TrrnEhGASrb3dPBUF08YL2TVBlsXVC2tme7oADLXfeuyGdmZ/7eb8jAW9DsgR/QB3ull",
	"Bm5F/jgW8MQCNg1EziK1vMtQS9KvZoDffpfSi5YoGVJh5HNTSjFC1FS3gumSpcYXPXpQucwjkQWmnDYJ",
	"7IGgqVZIFXf0Z8nvkmXpD6QvDwN4YIIZmuHPIFR0XWlHZZ+kSISDwAiykhlcstEc+bFSJgf/GOEwNDUl",
	"Ggs+y84JlUwpKQM9m5ow91ssgkrCevbk2RPv6TPvydOLZ/sHP7w8ePHkP5WklCucqGnDZAh/h9EMGL/9",
	"9rtK8nKlfzt4uv+xHbr6kQdzWG69tJa4Qiw3IK5k8mik215GSHniyfEulGddhtFEeB5yHJhk/nmVaIBO",
	"zPh8Lclup8Ro9YIYe5oZi8+ZAvVTjzI7Qcv6Yk01mM1v8bxvjqfzhKFZctMbpvQ5jee2JE9ENFGmB9Cv",
	"NemRWaS05ECofP+hcLo1rynDYTjvo5wWbCUFwyEoScBeoRXDREEXtiemwCph+rAw5nA0MZn3s9w8P3Kr",
	"aQ+h6b/bnofm22+LROQGbvqxs/kmpwl+00ff5LTlb9B/G14/pEFlExk9+ps+WsRHZbUEmt/0UXYqblF7",
	"/V5IfcIkGAWdUS3C/pR4zwZPCkau29vbAYafB1xM9mxduffLydGrd+evoA44GkJUoV5eJeplohX0biCu",
	"hj7i44j2Dnr7gyeD/V6/F2FlIts7QWQMEB6JQ8iQYO/HF8znxkhRbpN69eGXQ3vYnEyMfq71YPQt/ICj",
	"KKQaqBz9+NOr1IAF59fvBj0Yo9FMToKkq1d6NJDiJ+J6AfSQnj2pTB6TlNtjWh0D0OnpP3/yZHWVEQ48",
	"u7umztPVdWJmHf7/IIGptL+60piLEQ0CE+Dz+bOXq2sozr0ZZnM3PngT9EOdSekjtWA49Mzh2SNCcONt",
	"KuPZDIt5uqt6m3qQiVn2Dn7r2Y/pBvc+/qnJRuAZMTnqKy7y0iJ7FiQRKPjmqi4ht8CzwWr2vlgfXBr8",
	"uVdIliUrifFCizcJrmdgM4UX2FhhZKvDY15p3/BO6A1h6PDYvjYtkNsbog4D43V9jBX+p2niHAZQmHV+",
	"HOdcwMM65PMwnlmDVhrUoY/SSAoDZ183jk+JBVxyoYajubtfwKvuYnFEBzAmOYCWBroBbwRerYvD+5FM",
	"KAMpm+gEfIwEZhOCvoWjnKQ35DsN14Wrsf9Bx2QMKbw0am3o4LSVGWWxRPtPUIDnsmpiCoMJP51WvbdL",
	"i5N4ZcRHyQzI57VnUDFmwoK1RrwCC3ajrmnUq10ajjL2GjzHAZ+4mxaXaUBzV3NU3/skjRteOoN6F++a",
	"qFw3gwhPKDO3Pav8UXL19PJ4t5QF/LbMUdCm32mSCD0oSaD3Zx1n7j8LF0Hv/3HfhcGT53VEm/LGWvje",
	"E/HxhqiUsZZw4IxM0awVWd7ag+dd5sppy3KmwD4MY0cnxw7yEO8wQXwif3omf7BWYZ1jS4qiRcjnpBnE",
	"U9n7kiQu/7NSbOnlomzMrX0iZlZGge3r8OQQHR0ixgMyKJVRFB/hV+bFZdNFMixlOg+E5mP2tVQVb1lO",
	"FubNp6enYXySPRfarsPXbvBl6MKsO5BPBlXmR7lbQK2ooAE1MNTvgXf7UnDspfES5VKgYNDs+gicTvuI",
	"izS8B5zLkxSd5uzuY4Zs01k8rYLSUWY066HKbExD6W4rWSHfsJYN9N9wfE5NXAv18NSYuBffDwv49xHG",
	"fo7sHgyaGQ7nkppHNRudBvu9KC7B/esQTzLOOhyN9AkGQb9/gLUQInWAplFE9rk+cRy6MW7DdHCvCTRH",
	"YjB3hNPJZ/WuiEZkGVFlt1hKorw0nXIpe/6FghMDXOlLrdNIbp7o25Bdxa3RNeDR8RvT8jrn6iutsl31",
	"0ZXCkytzXX81I7ORiwh11c4Ru6wHm0urcfORIBAXiwzGNFREDLKHyrKOFJ600o99ggTb2UqH2Y3cSoeZ",
	"19XlPdJg+/3UEsjWPuThBpLf2pEa1bEhCaHOpmaE8rP8wpMaje9MJvYmJ/2U69Q54Jd88wAP/Hevl2iu",
	"vISNZzUTKHDiCuxQQ/kIGbBLhM4RwEYizOxwHXPKSxpTLJU19lxPpPqRB/NGRN+Qbv8s8T5OHRXgUk4f",
	"9gH+WpcpTCRvf/hzJ5BtOqcOaVtBmqHK4pavga8KZW3vS4b/OiuUEQFFLB3D9yuxZIotYKnp0fHhXMc1",
	"txA9eVkDktZTDv7UpGG4IlT6rLSYm9BeJjJt7wgzxpWNKIwwMroYCsiYMnA5TDZsAOxyqlQ0dOEFnz95",
	"mTA8eHvX2x/jv/0wfvHc++GvT//qPf/hxTNvtD/2vWf+yxf74xcv8Bi/0JToHGF7B/qs9Nx78sx7+vLi",
	"6cuDZ389eL4/+NuLF/+B1321NSaYrHcrcBSBflRgHN9/f8TZOKS++v574xLvXHUFNX45ddbg8r5g/NgO",
	"dgsY75efu86IXpkbku0AjebGuF20cq3CbSdKvh4rchnFtK/cFW5nTo6dPTc7QEF8LoABCEvx5Zc3eYm3",
	"9AZn5QvgSpuUcYZbKStNsa3onXm4VURQqQOnUv0TjpJF/XPQKaAd18hyDesE2qbKupem2ag2Pp4RFQtm",
	"zI9TKhUX1MchMgYkOaWRRHSMGEcfzn5BxmpjnuRExIcwJqusk0eZQRT43d3YFztb1cZ8Zz1rVCbxSy3D",
	"VMebWjRcZTQGP4fZ+6fYDO9SsWnAfmcj7rn4Tgn3TXOnmc4Ld/Xmyg5qIyWITZ6yXF/KHVAg2PM73e+K",
	"i6HXwMi0Bmv9epLXqmk+qKprIOtzusBLC649d6T1jKa5+GIdc7nT41Idek64THrpulOWYrgZ4AW9B5qo",
	"9Gq7K/4Bnv1JapoV/j1Z9g0VrQ6H3CXgMoYBFd5C+SNbfIuwNeMZ5i4lawXK7jB6NyaNcgLq9ID1cGzP",
	"Ukv9P+D8ZQvC4zhWfou46rT11va1nvPdWj71/XruJonP4lUfXeWXSH8TCaqJcXhNGXwm7IYKzmYm9/Hi",
	"N7YUOK2AH8sgjbjU+nEymVkrrh3ZhWqlw/xOtN5la/NszesoJw632+Pdv2+p49qSYYhr2hHs2q3l3NK9",
	"Z7kfDjFO3HWaxaaaxV6asKdawbAPZPi4jpqBRnNkBQ0EnKundsDR4cf5PwzHrmHqbVdy3oEgu1Nh3UnO",
	"FiVnHbmXyau1PF56JjZxMYI6VzhsdIjujtX3xa6ePVBrFmsR2om/9cRfzjL2eNcj68K7/PLg+NXp2auj",
	"w4tXxxDE7vTDBaJMKoKDAUocLzL0mCzgYKUDxrkrepyOYX2fjDXVfjdeT0bEL9H+m7pslC1FDceNp9t3",
	"9g8CEgxz9LzhEpWlPhFkxm923s96Esi49AadGNqd60kFta8nfZb6dlX0VJPDdHyl4ysdX/ka+UpzzS//",
	"k/t6vQcbyehXvtw4Twt2LzhafsFR/XYh2b9H9ZDjfPV8JfLNEo2IXaXgnr/jyEKtO/3mzDe1xpZwurUG",
	"mWGT2zyrQ+xXT3fr6YJ1Ah5EXEo6CokNHIt0ZWQqlxqcodQpVtMLW2Zl3AM0mtt7aBOBHpI8yPwNNaIS",
	"XY1Nuvc7DHtgR/AQ7JrVqaUfgE/vg75JK8FJwkDNb6cQj3aH8UZTnO8udA0EYEmyM8ChKp25XB6r5scp",
	"efzharZIXJXBbpYRVAVB7H0xn4b6E6jqJhoyZiaB8JZ9ONMBVjtv5sZTW96Vpoqs9aotg1BsvrEJWBEX",
	"KGbJJ0HlNYqZomESVVcrm5Wm2ET2nVF5vbX3cGY4QxhH/dTA2ZyyxeytemZDl0Z76w/tYN0yVLXth3a1",
	"PV+cvO7u01o2OGQQJgwWmnKsOKBq9ZO4JBg2lEchn1TF4tK//8InbftdrvPorI6vpnXStGeE9G8XMsx8",
	"gqSU9iPlTP+VnrD1pzR0t/5kErM4r01zMG/Nb7Nsh2FDXXxxm2DBZLhwbxsNQ0b/ggwnabopm0djIUT2",
	"AJ2MIUmEjCFCf9A3kTMhx1dgome7pBMugLZj+GULYAa0hZDfZbM1Cft2P9mnaE6wyC5unanD6Naa+Q6f",
	"e67qBqdH6rY6a83xJgP4tvozJqDdd5UxCrYSChC44Na7Kn3XZyPKpiYQkwIHME4DZJpBSbuW+ZPfNbdm",
	"5PcrV9AmzoFfZQxJQG0q3jGmYSxItdHEmF8fnKeW5pVNL7G0DuCFfNKF3GvbLpJoZ1lNEFS8HQbWy6qT",
	"Jod1SFwilmUv9SRKittI/xJhyCrr8jJSkXmAjRIIFd/vuXaOba/rhIE19EeDPtKQ3YHxszGHdCN6ZK6r",
	"ZkdJ8KDMu6vZniHhZtf2Hatb943mIufIMLxzgoU/bYvj/REL4inCsK7zxfzRRtqpPyDvIHRXyhL17xfw",
	"c5d8qks+1SWfujfJp4BhdPmn7n9+nAyHvZ8pqAx7r7zvSWTR+imo9BLsfTG5ReAe489ltmJwupDZjEKa",
	"0WjV3SSjIjnZxV2okcElOxmjK5sKZpjp7Qolq+HyzkqirIGNsCDilCljaRPGtJfp9JKZNPQYScomIbHj",
	"GqAPSZruK/MO6QrZK5tMd9Coy0ucSzluGUPdQdcfsE2bD01RIi+ZbVyz+sIkLvTwF7uDhmdcRNPcWA31",
	"SiViX8WC2Mpa0bi6ZCZptdugQpM4lNzeMUl0pbm9NXgAK8+UlMaAXa6IVKUXK952JVThfH0sNY0I5MuG",
	"1kmAOKtSPbIvKetTfb/q6sPtQZJfRxPMAB1zYujxlotrc15dQQtV47VP4UoGl9wjlpi1knw20Jp1etL0",
	"tDDeLHmNMGTDN1Zs3QeKsJQmbmG5PbAwn16jNbxw/WjtxgwPKJF8juAAOEDvWTiHJZQbrWFhaNbu3jvo",
	"aSrv9XuExTPNqu1HEwvrY7/OHKi0i5yDdazXUqMm0N/MIG25yWYfw8s2PrakDJqaxo1W51ItZHDJYPKa",
	"82MFnl9LVgAQp//8u0VtlXqqtbH1lW7Q5dZYA0mUi/waRxERCJhDdg3M9psMznYRIN+5Fcq7WQ2jbZbS",
	"xdMnT8ru2pNxO4Ox1S5IgEaG/5tI4poQ9Z7PNFU9KXeP2EjD5YxYDbdkKxK+7vbgdkpYxVqlYnOATpTd",
	"B7lUTkKmSHQYhvCXca7KySxnntMchfqm1JiSMJB9NIptSvr0Ya995ZlqznCgDEhEWKCPL5YjXVMG2fCh",
	"OUcvA3RuaOuSWWH9d83Kr8x4Ih7Fes5ITbkktp+AKExDibCLtmbO0xERMGXmEyOpyjX59GiR/x0eqJa5",
	"+RWemSx7zpx5vLzKDN7f4G00XPG7RO7Eyd6SDjY+R21OnZIoAHSp9kHlJSMUdDCjryAuHD2jb6nSDeiK",
	"7p7VEqhu5rscvaceDHYcl8zpWdC7jKOICyUzHLqg2qw4+jUihMzetU9ZJQdNSysuHaMVkwWyqk0z5bEn",
	"2yEYXUBxdAWdXuXIAL4ySohmYobtGS4GXyZDsY8SzMYvro6dzcfSA/lFTtVP6S/i4RxUc+pnFPNFJrgg",
	"ZaVT0dDFVBByyQI6HhMw+iRt2CUHpuq8yA8umYe+/94s3fff2zJN5cVhysK/Ad76zQITv2SoOAWn8eUU",
	"dz0vCo8x9LiyZNZ0dG77S7YeGVahR1WHW3xnHHCoKkP/wkhhyzca6t8tOdrnKJ3BZkcGm1TcuftP+PqV",
	"5fZt2mfMqRddmNNJiYUmf7Jaz0ajT3W1k4QbVleZKrwyR3iXHvyrQ1NFXvBj9COWbcFpg5TCi7BI0oPj",
	"UUi2lyDcgiabJXwJgI5yY+jSgndpwXcNX3+B4h4Pjned5n+FLOzy+3dAvgsgL4QJfTAwDjkPplrF8WK5",
	"ArrmQfSPusZPuoY+agln1it/dvJBluKwhl/LmAqpwH28j0Kc/AkO3kMcBIJI2U+5RbZkyCeU9Ss8Y/ou",
	"/kBrXjLlD6nd7Fpx7UsWsJ0In9k9aiuIaYYMWulyS96fcawRuXTfgJy30hm4FHV56xNG18A7SNfp3OZb",
	"dpt30sNJ1YzocT/dUVZ6hBEjt4uycFCRnF4PdoPn0E1ug8xWALlaLNZ0q8tWlER5kviCVPi2rUhzD2tx",
	"b7KLGuR2uNxuXnv0jtwiS9frwHOJCrr3Rf/TIEAa+UwlUN5KOJpKCRy7uGh3bNzsp44fK+3MEJPMfa6I",
	"4LUJRfaXmSwWKOsbWX3seUPUEgLr2N3XkKjMScA7UFwKl126w0pXZMtp68WcgbNKvyyBZoSVP62KOVMK",
	"n5S8v6kKJ7Oh1rSertQ4kG4jZacTL3cfmmXnWsvebIyXaS4fGGGCh6E09rOx4DM0i0NFvTEEMUB6ewhT",
	"lrQL6DiDWMZ6rG/HeGtRlqy+v81wSHaeKUzqzLWNQ8PCzG0A1uUsg7B4NpiNsYd9RW+gP8/W7DKa3CeY",
	"W6qrTXBfjYwuNWe8yrIiyhoxosMguP9cqMCDVk6yfQ70uxj6Ngd7MVopV9GwybJ0nOeOOE8zKO1U/cgI",
	"qZUx5JYM00b2sO/braJbOO2+HePDpLtzFwukE9sdeBqAx1Hj29eHKN2qUgL8ugW2hRpZDlxYMGaFHwnK",
	"seua2rYQ5yrapgR35MAm60y5O090jGkTxpTiTbOmCiLbnTBPNb8qc8KrzxEVxLLHbyQyNZDikGAPwxMr",
	"PoHnnVLechEsuxY5N9111qt7p1yaXQa5k2zSVyMJ4+qLePPKeSPyNy29F+fm5iaDgTYsz9nL9qZX7dkn",
	"3ubcIbOD7+zR9xjRKf2eE7UFYGfkiU+EUmQWhVpu1X6DVPn66IgIhS5se9X+17qYK9W9S/rqLj3zVFL+",
	"SilX5v46RVfip7VHDrmFqom27uVD9/Lh7pBe/g7ioQA+JFhA7L8RlmQrKaNKjTe/0ohINOexMC4RcOYz",
	"EQ4iImZYNxzOBwidQ8oDE9kGflbcZZe02Q6ySuEAnbosdVAYgm0GRKIkpG8mwEIf+bFUfIamdDI1gdPT",
	"NI19NKah7mOi255SqbiYm+f4uUh79peqo2Sqtxy7Nd2WcSmoSHQqy5K+FSOxJBmBTTtHboHe6PU5tvac",
	"Yr4gUzoTsPUnswDLSr+mITmBhVxSuMywU1TWnz8mZf3eJPxMcfhTgsOF6JGWdGsp3RCAamVKySQ+si0P",
	"anYkuE8khD/MxFUnN7pA+cOqI9vbeoL+Ll521H51YmaWnAJcHOm1G+Bxg8rr5jmqk7PI5SaikXscpT9N",
	"uVTuF5+zMZ3EggRDfZrXX8ETIH9K/GvKTJFZZN6vfeKjIWiVxURG6XM3/Sl98HaHqUPbe5gVtfr0zG1f",
	"SyH6c/TRSp83RMi2Mt2AvVC2lFghi6x2ds+EBQfgbmmOuazM5RRTYBftdGzY9jA9FjzAV5l3Hw5946jm",
	"Rhh6AZVRaBTfxxnM/J68WEzVsuQEnHzT4vNEibDVL819waJOWXEFYsa6vaNagQWUObjZEa1F1vrLIA5J",
	"2QHPcITK/N81budtJ8ZGtbb7QuZdpJ9d37t/GWmH072N3O6NToKiFSygeHY0j9x2Z3565aJfAl3a86fi",
	"KOQTpCnecgQEw5CDS3bJ3nFFDpCPNXzRLNaETRJKHqDXXMC9o1wWSh+j50+eIywvmZqSOZyFGFdJtHHE",
	"BcJhyG9NRH3dV76xsgD2v/CJWdZXsGRbyzWdRNasEdp1kaVkA7lieT1MdnNbnlAhn0yynKS4aTV4y7Ov",
	"+uJ3e2A3O+DIrznW7YuzbYA9boB1061N4sdvFxJdKASJlOLoXoPfPOUyS31ibhi3Bn8wHJRhPDnol/2o",
	"l2Hpj/pQW/abO13vIg19p3A8Ut5jnzJaFgTpsOVaPOiL+aNerIX8mWKZybriVihzvNjUFalzxVhxt1FX",
	"Ce0vifZmkkKtu+dviFq64S1xm9T00flQ36nTQG2C3K5/qmWSVR6qCQPciY9q8uZ8XRBlNZ2W7TIV6kyn",
	"lnQMYlexGTawnGQ0mb3kzsP7xEfLL+QhomlSHuny9rFZQqNVd+9HrtbPupPuHv7h3MMDrx3S4KqPrshn",
	"4se69FBRcwdvHmHZv4RKvicsSP4O+WSo5Qjcri9yUygMXUB+muQS3zhVgQNA8CCu7HdxR9mIcj7x0SDk",
	"Ew9E9lq1pZa0nHmppO2tOQofh95E8DjauC2fCAXMkPpEbt4a9gSZUKnEfOO2An97beHASxKbbj4wk8I/",
	"o7GsRw32feU6dQHRnsk4td5GmeMIDTbpf+3ajs2ZtOLrrp5QG9QnLNigtmahnmGhvUd0Me9uMEFXefzX",
	"9A9ROa2pJz7Kc21tTVtheZ1XtSNBtBaQ9LpS+YYmGmvfF9Bxp3536nenfnfqd6d+d+p3p3536nenfj9m",
	"9btUU/wa9W9n336gV2YrPJgZuUUJQPWZa6nb8rkr+TMU3NSpahfBX6pZzzrexItLc58u0wqz667W7tQp",
	"WZbQy2aXbMmB/6HznuV2iipupKdfjx1dmJJfEz+yi9MxpI4h1WNIlmA25Ej8mrAHzJHi0iDNE8I0iwGP",
	"7cWQpzDj5RbTMxKF2Lc86QJW6I5wqMfumT1qhL4OSdUxkxsTRwOEGZsRFxpk7u+h3rU/l4UUF5TcEAnj",
	"sa7taIYZHWuhYcZivUpdk6V+o+7Ht7bqnbmQuoF4bhL3UnJs1VEzmXOycVm6SaiizRijSa8IVr6cD+do",
	"dCkzbvjw82M9VOx9ESQkWJKhwpO6GAn4LQs5DsqxgW6pmtov0zAMC671toWjDKCa+9ePKMMmDJpNr/fw",
	"qTdZ2tE8s3hfMyH3i7QIBIsUnqBvJZndEIG4QJc9iNamLnvflQ8xQ+hLx7fUnFUXSXsQokPGs5qQcsVN",
	"JLO1cZUVQ0duBB20YPmSJe6gdT+hZQzlzD5lrIxSCqFIifAJU3hCEB8juGhFOJhRJiHqn73BzYQSLEdK",
	"2uO5wmpHCWCq3mMnp6uAx6OQpOcrFs9GufB/6+RT+JpCe7oQmChLQ5CFRS5ExkM2EOIuc7Av0HQMhTYO",
	"Z+2aWhLJ2pboolh/dc/UEuKoCGDtyPD+hrItA8oecHRP0MlUbRS4Ws6lIjO5AKQplkZmINMDUrwGrg51",
	"jTMzpC5edRevujVMZ0n10WAbgkxsMyb9FN+QPKo5y+O+LsY7eHfwbhvejwHYPmdSCUwZCbyAhGRissRt",
	"LsUXoV6U5pmuUdq1bCTfj9I2jpMmOnnfMYS2GUI5MT8eBSDLJ3ajBixdQaR4Y70gwxtcYquOIXQM4Q4Y",
	"QiwXMtY8XCYAjzPwKCTbYwBZvSCTpKoewjPj6eDdwbtNeOdI77FAe9dJ55rJ7y7XXIftu8P24xDagc9n",
	"O7PKa3ybh4cEHR+9f4s4q4HsY5/PukN6B+y2gQ0U+miO5ADsrZ/FSxDdWHJrfHdH7g7edwHvx3LWNoEo",
	"ZmQ2IkJOabQJxqGtRdFNJcLItI/4uAaqIRXq23RAHbY7bLeGbSBhNMtS30NHeCQ9QWZckZ36zJgu0Cm/",
	"JeJ8SsIwvWmvgflTeQb1O229g3zbkK+i3EcF/d3cpS0BfWNl3rGATqHvOMCdc4DHot2LINqpTe7s+LSe",
	"A81ZEHWyvUN228jW9PlopLkG827keLpM60jusyDqhHYH7TuA9mMR0+5l4paADU+Csa/oDUkfPa4B7HM3",
	"rA7YHbBbA7ZMqe7B4/r30LMu/NsW2ef//GXjFy3nv4fdo5YO4G0DPCHdhwZxNqaTpSnYJMqEAkCmQmxz",
	"mqe9pM+3KZMKM5+UJoc4jKIjaOEUouEXMZrv/9T9iGywfPQ2hkBVYchvTTQRzm70FnB2kI7m7+T3gxsc",
	"xgRyU5fF7k+K9pYGbdhJlIQGUbBxFHlmxT0YcZ3I1w8xTuJ9iWJdIPQMhedwDajZYWSFinCDvwoKoRm3",
	"A8hzsoDH3i7DmBZpuXFiUrZ0h1qKaJr/9prMy/PGa/aT+WVJYJMOwVtBMGCjFjQaITkvLBWmrEmQkxGW",
	"1F8W6sS2uCzWiS3SBTv5CoOdOPKoinbiCPI+K5glmGnxyYTtvg62ukcT3eHxbnBd9Wri3sNbK0URjcie",
	"zR21BMs2+mMsBGEKmfIOx66ZMpAe29/OTQ8t6HSQjs4FWBtihsO5pHKIVT6WnZankLCpX1T/0uVYGajQ",
	"zd1L0m/10mR3dXtsP4LemkgqjWinp28pYiGKnSWKNiLY2QSOe19sxkII3aMU9q8hwZ43piygbFJN468+",
	"R1yYoI22LDLZFbMxTk2LyAaVzBO7aeAQSpxiNX3telxhJbHl0EUmsOaCvcMOqFHIymLMTCqvEfZ9EsF5",
	"0tpkKnvUPx5CaVI/UyJAQlB57aUdlY3lXC/1aG4zVw6QPjlyFs6RzOe0RFSiKzv7NnJFriVRfXlzN/Fn",
	"vxJd2iIzgz00TrHl+I0BHtLI23l2smPgMZVJKxIWtHaM2VJudoMpPLqGqLhyldXXlc6tG9S0HM00XW7n",
	"dZVTbqa5k3zNxbGrtZSn3Vd8V+SCTfnr5glh2zI/F5SWx2hZfrgZFcvg91Wxq4AoTMNVbMqUIgEokgiP",
	"eJxj9HleNShlVmZ2KaeSx7bnwjK2Bf1+77M34Z7twep3x2kqtLqpvO1qSpNRm7KAfNZ/OK3sA1M0bJ5x",
	"G52R0MSbm9IIaWVNguVlRIA7kwBxhq5eCz47dfaZKzB/Xl3wzDeUIRcw3ISoIovM3WwewEHrnrId/l5M",
	"OVfWZ256u9z8bD8FEqgz0syi73CcmV4WRlkKGsFnw2gnw6rqUvGWO0yNk8MpltNW+mx83qrbWT1SyzGW",
	"rYzBZsTOkVqulxrEhm35YbzlYVV1eNoqnb3ehe5Z0VcqUFrpbkvdaKVrQoTpp15qdSMKPdzAIm8FZqM6",
	"Vqw2qtPsdsFeK2x6luCM2JTwO08OX68D41QgMpqIs9CV9JGwxVQNHXEeEszKc8fXyS/fv2dLEVKpWl6C",
	"Lsl+q0dCw3zzp5sgOap8NedCGWFxHVJGlp4MTYpLHMbE3g0LrShIwswvSSPmjKFhc0ODGIeLx+0S21Zy",
	"UDx3jfwL+qlj0yqe0Y70ykuqiD7i6KOWledHPGZw9DqZRdhXJDiUkqjk24WjXaMD3D0wk62X2au+tppd",
	"9x/JhDJG2QTpBdGqG+JjJDCbEPQtZX4YS3pDvtMH0rPXR97+/v5LZC7d/gcdkzGOQxNE2d1dJq3MKIsl",
	"2n+CAjyXVfcggs+2rHIuXDuZy5+SqZHPa0+tYjKKb3Mqm+oka4hf3bN3S1nAb+vI3xoKCJXXiVdVHZnZ",
	"OfetbxLN3EMk/Nvy+EcvALfjcGhViEpvQzOfztXwq3M1tIRR7mdoqOKeeSHpHpU/LcLgA+g9xt1IxlFk",
	"TNIppzevygg6zk65iAbTzAIg1nWPz8uZNFdnrcNYuZ88zH6Jt7y9Z23DCb7pfLqbxTtCuqHpIvU3w/py",
	"8ZQ+G63h2Vvw6E0qm0PbiIScTZIMJlW3eAuSK/vurnPj7dx4W5GZfobo7rXgXAnfdlzza2O5c8rv0HwH",
	"aC7zyH+IeA58T86ZvwM4Hx8h3XIjOB/753YwHZg7MLcE5uMjlFLdQ8bymAtCJ2y78Vd4rCQNiPkltREt",
	"JBm+ZGlMlkxlynLwv2SrGMBrM4UuRkvHBNplAhY7xSgtD5kRTCLubV9hX8YRMnr8JXtz+h7iS+jCa7GB",
	"NxHvFPyOHdwhO3hz+v4RKfsJX4CsJVvIe7KMFWBBXFaJS8bHrspG/MCMu+MDHR9okQ9MKLPE+0jgv3FE",
	"ZWigbfB3AZc77N+JDrAYcvkhQn8S8bUu3KwK38iI90b31eG0w2lLONU0+tDhWVchr1LEm0K0U6Q7kLYK",
	"0kehQFM24jELPCViuVl+IdsSMi0temCuxO+JqX5hxtHBuINxa66fWbp94HAOKbsmgVdTN67EMujIpq2m",
	"rmi/QK1OYe5A3CaILa0+Ar2Zx2spze8/NNaY38cdRDuItgbR9x8ePjTVtpRl19S62vJ7W79TlzsYtwvj",
	"Bcp94JCue29UcV/UUOJ29z0dWFsF60O75yHJSHxc/wlw5ePfdGLo6LD6DXBa7Ah3L4G/upfAeSopfxCc",
	"K/MA8dPaI6fcQtVEW+cQ2QnHu0N6uS/kQwH8jS69PAsJDkPkhxSSkPhTEsQhCZCpWB4e+AgKn9uya0Z5",
	"YuSzGib92ZhMDyRq0y6iMJb1I0QcklbiShZ2Y8sRmurFmAS6koNPfGT/Bnpep7pNL+3ZQAwuumDjdkLu",
	"49A4D2/cFg48qUTsq1iQjRvziVDAzqhP5OatYU+QCZVKzDduK/C305ZTlu2xfP0GeNykchfndOOYYs1C",
	"eq4OKWZ5gWNPXkBlFOL5ow0vtt0gYVYFyKgu8AX6NhHg3+0gWS+XJerGEYBLIryoaMCRHPIVZDjGouph",
	"aueVj50m6F2gu9r5eYGH2Py8ML2WEvFugKRHEYFoa7gxlIZe2b2rD5yC5r33Bf51JirD9YvAOIbvy4CB",
	"WYCwlNynWsQgheW1RKM5AhU0jw/TiMHHq4Tsmp4imXk/qas/NnvS1ujDrPQa9NFfdgzL7P0nPrL7P5qj",
	"k+PyXK1FRthxlMdDY2CPWIPAthvOE3qsjObpeNvSYJ5Jtk7K1P6zNFNnevqtSu7v4hYWuGJFaMJF1nff",
	"9IJs3v5OL/gqUGzjC26kSYwJVrFYnZ4wDJEtisYhnmTuuSiTJm9omTXvtanzWlfp7TbB3mpCtBPw9AQ2",
	"y8D3VQWCzu17PmH2mE5ayhfs6HTvi/0LLpYUn0xCUHm3K5ks2VbKpnQMO5JOvwoKwikFBPJhuWMDMJRO",
	"pgYSL2CZMlhsI683YXgUdkFq7/sltKENhHMw/0Yiu30udbziiFA1hST6cN/CBQqohD+pGjRiC1lY05B4",
	"cRRyHNROkKvrIFNHn2XK04a8piH5AGV+NkXWuEWKJRFDMsM0HOIgEETKqz66MguS/jWcESnxhNhvhBoq",
	"OoNPhAXJ35DlnrIJkfXuoiCBY/Y+Ct71382NFKxDSznIimveSrdJOvwWLt7yZNPW9CxdtpCPz5F9C11l",
	"UNVCb11+vO7eKD1MpJLL+8RHD+S+aLsnAy1kkZGyyIrZVAtwVy22gGzroJDuy55LRVojAz9yZY16kSbe",
	"T++MsopHRa4y20aqfEAa/t6DySy/jpq8pgpbknAotwNWwVN2Ae8VXYE43fjUWeMmc0HVBYKUxKQgWyBM",
	"WXGlmVOEi5T4tBUTYIFZ1iFKM/7g7nmdvbFb4HZrE2UFUX3RH4bmw/ATH7lrve1aNo7MVgOukCncR7E0",
	"T61lRHw6noOzLRTgY2RpA42IJjppr40geQjYdRNHOdNYqi3ZnjzNApdaSQiLZ3oVC6TXz331B42K33h6",
	"FfQpAZJwZ3/87C38/LFfSP1VWJ2LKUEnx9aiUjhpDiqMQYV9q20UevG8yihUyhjO8Q2whUWZpHiRV5Rc",
	"Y+ifNBFfcMcK1rvEqJUwCS4mrON2dmi200FJqqRn9/gC+Q6N/LBswHwueFuMZ4+wYPvM557D6xULauDo",
	"FQtWyNQnHR0X6Vgv7g4k6CTiW3ir9eb0ffULrTcR7x5mfXUPszRJlD/HsnE+7uebjEU8NMoPV/nyKs0T",
	"h8djyD1olEADneWo6dLDdc+r2sWro9YHjNl23ku+/7AKut3byA68bYO37EXkw8JvvTBalbh9/2EdOdtF",
	"1OpA2hZI8+G0HhY4FSXC+4MIvglEk0ayQjbzlOKWqmlN3F5QIv6jh9OBtwNvG+BNAfBQIbylhCvNZWwX",
	"Q6sDantAXQygdb9BqpHmSYKFP10KTQWvVzRFaDSaCvBuxYAVjLIYrLEal3AJUALJc6h3Bu2s9O6Essh5",
	"c5U6yEGRofu2+nqh1hWiuzs1rSKpBFZkMkeK6z0doGMyxnr+VKKrcfzHH/PKcCPKXJ4WL0uhWq/fI5+x",
	"r8ruNj/uxOkEBwHVFXB4mvt9tQvAaOrB/g70zvYeqwf4/eAhlu6EQ0fCQPQGtOQvA5st9/x5NCVid74y",
	"ZzGTCKMZZjEOkenNIB0FVBBfhXOEJ5gyaTiPJuQRlkWechazI6j9zwwPWOd2PA8cyvwwDsgw/+3ig4i+",
	"xX0ZgynC4q4e8sWMjikJLI7h/x1ut4Xbs5ghnCPg7PWoQVHNK1GDPBJMCPi/cEnNPlQI5TOiYgEoMgJY",
	"kEgQqXUQNgHM3GBBeSxBJku4P9VtW6PyDF8TFEfJNVFIPiMNVS8S3AfPGyhdqlefYjU9yoxwhRy37gNW",
	"hwcnPD1Ed3Fb/jgiFj4ZgszZ7KVWf/lorFPesrEoLCZE7WwsTunQqw3OXFN+m+yKXWGtXFUNT9cbqlXO",
	"Wu2oGTvkRY7aDa1DWBhzOcKZ0mIi717FxwWqt0cck5okv7qOFvQO6NWlJBh0nK+OxqJPFtmlvFulRU65",
	"UETzMKyqDzOHloYcP7KVzFzGgs/cezBNQVeaXuBFGHwqZYfntoVT4/+0khdC6+akZOj9JKhig8k4dsF5",
	"CAtqjcLNfvMxlMYz1LiknMkpjYbXlAXbec7l+MJD5HWbUWjHuGowruK6Tiy/uhv+xeNoG/5wup0lHnH6",
	"584n7uvziQOyqPCKcwkp76t5chEZeziYUeYJOplulk5HzqUiM2mQA/2gKZYImkemeaT4KiAd6uJnZjDd",
	"BUN3wdAOiLNE+qDB7NyG8Cgk23OaSwCdcZ1bBeSj3Eg6KHdQbgfK/gLdPXws79r9FbquC+fu4r8Dc/tg",
	"XnAAeHBQDnw+242KrdFMPhM/VgQdH71/izhbBeVjn886DbtDcqtI1rR59vD16xmZjbYsj7EgCCPTsClT",
	"Vya/tYPpUNyhuB0UzxKKe/AQntJoIxiblrOimMosjmuCF4bRAbgDcKsAtlT3cEEcSU+QGVdk91r1Kb8l",
	"4nxKwhCZLmuo2KfyDIp2anaH71bxXSTWR2DUFkG0O5ifHZ/WuJY6C6IOyx2WW8WypsxHgF6bJnQj7GJf",
	"0RuCXFMm0ws8XoMj9IiEnE2MK2Ldw/O5G1YH6A7Q7QBapiT3QOBsY4rv7NnKCbQvjf8xeOJZp2PNAEyK",
	"2QKMTZ1jrHDvQYVOvLNMi69YEHGaTQBqtjXvX2wSe6ETF0W+6lkFpJpYmuvc5jkvzUmR5NRbPx2FaX7I",
	"sM0uYfOjwd9wZKOcJfkmclkqqnJS8MlQgwBSn0Mi5GF675R2oagK18ph0X4+9TVScE+Mk/ejSQT++HN3",
	"bz3duaF9L6X9NanB5BBZqy4gzQOk9e4ipb3pf+3ajv14JoHGmqsn1Ab1CQs2qK1Zm2eF/r1Oy/HxrpPo",
	"LWRzhHjuTZKmd3m92lPCP+VzcljVY1ePD3Rve0markpVKaeVWQzqE+yEKMTIZ5XJ9KVbHFyyS/aOK3KA",
	"fKyZM5rFUp98EXYR6NFrdyrum3MwcV3cUrAHqlgwhNHzJ88RlpdMTckcVCrGFSKfIxMEhguEw5Dfmqd9",
	"uq98YyYDV0nSDzfcTfW7+6/QFZKSdUpdp9R1Sl2n1D0mpc424F6o8XV231U2RCg7lbJTKe9N1nCTayvR",
	"sfJGqzZVRT8WwhJYtU0NQiyYgkkGLLgYidWUMAVPtQOnCN5nVTExAB6Z2VRnDmk7If8C3jp8bX7wsqDK",
	"EG7L2NpG+p5leXJKT3AE8udolOqDwgyLaxcaB2khfq/h+YoFyfntPuGyw+OmeHzHFR1TYkTJ4ekJ4mNL",
	"pSZm0wpkLiJrTBmVUxIsF1ua5lzJ6iTlhuJe23LdzVBnROiMCJ0RoTMiPDojQnM7wEZWiC5d/L1LF7+p",
	"jeNjF1Z1fWvHoibW5klsx7nCq85iJjYgRozcFk9k5sd7fyY718PMn8q2EpI5qJcn9h5FXu5Ohu2eDA1o",
	"mx0Mv2RyttfxEVzqItiZBjtvjgqj4s6NiYUYrz/zETo5Ls/OvZ2M3FVY2vMx80m4/Uzku59SvxfFJUzg",
	"CCYkEUYJxkqZgSnX8YOOH5Tyg2oyWkdk7YV8sjJnT8gnJjc+PFfA6HyKRfSTXhMkYrZUmv3CJ7sh4Py3",
	"dharM2g0INuOBJeJJM1Gf+ETSOz/mIVSyCeU7e4Q94tuXp+Lfgw5DwymIIOkPnYhX5CAMEVxKOEYhTgj",
	"cHhDEZbyloug+OQPWmx8YiKf8Swyrpsw4+GMqCkPID+WL4jWiO0fB7238/M42hfn+77YV6d6IE9E8H/+",
	"z//p9Xt61HYnfM7Dof78f0d6alM9NZKQxYByTZJVKM+PYVnOCyg5QPZqPZwjzsI5ujKDvUJUIhlHEReK",
	"wFq5JFp2MsXsWf0eV1F5l+8ZQRd68U/t4tuEZZKySUjcSC702XZMSRjAW+sRpBwMEGVSERzoIbvB9Uo6",
	"d4tc1n+U7dblMqzVIVcRXLYUukv3q4x5phj6Lb8jmYofa3DUC8j7BuSIRjyYwwRCPplQNkGU2XQaGbIc",
	"pBv4PRffmwnovXQj6qNRrMDMMOJqaiwIecSvd17PwCDJexar6ZB8jkzTYxxKzU3MJc9Q8WuiZ0jmP09H",
	"b3z6nv588uGPk6fv6Ik8YWc/+EcnL06uo3//6+jnlwMy//mp/+xf838/C69PPnH67uKfz95+evv03af/",
	"VW8/vfrjf8+fPHl3fH37y0X46d2nifrfX98+effm7R/vfz159u7i+vaE3tLg3+9Cn568OJm9uxk9+zyG",
	"z9c/0tGblzf/eTO9CX794fo/v/7w5D///vnWn4V//Of8h2g0P5Ens3AaHJ28eHvx4fO7Tyd/vL84nL9l",
	"TwZPf/2V//Xf0auX2Lt58fafL9VPR3+j159nN7Pz/dP4+K+jn+fv6PPpqRj+r911zV4Pej88f/Fs/4cX",
	"L7xnT/ex9/z5yyfeS//F3zzsP3/u778cvfjh5RMjNRrJ8fxil2XLWlj5DDv/dKuqSHy4YPiJY5ARW1UX",
	"OlNsQWEgfiyomvcOfvuYM8wWZV5GgziM1bRmuquQT3isdiqceQwP8jPSGbMAmeuPhAe7V87o518vSgWy",
	"HuVKfqTIZ7UXhZjmOVHvN7CWOv45xRIxjlxb8Lj1Y29ZnqYCxX7//Xns+0TK77+/ZBemcdsa2HVt3pNc",
	"N5ptGzZrFg/m8As37LNMXFGp+bU5PZhSaM5j08FIiwOTo88YhfFYkVQi8FgNls9oA6peTpeF7V6PMGdE",
	"YQ+yR+19sU4UqxJyhBjyiChKBILs4j6fjTiySXMKB6xfoLhLIH6ky75z+XUeaerP7jy27Dy2nH4SGmY4",
	"nEu68yPaMRB95SktwUSzhHOLCFOC1EeYRLpOJqebzxkjPuQRhPRupXYMvYgXghCXymepi5ZGYGbOC15N",
	"umcz5YbWxDsx/yXI7ZJ97iRzVJrxGshSk/JjxenmSaneOuSWRjjSvyYpqXZuatSf5DKpuACTOjKvM6bf",
	"IRqBuMozW8FPQFqUyHsVpYgpvV9ScUG2kPTt3QXS2i061+1VA+2d0qWgUJcC7qvDSZ5IygGTK3N/Y3xV",
	"oae1/DO5daqHtS4bTRe/7+5wXp6V5oHAncdbkJHvP1QLxvdxJw+/Onn4/kOFEHz/4cFAAVqI1YbiLmnE",
	"mY5JgEZzB5uliDlK+u9kWifTWsCqnyG4hwjYScQ3wuqb0/cuCdN4THxVC6VvdKcdQDuAtgBQTaAPFZsm",
	"svXmGZYai9EkpnYH0Q6iO4foxFHbQwQpvGfbBKMmCUNjiH6QnZbbIbQlhMby4Wi4+rcxNQFZsrCMBIEQ",
	"X+7CceHm8tXp2aujw4tXx3qy6A1R51MuFJHqFKup834dIHffaghJYzjTHxoRdUsIQ+qWW88AytKr2RlW",
	"RUifZoa7KmQLPLa1fjmlgU4gDAtzjjt1L1j7JU+Bl3VDWNC8k87x4PExiCzpG0Dk8rIYF5ddcYkc5omY",
	"0RU5kky0wjBEbvGNF2Gm6qA0tNJppu21YirZ/tT8qo+uXGSlexjYqKyHZOzr9BEJEkBYxcGYhoqIQZbj",
	"lLo06X/a6GjBbWrdbjIv/L+6qKwLXix5ADYIZ5LWrBWgtePe2wtmkudsjm/nv22Ze+99ST+s9sDErJKZ",
	"fyNRQBSmoSw9RaWTvKv30Fm67xy27lKLydFCuygoaN4nx4nPRzIAJIjPBTxsEEQJSm6Io219qhiU+1rm",
	"cFT7Aev+s1UPWKMQK11j74v7C8wgmvC932Mc6rO2VHhJoll48yiJoESCZQSCpUwmgkywMg9QkG0IQUP2",
	"WeSE3hCGXKeloLa/HWOF/2laOHTtrqW6pepZH6XKWTvaWH54P5IJZUzr2XoU8GSXj5HAbELQt5T5YSzp",
	"DflOHzfPXh95+/v7L+2J83/QMRnjODTBnFwc4aSVGWWxRPtPUIDnctmxstzPXLdjQuL1ax0rK2ZAPq89",
	"g+oz6lojvr+h52oHnMtB0eHFSxDWqUwbHHjtaua5FM4wGSc/NA9Clgm1KUAcD6z0wc9w7aVSwb1sx7oY",
	"/iMWpOR1e14ycAmhUpdz/yQW/5RKxcVccwG9miMsieX3Et/Ag3Mo5n4rZfimx3PocK2zuX2RIF2I44jL",
	"WJAhZQH5rL9RlIjhH0TwIdjszZmdKurjcCiovE6/vocH+lU2z1/4LRFoBM9QIehfMvj/scpGLBiy2+r2",
	"RssCzcWxQhjJiPh0TH3gxntL2PFY8FljftzvffYm3Ms0cZzOqM4EP0RR4wnGkeJNZqb4hvNSfGFWZb2k",
	"dNqKfSQPhO3bSkoXMg+1djotAXM7HW/dAnX3kW1r19Oo8G4pC/jtdkLi6s3zsuLn8cbBfbCHbMtktaym",
	"UlE/a3I6o/LaldihnUnwkDS+H4BK5TcDZ9DeWnqHuwbIlH1AtwKdnf6h2ukTCDThrjwknW2+Zdu84y0J",
	"i7Sf27DHA5HsfdH/rGGD19VWWN/1ZO7K7m6oubO436UyYPe/LdpeYmXX1FBmX4dnW9XGdQuNLZrVBefK",
	"x1t4V3bGuUJHh9WPy3SBI9w9MPsKUWcoo/yVmf31/vr1lSCktffVdnFW4ql7VN255t4FlsufU997SEs8",
	"C1efx01CNyJIgM4P3/6CIsFvaEBExan8HM/CU1ekjQg+ehbDZFAND1e6sucqb/uU9VWdmIA2shtfN9Di",
	"Fk9Oejf3cqRQHgn0CMwL0mZVylG1CdcNj7fA4UFrnCbnElEYrh3//faXIuWbFrO0vzRm9ywOFY2wUHtw",
	"OewIu4rwXd/FmbzNjAqC+uuhJarviDIM9pzCDYiLEr0Q8Q4btwA9/cLKlEScdomUNo/UvPnBcgHJnTVk",
	"S/kpgLARRu8cPTgCN+kjHAGuF1k1D9i9Lzle7g5hxkhXpNZj+B5MIOQzlXAtmonsWyDePGJN7QJidyys",
	"zCttEkAo/YayCqo8SBHV/Mj25OVWnXOAsr1bgaMImENhPY44G4fUVwN04aJAU4mUmGuiUjwTIpoKxG/Z",
	"InXdD7AamkY4D9RGsnhp5hibcxjkIQ2s8ptITp+zMZ3EBmNZF0k3IE1HupINIF2NzTdE7R6YOxUpnSlk",
	"2fFpffLcriEyL8+qXLYWhdIWzY4g/6Tky60nYWhWTNIJQ5wlqTZlFXDO6YTp/96zV5miOxdu6bjWOITp",
	"yXmcea6RLUu6+5Y1YeXG3snx6YYEYA6iRK4kSeMmaEsnSWycfzAoK+X2gRsS/NP2sZ6Rbi3/334tzwCb",
	"XqQP574+zG7eR/qLcmf0Pko9Ar4ChwD3cfc9uTwvbfQlfR5tZ/1sGAl5LxzCNvbrSvlBl9l81+azHDfN",
	"sP+jeTQFTrozAdBfaiSzNrJ0ePNK25fl6/MN8ns3pMmaucmAdYPT9MI8VlmunrZ0zMhOqYZKYxY86JBV",
	"23iV3/b62KpSjva+wMchtFjPTpUzU2XGg0Zzc/IoN0/lQJUjzlpnP89Rb3epvztry7rUtTu/mvyISs+0",
	"WfLd9ERbkSL7A6jJDQnfVLrH0gSU/3WkyZP7KU06P7tdMAdH+7sXPYvRd6rE0Bm54ddEZl+283F+gC4j",
	"uLn6lAQ8dFzwseXyKf9gf13E5onengFlcS6Hyct1Y6oPrOcQ5COc4htnqc+94tfTD8wU0/vdBU7pDkcr",
	"covWME3VYyYwKs1MMptYsS1uH1axmU4vuGPo1wbaYli/TmM4n2KxcKObXTUu0AzrpaUKRfEopH6BL0EL",
	"W9EeFiIsme5Kkxhn+VTrHEROsShoI3alICF3ZqnaOO+uZV+iRHpZMbbW8mSOxR0XvHMuCEAsUqVWKqhC",
	"iqdUuZ5ORLDwp5WXFOfwMwDExP80ZCP1oQNcuriwX6GT4z4y5lsb/XcelXjumwZXvjY03SZlkmuRQp9G",
	"JLhXAqW29s2CiEL2UpjLJTvnM4IOj5HNQi0P0NWPWMILyA+SCP2vy9yh/4bw4+ZLExVZXCWN/BELkm3n",
	"8D+upcP/HEaR+eOY3FCfXJkM06WPzecLBvcHFQpmc8YHZGJdrtdjdp1hvQYLSpmAhX+G2ySAbuVmlYTj",
	"pReqmavTcJ51lCGBE/lEJI/60GsuUDLuvnkkAWcfzsI5IjdEoBFBNzikJvIGaJoDdMJQOkNbzedxGOjS",
	"hKopEQhnfejgdAUOPH5ICVPoW5+HIfEVF98ZdBf9D/RU24q1lFsoL1mo7fsBrLjJl2bSd3FnHxF/j0eE",
	"6XWZL3PoP4NwK6Bcv48IQ4enJ2h/8ARS6GBFRyHJ7rz+VbddtsWHET03P63YZUU+q73PnhuWFRuar5kB",
	"H+gBDPYvmQGxPLhkCHkoFuEB2rtkg8HgNyViZmBga38Esis5bFQ5Oz8olxC97HZtE2I6PUEn5rFYGwSl",
	"+DVhq70/NPKQKVv+DkRj4MK0tUJpsg5YCDtjjtYOjUZme0Cj+QBdaG5lv6bScLopZ1yrbZrHHQYzyiyn",
	"q1A7tulUAMe6P2u6lVzZniG8BHBS+8EFogixVEPs+0TKJiEoKhWsR+Rzck3a8TiZzrA/nBE15e14nWS2",
	"fCv9QbCrXYfySKn+q47jkTLJBlq/Zpke1OzCebTsXQNpbRNplJWsyZd3618DZKHlXiyJeYLmDH2STiDw",
	"7AhLEiy60GdD82oRU/UwLRHGW7OHwoCH7hlZwbjpJO1qQ+jahs/Uq4dltJF7cw+bRXuH5a368wAlAw18",
	"kPn3A7UAXVB2974Yaq7px1OApkrGsxyLpoE8Fpu+3e+M1q249GjCQm6XNpQXZVduKcNKX5dVBLtxtFnv",
	"yq2KyW5yJIQz1eahcWBNK+Pi6F+7qDhf3VMwIIrykDiHx8hlWbyf8TMKuNjDwYwyT9DJVG0UEUfOpT5X",
	"GNyAVWSKJYLWkWkdKb4CRmAPOTND6YLhdMFwWoFwlkQfNpR9zqQSkBPW0/J5AjDbGbYz3aG0u9pgP0qr",
	"Hye1O/B34G8T/Etp+MFzA4jwhUch2V6sO8cAMgHvVuM8M44O2R2y20J2juweAZJ3HbPyg6yIbFIEcxeu",
	"soNy61BeCNL38IAc+Hy2E3XcB/dz4seKoOOj928RZyuAfOzzWadsdzhuE8dAmY9BtZ6R2YgIOaXRRjie",
	"CB5HWRhTiTAyjSM+XoHgt8kgOgR3CG4HwbMszT1gAEfSE2TGFdm5ND7lt0ScTwlEpdY9rhbNp/IMSnbi",
	"uQN3m+AukupjkNUiiHZmAT87Pq1t7j4Log7QHaDbBHRKng8bwpKkoSK2fD3NEPYVvSHI9rFaOp+TJGRE",
	"B+MOxi3AWKYU95BB/Hvo7dbX5PyfvzT0Nzn/PexcTjpEt47oRUp9OMgmQlLjbr70wSaANI4iLhQxDzNt",
	"zfLsnocR/ZdtuYWXMIenJ8Uv7UvmYWaGhRcCQZJ1f0mxouN8v2dIo1GlXUfuvx+gyFBG289H869av/R+",
	"/vXiR4IFEcaF+uC3jxooP709PDqnE4Yh0Ti8fj0zi3GMlf1C/04C+zVU/Oi2vMybGh6FUoOREZYEabQZ",
	"V/wwTOOp9xHwXK2bKg6FAz7DlKHb6f9P1tnsRAgDcfxVGk6arHHjwYM3DJsVo7Jm4eYeZpcKzVYgdDB6",
	"2Hc3Mx2gxNMyQ/qx/5a2h85vdM+wMFbPOHXUpqlU3TrUJX1eQ2+jh+iWV/qfG4SK4Ri+K3JBe5JVfQzr",
	"9d19EGP/PyZ8TLa65KUtbpYHUdjz6iVR94FBB+yisy2UYw0yzBPZIB5Kg1yg+TQVOZzTqFLXWk+JXkVb",
	"OhPQG+Z68Ebu+cNxoh5Jz8A1IkL8s5BByEhYS3ra7jIunMaS+C7IgTerIo633Mdl7bHtfQO6R5Xrr462",
	"R3JkhXRl1EHEX0UJIKj3AayfzWR2hpkiQpHhCScDFLScNTbE8G2Kl5gUf9pMTcQN2F9nuD+eeZA2Fc3F",
	"0aY3z+2RfnJwZ/5r3+RXV/tTrcvBandNFSHC6ax2gDUrsUyy/6oRZnEPl8PlLwAA///PNQZjBf8DAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
