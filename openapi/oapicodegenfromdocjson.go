// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package oapiclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"gopkg.in/yaml.v2"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	HMACSignatureScopes  = "HMACSignature.Scopes"
	JWTBearerTokenScopes = "JWTBearerToken.Scopes"
	RequestDateScopes    = "RequestDate.Scopes"
	SignedRequestScopes  = "SignedRequest.Scopes"
)

// Defines values for EnumAuditLogStatus.
const (
	Failure EnumAuditLogStatus = "failure"
	Intent  EnumAuditLogStatus = "intent"
	Success EnumAuditLogStatus = "success"
)

// Defines values for EnumClientType.
const (
	Azurehound EnumClientType = "azurehound"
	Sharphound EnumClientType = "sharphound"
)

// Defines values for EnumDatapipeStatus.
const (
	Analyzing EnumDatapipeStatus = "analyzing"
	Idle      EnumDatapipeStatus = "idle"
	Ingesting EnumDatapipeStatus = "ingesting"
)

// Defines values for EnumJobStatus.
const (
	Minus1 EnumJobStatus = -1
	N0     EnumJobStatus = 0
	N1     EnumJobStatus = 1
	N2     EnumJobStatus = 2
	N3     EnumJobStatus = 3
	N4     EnumJobStatus = 4
	N5     EnumJobStatus = 5
	N6     EnumJobStatus = 6
	N7     EnumJobStatus = 7
	N8     EnumJobStatus = 8
)

// Defines values for EnumMfaActivationStatus.
const (
	Activated   EnumMfaActivationStatus = "activated"
	Deactivated EnumMfaActivationStatus = "deactivated"
	Pending     EnumMfaActivationStatus = "pending"
)

// Defines values for EnumRiskAcceptance.
const (
	Accepted   EnumRiskAcceptance = "accepted"
	All        EnumRiskAcceptance = "all"
	Empty      EnumRiskAcceptance = ""
	Unaccepted EnumRiskAcceptance = "unaccepted"
)

// Defines values for ModelAssetGroupSelectorSpecAction.
const (
	Add    ModelAssetGroupSelectorSpecAction = "add"
	Remove ModelAssetGroupSelectorSpecAction = "remove"
)

// Defines values for QueryEntityType.
const (
	QueryEntityTypeCount QueryEntityType = "count"
	QueryEntityTypeGraph QueryEntityType = "graph"
	QueryEntityTypeList  QueryEntityType = "list"
)

// Defines values for GetAiaCaEntityControllersParamsType.
const (
	GetAiaCaEntityControllersParamsTypeCount GetAiaCaEntityControllersParamsType = "count"
	GetAiaCaEntityControllersParamsTypeGraph GetAiaCaEntityControllersParamsType = "graph"
	GetAiaCaEntityControllersParamsTypeList  GetAiaCaEntityControllersParamsType = "list"
)

// Defines values for GetAzureEntityParamsType.
const (
	GetAzureEntityParamsTypeGraph GetAzureEntityParamsType = "graph"
	GetAzureEntityParamsTypeList  GetAzureEntityParamsType = "list"
)

// Defines values for GetEntityControllablesParamsType.
const (
	GetEntityControllablesParamsTypeCount GetEntityControllablesParamsType = "count"
	GetEntityControllablesParamsTypeGraph GetEntityControllablesParamsType = "graph"
	GetEntityControllablesParamsTypeList  GetEntityControllablesParamsType = "list"
)

// Defines values for GetEntityControllersParamsType.
const (
	GetEntityControllersParamsTypeCount GetEntityControllersParamsType = "count"
	GetEntityControllersParamsTypeGraph GetEntityControllersParamsType = "graph"
	GetEntityControllersParamsTypeList  GetEntityControllersParamsType = "list"
)

// Defines values for GetCertTemplateEntityControllersParamsType.
const (
	GetCertTemplateEntityControllersParamsTypeCount GetCertTemplateEntityControllersParamsType = "count"
	GetCertTemplateEntityControllersParamsTypeGraph GetCertTemplateEntityControllersParamsType = "graph"
	GetCertTemplateEntityControllersParamsTypeList  GetCertTemplateEntityControllersParamsType = "list"
)

// Defines values for GetComputerEntityAdminRightsParamsType.
const (
	GetComputerEntityAdminRightsParamsTypeCount GetComputerEntityAdminRightsParamsType = "count"
	GetComputerEntityAdminRightsParamsTypeGraph GetComputerEntityAdminRightsParamsType = "graph"
	GetComputerEntityAdminRightsParamsTypeList  GetComputerEntityAdminRightsParamsType = "list"
)

// Defines values for GetComputerEntityAdminsParamsType.
const (
	GetComputerEntityAdminsParamsTypeCount GetComputerEntityAdminsParamsType = "count"
	GetComputerEntityAdminsParamsTypeGraph GetComputerEntityAdminsParamsType = "graph"
	GetComputerEntityAdminsParamsTypeList  GetComputerEntityAdminsParamsType = "list"
)

// Defines values for GetComputerEntityConstrainedDelegationRightsParamsType.
const (
	GetComputerEntityConstrainedDelegationRightsParamsTypeCount GetComputerEntityConstrainedDelegationRightsParamsType = "count"
	GetComputerEntityConstrainedDelegationRightsParamsTypeGraph GetComputerEntityConstrainedDelegationRightsParamsType = "graph"
	GetComputerEntityConstrainedDelegationRightsParamsTypeList  GetComputerEntityConstrainedDelegationRightsParamsType = "list"
)

// Defines values for GetComputerEntityConstrainedUsersParamsType.
const (
	GetComputerEntityConstrainedUsersParamsTypeCount GetComputerEntityConstrainedUsersParamsType = "count"
	GetComputerEntityConstrainedUsersParamsTypeGraph GetComputerEntityConstrainedUsersParamsType = "graph"
	GetComputerEntityConstrainedUsersParamsTypeList  GetComputerEntityConstrainedUsersParamsType = "list"
)

// Defines values for GetComputerEntityControllablesParamsType.
const (
	GetComputerEntityControllablesParamsTypeCount GetComputerEntityControllablesParamsType = "count"
	GetComputerEntityControllablesParamsTypeGraph GetComputerEntityControllablesParamsType = "graph"
	GetComputerEntityControllablesParamsTypeList  GetComputerEntityControllablesParamsType = "list"
)

// Defines values for GetComputerEntityControllersParamsType.
const (
	GetComputerEntityControllersParamsTypeCount GetComputerEntityControllersParamsType = "count"
	GetComputerEntityControllersParamsTypeGraph GetComputerEntityControllersParamsType = "graph"
	GetComputerEntityControllersParamsTypeList  GetComputerEntityControllersParamsType = "list"
)

// Defines values for GetComputerEntityDcomRightsParamsType.
const (
	GetComputerEntityDcomRightsParamsTypeCount GetComputerEntityDcomRightsParamsType = "count"
	GetComputerEntityDcomRightsParamsTypeGraph GetComputerEntityDcomRightsParamsType = "graph"
	GetComputerEntityDcomRightsParamsTypeList  GetComputerEntityDcomRightsParamsType = "list"
)

// Defines values for GetComputerEntityDcomUsersParamsType.
const (
	GetComputerEntityDcomUsersParamsTypeCount GetComputerEntityDcomUsersParamsType = "count"
	GetComputerEntityDcomUsersParamsTypeGraph GetComputerEntityDcomUsersParamsType = "graph"
	GetComputerEntityDcomUsersParamsTypeList  GetComputerEntityDcomUsersParamsType = "list"
)

// Defines values for GetComputerEntityGroupMembershipParamsType.
const (
	GetComputerEntityGroupMembershipParamsTypeCount GetComputerEntityGroupMembershipParamsType = "count"
	GetComputerEntityGroupMembershipParamsTypeGraph GetComputerEntityGroupMembershipParamsType = "graph"
	GetComputerEntityGroupMembershipParamsTypeList  GetComputerEntityGroupMembershipParamsType = "list"
)

// Defines values for GetComputerEntityPsRemoteRightsParamsType.
const (
	GetComputerEntityPsRemoteRightsParamsTypeCount GetComputerEntityPsRemoteRightsParamsType = "count"
	GetComputerEntityPsRemoteRightsParamsTypeGraph GetComputerEntityPsRemoteRightsParamsType = "graph"
	GetComputerEntityPsRemoteRightsParamsTypeList  GetComputerEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetComputerEntityPsRemoteUsersParamsType.
const (
	GetComputerEntityPsRemoteUsersParamsTypeCount GetComputerEntityPsRemoteUsersParamsType = "count"
	GetComputerEntityPsRemoteUsersParamsTypeGraph GetComputerEntityPsRemoteUsersParamsType = "graph"
	GetComputerEntityPsRemoteUsersParamsTypeList  GetComputerEntityPsRemoteUsersParamsType = "list"
)

// Defines values for GetComputerEntityRdpRightsParamsType.
const (
	GetComputerEntityRdpRightsParamsTypeCount GetComputerEntityRdpRightsParamsType = "count"
	GetComputerEntityRdpRightsParamsTypeGraph GetComputerEntityRdpRightsParamsType = "graph"
	GetComputerEntityRdpRightsParamsTypeList  GetComputerEntityRdpRightsParamsType = "list"
)

// Defines values for GetComputerEntityRdpUsersParamsType.
const (
	GetComputerEntityRdpUsersParamsTypeCount GetComputerEntityRdpUsersParamsType = "count"
	GetComputerEntityRdpUsersParamsTypeGraph GetComputerEntityRdpUsersParamsType = "graph"
	GetComputerEntityRdpUsersParamsTypeList  GetComputerEntityRdpUsersParamsType = "list"
)

// Defines values for GetComputerEntitySessionsParamsType.
const (
	GetComputerEntitySessionsParamsTypeCount GetComputerEntitySessionsParamsType = "count"
	GetComputerEntitySessionsParamsTypeGraph GetComputerEntitySessionsParamsType = "graph"
	GetComputerEntitySessionsParamsTypeList  GetComputerEntitySessionsParamsType = "list"
)

// Defines values for GetComputerEntitySqlAdminsParamsType.
const (
	GetComputerEntitySqlAdminsParamsTypeCount GetComputerEntitySqlAdminsParamsType = "count"
	GetComputerEntitySqlAdminsParamsTypeGraph GetComputerEntitySqlAdminsParamsType = "graph"
	GetComputerEntitySqlAdminsParamsTypeList  GetComputerEntitySqlAdminsParamsType = "list"
)

// Defines values for GetContainerEntityControllersParamsType.
const (
	GetContainerEntityControllersParamsTypeCount GetContainerEntityControllersParamsType = "count"
	GetContainerEntityControllersParamsTypeGraph GetContainerEntityControllersParamsType = "graph"
	GetContainerEntityControllersParamsTypeList  GetContainerEntityControllersParamsType = "list"
)

// Defines values for GetDomainEntityComputersParamsType.
const (
	GetDomainEntityComputersParamsTypeCount GetDomainEntityComputersParamsType = "count"
	GetDomainEntityComputersParamsTypeGraph GetDomainEntityComputersParamsType = "graph"
	GetDomainEntityComputersParamsTypeList  GetDomainEntityComputersParamsType = "list"
)

// Defines values for GetDomainEntityControllersParamsType.
const (
	GetDomainEntityControllersParamsTypeCount GetDomainEntityControllersParamsType = "count"
	GetDomainEntityControllersParamsTypeGraph GetDomainEntityControllersParamsType = "graph"
	GetDomainEntityControllersParamsTypeList  GetDomainEntityControllersParamsType = "list"
)

// Defines values for GetDomainEntityDcSyncersParamsType.
const (
	GetDomainEntityDcSyncersParamsTypeCount GetDomainEntityDcSyncersParamsType = "count"
	GetDomainEntityDcSyncersParamsTypeGraph GetDomainEntityDcSyncersParamsType = "graph"
	GetDomainEntityDcSyncersParamsTypeList  GetDomainEntityDcSyncersParamsType = "list"
)

// Defines values for GetDomainEntityForeignAdminsParamsType.
const (
	GetDomainEntityForeignAdminsParamsTypeCount GetDomainEntityForeignAdminsParamsType = "count"
	GetDomainEntityForeignAdminsParamsTypeGraph GetDomainEntityForeignAdminsParamsType = "graph"
	GetDomainEntityForeignAdminsParamsTypeList  GetDomainEntityForeignAdminsParamsType = "list"
)

// Defines values for GetDomainEntityForeignGpoControllersParamsType.
const (
	GetDomainEntityForeignGpoControllersParamsTypeCount GetDomainEntityForeignGpoControllersParamsType = "count"
	GetDomainEntityForeignGpoControllersParamsTypeGraph GetDomainEntityForeignGpoControllersParamsType = "graph"
	GetDomainEntityForeignGpoControllersParamsTypeList  GetDomainEntityForeignGpoControllersParamsType = "list"
)

// Defines values for GetDomainEntityForeignGroupsParamsType.
const (
	GetDomainEntityForeignGroupsParamsTypeCount GetDomainEntityForeignGroupsParamsType = "count"
	GetDomainEntityForeignGroupsParamsTypeGraph GetDomainEntityForeignGroupsParamsType = "graph"
	GetDomainEntityForeignGroupsParamsTypeList  GetDomainEntityForeignGroupsParamsType = "list"
)

// Defines values for GetDomainEntityForeignUsersParamsType.
const (
	GetDomainEntityForeignUsersParamsTypeCount GetDomainEntityForeignUsersParamsType = "count"
	GetDomainEntityForeignUsersParamsTypeGraph GetDomainEntityForeignUsersParamsType = "graph"
	GetDomainEntityForeignUsersParamsTypeList  GetDomainEntityForeignUsersParamsType = "list"
)

// Defines values for GetDomainEntityGposParamsType.
const (
	GetDomainEntityGposParamsTypeCount GetDomainEntityGposParamsType = "count"
	GetDomainEntityGposParamsTypeGraph GetDomainEntityGposParamsType = "graph"
	GetDomainEntityGposParamsTypeList  GetDomainEntityGposParamsType = "list"
)

// Defines values for GetDomainEntityGroupsParamsType.
const (
	GetDomainEntityGroupsParamsTypeCount GetDomainEntityGroupsParamsType = "count"
	GetDomainEntityGroupsParamsTypeGraph GetDomainEntityGroupsParamsType = "graph"
	GetDomainEntityGroupsParamsTypeList  GetDomainEntityGroupsParamsType = "list"
)

// Defines values for GetDomainEntityInboundTrustsParamsType.
const (
	GetDomainEntityInboundTrustsParamsTypeCount GetDomainEntityInboundTrustsParamsType = "count"
	GetDomainEntityInboundTrustsParamsTypeGraph GetDomainEntityInboundTrustsParamsType = "graph"
	GetDomainEntityInboundTrustsParamsTypeList  GetDomainEntityInboundTrustsParamsType = "list"
)

// Defines values for GetDomainEntityLinkedGposParamsType.
const (
	GetDomainEntityLinkedGposParamsTypeCount GetDomainEntityLinkedGposParamsType = "count"
	GetDomainEntityLinkedGposParamsTypeGraph GetDomainEntityLinkedGposParamsType = "graph"
	GetDomainEntityLinkedGposParamsTypeList  GetDomainEntityLinkedGposParamsType = "list"
)

// Defines values for GetDomainEntityOusParamsType.
const (
	GetDomainEntityOusParamsTypeCount GetDomainEntityOusParamsType = "count"
	GetDomainEntityOusParamsTypeGraph GetDomainEntityOusParamsType = "graph"
	GetDomainEntityOusParamsTypeList  GetDomainEntityOusParamsType = "list"
)

// Defines values for GetDomainEntityOutboundTrustsParamsType.
const (
	GetDomainEntityOutboundTrustsParamsTypeCount GetDomainEntityOutboundTrustsParamsType = "count"
	GetDomainEntityOutboundTrustsParamsTypeGraph GetDomainEntityOutboundTrustsParamsType = "graph"
	GetDomainEntityOutboundTrustsParamsTypeList  GetDomainEntityOutboundTrustsParamsType = "list"
)

// Defines values for GetDomainEntityUsersParamsType.
const (
	GetDomainEntityUsersParamsTypeCount GetDomainEntityUsersParamsType = "count"
	GetDomainEntityUsersParamsTypeGraph GetDomainEntityUsersParamsType = "graph"
	GetDomainEntityUsersParamsTypeList  GetDomainEntityUsersParamsType = "list"
)

// Defines values for GetEnterpriseCaEntityControllersParamsType.
const (
	GetEnterpriseCaEntityControllersParamsTypeCount GetEnterpriseCaEntityControllersParamsType = "count"
	GetEnterpriseCaEntityControllersParamsTypeGraph GetEnterpriseCaEntityControllersParamsType = "graph"
	GetEnterpriseCaEntityControllersParamsTypeList  GetEnterpriseCaEntityControllersParamsType = "list"
)

// Defines values for GetGpoEntityComputersParamsType.
const (
	GetGpoEntityComputersParamsTypeCount GetGpoEntityComputersParamsType = "count"
	GetGpoEntityComputersParamsTypeGraph GetGpoEntityComputersParamsType = "graph"
	GetGpoEntityComputersParamsTypeList  GetGpoEntityComputersParamsType = "list"
)

// Defines values for GetGpoEntityControllersParamsType.
const (
	GetGpoEntityControllersParamsTypeCount GetGpoEntityControllersParamsType = "count"
	GetGpoEntityControllersParamsTypeGraph GetGpoEntityControllersParamsType = "graph"
	GetGpoEntityControllersParamsTypeList  GetGpoEntityControllersParamsType = "list"
)

// Defines values for GetGpoEntityOusParamsType.
const (
	GetGpoEntityOusParamsTypeCount GetGpoEntityOusParamsType = "count"
	GetGpoEntityOusParamsTypeGraph GetGpoEntityOusParamsType = "graph"
	GetGpoEntityOusParamsTypeList  GetGpoEntityOusParamsType = "list"
)

// Defines values for GetGpoEntityTierZeroParamsType.
const (
	GetGpoEntityTierZeroParamsTypeCount GetGpoEntityTierZeroParamsType = "count"
	GetGpoEntityTierZeroParamsTypeGraph GetGpoEntityTierZeroParamsType = "graph"
	GetGpoEntityTierZeroParamsTypeList  GetGpoEntityTierZeroParamsType = "list"
)

// Defines values for GetGpoEntityUsersParamsType.
const (
	GetGpoEntityUsersParamsTypeCount GetGpoEntityUsersParamsType = "count"
	GetGpoEntityUsersParamsTypeGraph GetGpoEntityUsersParamsType = "graph"
	GetGpoEntityUsersParamsTypeList  GetGpoEntityUsersParamsType = "list"
)

// Defines values for GetSearchResultParamsType.
const (
	Exact GetSearchResultParamsType = "exact"
	Fuzzy GetSearchResultParamsType = "fuzzy"
)

// Defines values for GetGroupEntityAdminRightsParamsType.
const (
	GetGroupEntityAdminRightsParamsTypeCount GetGroupEntityAdminRightsParamsType = "count"
	GetGroupEntityAdminRightsParamsTypeGraph GetGroupEntityAdminRightsParamsType = "graph"
	GetGroupEntityAdminRightsParamsTypeList  GetGroupEntityAdminRightsParamsType = "list"
)

// Defines values for GetGroupEntityControllablesParamsType.
const (
	GetGroupEntityControllablesParamsTypeCount GetGroupEntityControllablesParamsType = "count"
	GetGroupEntityControllablesParamsTypeGraph GetGroupEntityControllablesParamsType = "graph"
	GetGroupEntityControllablesParamsTypeList  GetGroupEntityControllablesParamsType = "list"
)

// Defines values for GetGroupEntityControllersParamsType.
const (
	GetGroupEntityControllersParamsTypeCount GetGroupEntityControllersParamsType = "count"
	GetGroupEntityControllersParamsTypeGraph GetGroupEntityControllersParamsType = "graph"
	GetGroupEntityControllersParamsTypeList  GetGroupEntityControllersParamsType = "list"
)

// Defines values for GetGroupEntityDcomRightsParamsType.
const (
	GetGroupEntityDcomRightsParamsTypeCount GetGroupEntityDcomRightsParamsType = "count"
	GetGroupEntityDcomRightsParamsTypeGraph GetGroupEntityDcomRightsParamsType = "graph"
	GetGroupEntityDcomRightsParamsTypeList  GetGroupEntityDcomRightsParamsType = "list"
)

// Defines values for GetGroupEntityMembersParamsType.
const (
	GetGroupEntityMembersParamsTypeCount GetGroupEntityMembersParamsType = "count"
	GetGroupEntityMembersParamsTypeGraph GetGroupEntityMembersParamsType = "graph"
	GetGroupEntityMembersParamsTypeList  GetGroupEntityMembersParamsType = "list"
)

// Defines values for GetGroupEntityMembershipsParamsType.
const (
	GetGroupEntityMembershipsParamsTypeCount GetGroupEntityMembershipsParamsType = "count"
	GetGroupEntityMembershipsParamsTypeGraph GetGroupEntityMembershipsParamsType = "graph"
	GetGroupEntityMembershipsParamsTypeList  GetGroupEntityMembershipsParamsType = "list"
)

// Defines values for GetGroupEntityPsRemoteRightsParamsType.
const (
	GetGroupEntityPsRemoteRightsParamsTypeCount GetGroupEntityPsRemoteRightsParamsType = "count"
	GetGroupEntityPsRemoteRightsParamsTypeGraph GetGroupEntityPsRemoteRightsParamsType = "graph"
	GetGroupEntityPsRemoteRightsParamsTypeList  GetGroupEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetGroupEntityRdpRightsParamsType.
const (
	GetGroupEntityRdpRightsParamsTypeCount GetGroupEntityRdpRightsParamsType = "count"
	GetGroupEntityRdpRightsParamsTypeGraph GetGroupEntityRdpRightsParamsType = "graph"
	GetGroupEntityRdpRightsParamsTypeList  GetGroupEntityRdpRightsParamsType = "list"
)

// Defines values for GetGroupEntitySessionsParamsType.
const (
	GetGroupEntitySessionsParamsTypeCount GetGroupEntitySessionsParamsType = "count"
	GetGroupEntitySessionsParamsTypeGraph GetGroupEntitySessionsParamsType = "graph"
	GetGroupEntitySessionsParamsTypeList  GetGroupEntitySessionsParamsType = "list"
)

// Defines values for LoginJSONBodyLoginMethod.
const (
	Secret LoginJSONBodyLoginMethod = "secret"
)

// Defines values for GetNtAuthStoreEntityControllersParamsType.
const (
	GetNtAuthStoreEntityControllersParamsTypeCount GetNtAuthStoreEntityControllersParamsType = "count"
	GetNtAuthStoreEntityControllersParamsTypeGraph GetNtAuthStoreEntityControllersParamsType = "graph"
	GetNtAuthStoreEntityControllersParamsTypeList  GetNtAuthStoreEntityControllersParamsType = "list"
)

// Defines values for GetOuEntityComputersParamsType.
const (
	GetOuEntityComputersParamsTypeCount GetOuEntityComputersParamsType = "count"
	GetOuEntityComputersParamsTypeGraph GetOuEntityComputersParamsType = "graph"
	GetOuEntityComputersParamsTypeList  GetOuEntityComputersParamsType = "list"
)

// Defines values for GetOuEntityGposParamsType.
const (
	GetOuEntityGposParamsTypeCount GetOuEntityGposParamsType = "count"
	GetOuEntityGposParamsTypeGraph GetOuEntityGposParamsType = "graph"
	GetOuEntityGposParamsTypeList  GetOuEntityGposParamsType = "list"
)

// Defines values for GetOuEntityGroupsParamsType.
const (
	GetOuEntityGroupsParamsTypeCount GetOuEntityGroupsParamsType = "count"
	GetOuEntityGroupsParamsTypeGraph GetOuEntityGroupsParamsType = "graph"
	GetOuEntityGroupsParamsTypeList  GetOuEntityGroupsParamsType = "list"
)

// Defines values for GetOuEntityUsersParamsType.
const (
	GetOuEntityUsersParamsTypeCount GetOuEntityUsersParamsType = "count"
	GetOuEntityUsersParamsTypeGraph GetOuEntityUsersParamsType = "graph"
	GetOuEntityUsersParamsTypeList  GetOuEntityUsersParamsType = "list"
)

// Defines values for GetRootCaEntityControllersParamsType.
const (
	GetRootCaEntityControllersParamsTypeCount GetRootCaEntityControllersParamsType = "count"
	GetRootCaEntityControllersParamsTypeGraph GetRootCaEntityControllersParamsType = "graph"
	GetRootCaEntityControllersParamsTypeList  GetRootCaEntityControllersParamsType = "list"
)

// Defines values for GetUserEntityAdminRightsParamsType.
const (
	GetUserEntityAdminRightsParamsTypeCount GetUserEntityAdminRightsParamsType = "count"
	GetUserEntityAdminRightsParamsTypeGraph GetUserEntityAdminRightsParamsType = "graph"
	GetUserEntityAdminRightsParamsTypeList  GetUserEntityAdminRightsParamsType = "list"
)

// Defines values for GetUserEntityConstrainedDelegationRightsParamsType.
const (
	GetUserEntityConstrainedDelegationRightsParamsTypeCount GetUserEntityConstrainedDelegationRightsParamsType = "count"
	GetUserEntityConstrainedDelegationRightsParamsTypeGraph GetUserEntityConstrainedDelegationRightsParamsType = "graph"
	GetUserEntityConstrainedDelegationRightsParamsTypeList  GetUserEntityConstrainedDelegationRightsParamsType = "list"
)

// Defines values for GetUserEntityControllablesParamsType.
const (
	GetUserEntityControllablesParamsTypeCount GetUserEntityControllablesParamsType = "count"
	GetUserEntityControllablesParamsTypeGraph GetUserEntityControllablesParamsType = "graph"
	GetUserEntityControllablesParamsTypeList  GetUserEntityControllablesParamsType = "list"
)

// Defines values for GetUserEntityControllersParamsType.
const (
	GetUserEntityControllersParamsTypeCount GetUserEntityControllersParamsType = "count"
	GetUserEntityControllersParamsTypeGraph GetUserEntityControllersParamsType = "graph"
	GetUserEntityControllersParamsTypeList  GetUserEntityControllersParamsType = "list"
)

// Defines values for GetUserEntityDcomRightsParamsType.
const (
	GetUserEntityDcomRightsParamsTypeCount GetUserEntityDcomRightsParamsType = "count"
	GetUserEntityDcomRightsParamsTypeGraph GetUserEntityDcomRightsParamsType = "graph"
	GetUserEntityDcomRightsParamsTypeList  GetUserEntityDcomRightsParamsType = "list"
)

// Defines values for GetUserEntityMembershipParamsType.
const (
	GetUserEntityMembershipParamsTypeCount GetUserEntityMembershipParamsType = "count"
	GetUserEntityMembershipParamsTypeGraph GetUserEntityMembershipParamsType = "graph"
	GetUserEntityMembershipParamsTypeList  GetUserEntityMembershipParamsType = "list"
)

// Defines values for GetUserEntityPsRemoteRightsParamsType.
const (
	GetUserEntityPsRemoteRightsParamsTypeCount GetUserEntityPsRemoteRightsParamsType = "count"
	GetUserEntityPsRemoteRightsParamsTypeGraph GetUserEntityPsRemoteRightsParamsType = "graph"
	GetUserEntityPsRemoteRightsParamsTypeList  GetUserEntityPsRemoteRightsParamsType = "list"
)

// Defines values for GetUserEntityRdpRightsParamsType.
const (
	GetUserEntityRdpRightsParamsTypeCount GetUserEntityRdpRightsParamsType = "count"
	GetUserEntityRdpRightsParamsTypeGraph GetUserEntityRdpRightsParamsType = "graph"
	GetUserEntityRdpRightsParamsTypeList  GetUserEntityRdpRightsParamsType = "list"
)

// Defines values for GetUserEntitySessionsParamsType.
const (
	GetUserEntitySessionsParamsTypeCount GetUserEntitySessionsParamsType = "count"
	GetUserEntitySessionsParamsTypeGraph GetUserEntitySessionsParamsType = "graph"
	GetUserEntitySessionsParamsTypeList  GetUserEntitySessionsParamsType = "list"
)

// Defines values for GetUserEntitySqlAdminRightsParamsType.
const (
	Count GetUserEntitySqlAdminRightsParamsType = "count"
	Graph GetUserEntitySqlAdminRightsParamsType = "graph"
	List  GetUserEntitySqlAdminRightsParamsType = "list"
)

// ApiErrorDetail defines model for api.error-detail.
type ApiErrorDetail struct {
	// Context The context in which the error took place
	Context *string `json:"context,omitempty"`

	// Message A human-readable description of the error
	Message *string `json:"message,omitempty"`
}

// ApiErrorWrapper defines model for api.error-wrapper.
type ApiErrorWrapper struct {
	// Errors The error(s) that occurred from processing the request
	Errors *[]ApiErrorDetail `json:"errors,omitempty"`

	// HttpStatus The HTTP status code
	HttpStatus *int `json:"http_status,omitempty"`

	// RequestId The unique identifier of the request that failed
	RequestId *openapi_types.UUID `json:"request_id,omitempty"`

	// Timestamp The RFC-3339 timestamp in which the error response was sent
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// ApiParamsPredicateFilterBoolean Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type ApiParamsPredicateFilterBoolean = bool

// ApiParamsPredicateFilterContains The contains predicate checks a property against the values in a given comma separated list.
// - `in` checks if the property matches an element in the given comma separated list.
//   - `in:Contains,GetChangesAll,MemberOf`
//
// - `nin` checks if the property does not match an element in the given comma separated list.
//   - `nin:LocalToComputer,MemberOfLocalGroup`
type ApiParamsPredicateFilterContains = string

// ApiParamsPredicateFilterInteger Filter results by column integer value. Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type ApiParamsPredicateFilterInteger = int

// ApiParamsPredicateFilterString Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type ApiParamsPredicateFilterString = string

// ApiParamsPredicateFilterTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type ApiParamsPredicateFilterTime = time.Time

// ApiParamsPredicateFilterUuid Filter results by column string-formatted uuid value. Valid filter predicates are `eq`, `neq`.
type ApiParamsPredicateFilterUuid = openapi_types.UUID

// ApiParamsQueryLimit The limit of results requested by the client.
type ApiParamsQueryLimit = int

// ApiParamsQuerySkip The number of items to skip in a paginated response.
type ApiParamsQuerySkip = int

// ApiParamsQuerySortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order.
// See parameter description for details about which columns are sortable.
type ApiParamsQuerySortBy = string

// ApiRequestsUserSetSecret defines model for api.requests.user.set-secret.
type ApiRequestsUserSetSecret struct {
	NeedsPasswordReset *bool   `json:"needs_password_reset,omitempty"`
	Secret             *string `json:"secret,omitempty"`
}

// ApiRequestsUserUpdate defines model for api.requests.user.update.
type ApiRequestsUserUpdate struct {
	EmailAddress   *openapi_types.Email `json:"email_address,omitempty"`
	FirstName      *string              `json:"first_name,omitempty"`
	IsDisabled     *bool                `json:"is_disabled,omitempty"`
	LastName       *string              `json:"last_name,omitempty"`
	Principal      *string              `json:"principal,omitempty"`
	Roles          *[]int32             `json:"roles,omitempty"`
	SamlProviderId *string              `json:"saml_provider_id,omitempty"`
}

// ApiResponseAuthenticatedRequester defines model for api.response.authenticated-requester.
type ApiResponseAuthenticatedRequester struct {
	Data *ApiResponseAuthenticatedRequester_Data `json:"data,omitempty"`
}

// ApiResponseAuthenticatedRequester_Data defines model for ApiResponseAuthenticatedRequester.Data.
type ApiResponseAuthenticatedRequester_Data struct {
	union json.RawMessage
}

// ApiResponseDataQualityPlatformAggregate defines model for api.response.data-quality-platform-aggregate.
type ApiResponseDataQualityPlatformAggregate struct {
	Data *struct {
		// Count The total number of results.
		Count *int                                                      `json:"count,omitempty"`
		Data  *[]ApiResponseDataQualityPlatformAggregate_Data_Data_Item `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	} `json:"data,omitempty"`
}

// ApiResponseDataQualityPlatformAggregate_Data_Data_Item defines model for ApiResponseDataQualityPlatformAggregate.Data.Data.Item.
type ApiResponseDataQualityPlatformAggregate_Data_Data_Item struct {
	union json.RawMessage
}

// ApiResponseFinding defines model for api.response.finding.
type ApiResponseFinding struct {
	Data *ApiResponseFinding_Data `json:"data,omitempty"`
}

// ApiResponseFinding_Data defines model for ApiResponseFinding.Data.
type ApiResponseFinding_Data struct {
	union json.RawMessage
}

// ApiResponsePagination defines model for api.response.pagination.
type ApiResponsePagination struct {
	// Count The total number of results.
	Count *int `json:"count,omitempty"`

	// Limit The limit of results requested by the client.
	Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

	// Skip The number of items to skip in a paginated response.
	Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
}

// ApiResponseRelatedEntityQueryResultsBaseResponse defines model for api.response.related-entity-query-results.base-response.
type ApiResponseRelatedEntityQueryResultsBaseResponse struct {
	Type string `json:"type"`
}

// ApiResponseRelatedEntityQueryResultsCountResponse defines model for api.response.related-entity-query-results.count-response.
type ApiResponseRelatedEntityQueryResultsCountResponse struct {
	Count *int   `json:"count,omitempty"`
	Type  string `json:"type"`
}

// ApiResponseRelatedEntityQueryResultsGraphResponse defines model for api.response.related-entity-query-results.graph-response.
type ApiResponseRelatedEntityQueryResultsGraphResponse struct {
	Type                 string                                                                            `json:"type"`
	AdditionalProperties map[string]ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties `json:"-"`
}

// ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties defines model for api.response.related-entity-query-results.graph-response.AdditionalProperties.
type ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties struct {
	union json.RawMessage
}

// ApiResponseTimeWindow defines model for api.response.time-window.
type ApiResponseTimeWindow struct {
	// End The RFC-3339 timestamp to describe the end of a time range
	End *time.Time `json:"end,omitempty"`

	// Start The RFC-3339 timestamp to describe the beginning of a time range
	Start *time.Time `json:"start,omitempty"`
}

// EnumAuditLogStatus defines model for enum.audit-log-status.
type EnumAuditLogStatus string

// EnumClientType This enum describes the collector client type.
type EnumClientType string

// EnumDatapipeStatus defines model for enum.datapipe-status.
type EnumDatapipeStatus string

// EnumJobStatus This enum describes the current status of a Job. Values are:
// - `-1` Invalid
// - `0` Ready
// - `1` Running
// - `2` Complete
// - `3` Canceled
// - `4` Timed Out
// - `5` Failed
// - `6` Ingesting
// - `7` Analyzing
// - `8` Partially Complete
type EnumJobStatus int

// EnumMfaActivationStatus The activation status of multi-factor authentication on a BloodHound user.
type EnumMfaActivationStatus string

// EnumRiskAcceptance defines model for enum.risk-acceptance.
type EnumRiskAcceptance string

// ModelAdDataQualityAggregation defines model for model.ad-data-quality-aggregation.
type ModelAdDataQualityAggregation struct {
	Acls          *int       `json:"acls,omitempty"`
	Aiacas        *int       `json:"aiacas,omitempty"`
	Certtemplates *int       `json:"certtemplates,omitempty"`
	Computers     *int       `json:"computers,omitempty"`
	Containers    *int       `json:"containers,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	DeletedAt     *NullTime  `json:"deleted_at,omitempty"`
	Domains       *int       `json:"domains,omitempty"`
	Enterprisecas *int       `json:"enterprisecas,omitempty"`
	Gpos          *int       `json:"gpos,omitempty"`
	Groups        *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                     *int32              `json:"id,omitempty"`
	LocalGroupCompleteness *float32            `json:"local_group_completeness,omitempty"`
	Ntauthstores           *int                `json:"ntauthstores,omitempty"`
	Ous                    *int                `json:"ous,omitempty"`
	Relationships          *int                `json:"relationships,omitempty"`
	Rootcas                *int                `json:"rootcas,omitempty"`
	RunId                  *openapi_types.UUID `json:"run_id,omitempty"`
	SessionCompleteness    *float32            `json:"session_completeness,omitempty"`
	Sessions               *int                `json:"sessions,omitempty"`
	UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
	Users                  *int                `json:"users,omitempty"`
}

// ModelAdDataQualityStat defines model for model.ad-data-quality-stat.
type ModelAdDataQualityStat struct {
	Acls          *int       `json:"acls,omitempty"`
	Aiacas        *int       `json:"aiacas,omitempty"`
	Certtemplates *int       `json:"certtemplates,omitempty"`
	Computers     *int       `json:"computers,omitempty"`
	Containers    *int       `json:"containers,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	DeletedAt     *NullTime  `json:"deleted_at,omitempty"`
	DomainSid     *string    `json:"domain_sid,omitempty"`
	Enterprisecas *int       `json:"enterprisecas,omitempty"`
	Gpos          *int       `json:"gpos,omitempty"`
	Groups        *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                     *int32              `json:"id,omitempty"`
	LocalGroupCompleteness *float64            `json:"local_group_completeness,omitempty"`
	Ntauthstores           *int                `json:"ntauthstores,omitempty"`
	Ous                    *int                `json:"ous,omitempty"`
	Relationships          *int                `json:"relationships,omitempty"`
	Rootcas                *int                `json:"rootcas,omitempty"`
	RunId                  *openapi_types.UUID `json:"run_id,omitempty"`
	SessionCompleteness    *float64            `json:"session_completeness,omitempty"`
	Sessions               *int                `json:"sessions,omitempty"`
	UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
	Users                  *int                `json:"users,omitempty"`
}

// ModelAppConfigParam defines model for model.app-config-param.
type ModelAppConfigParam struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32                  `json:"id,omitempty"`
	Key       *string                 `json:"key,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	UpdatedAt *time.Time              `json:"updated_at,omitempty"`
	Value     *map[string]interface{} `json:"value,omitempty"`
}

// ModelAssetGroup defines model for model.asset-group.
type ModelAssetGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *int32                     `json:"id,omitempty"`
	MemberCount *int                       `json:"member_count,omitempty"`
	Name        *string                    `json:"name,omitempty"`
	Selectors   *[]ModelAssetGroupSelector `json:"selectors,omitempty"`
	SystemGroup *bool                      `json:"system_group,omitempty"`
	Tag         *string                    `json:"tag,omitempty"`
	UpdatedAt   *time.Time                 `json:"updated_at,omitempty"`
}

// ModelAssetGroupCollection defines model for model.asset-group-collection.
type ModelAssetGroupCollection struct {
	CreatedAt *time.Time                        `json:"created_at,omitempty"`
	DeletedAt *NullTime                         `json:"deleted_at,omitempty"`
	Entries   *[]ModelAssetGroupCollectionEntry `json:"entries,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelAssetGroupCollectionEntry defines model for model.asset-group-collection-entry.
type ModelAssetGroupCollectionEntry struct {
	AssetGroupCollectionId *int64     `json:"asset_group_collection_id,omitempty"`
	CreatedAt              *time.Time `json:"created_at,omitempty"`
	DeletedAt              *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *int64                  `json:"id,omitempty"`
	NodeLabel  *string                 `json:"node_label,omitempty"`
	ObjectId   *string                 `json:"object_id,omitempty"`
	Properties *map[string]interface{} `json:"properties,omitempty"`
	UpdatedAt  *time.Time              `json:"updated_at,omitempty"`
}

// ModelAssetGroupMember defines model for model.asset-group-member.
type ModelAssetGroupMember struct {
	AssetGroupId    *int      `json:"asset_group_id,omitempty"`
	CustomMember    *bool     `json:"custom_member,omitempty"`
	EnvironmentId   *string   `json:"environment_id,omitempty"`
	EnvironmentKind *string   `json:"environment_kind,omitempty"`
	Kinds           *[]string `json:"kinds,omitempty"`
	Name            *string   `json:"name,omitempty"`
	ObjectId        *string   `json:"object_id,omitempty"`
	PrimaryKind     *string   `json:"primary_kind,omitempty"`
}

// ModelAssetGroupSelector defines model for model.asset-group-selector.
type ModelAssetGroupSelector struct {
	AssetGroupId *int32     `json:"asset_group_id,omitempty"`
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	DeletedAt    *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id             *int32     `json:"id,omitempty"`
	Name           *string    `json:"name,omitempty"`
	Selector       *string    `json:"selector,omitempty"`
	SystemSelector *bool      `json:"system_selector,omitempty"`
	UpdatedAt      *time.Time `json:"updated_at,omitempty"`
}

// ModelAssetGroupSelectorSpec defines model for model.asset-group-selector-spec.
type ModelAssetGroupSelectorSpec struct {
	Action       *ModelAssetGroupSelectorSpecAction `json:"action,omitempty"`
	SelectorName *string                            `json:"selector_name,omitempty"`
	Sid          *string                            `json:"sid,omitempty"`
}

// ModelAssetGroupSelectorSpecAction defines model for ModelAssetGroupSelectorSpec.Action.
type ModelAssetGroupSelectorSpecAction string

// ModelAuditLog defines model for model.audit-log.
type ModelAuditLog struct {
	Action     *string                 `json:"action,omitempty"`
	ActorEmail *openapi_types.Email    `json:"actor_email,omitempty"`
	ActorId    *openapi_types.UUID     `json:"actor_id,omitempty"`
	ActorName  *string                 `json:"actor_name,omitempty"`
	CommitId   *openapi_types.UUID     `json:"commit_id,omitempty"`
	CreatedAt  *time.Time              `json:"created_at,omitempty"`
	Fields     *map[string]interface{} `json:"fields,omitempty"`

	// Id This is the unique identifier for this object.
	Id              *int64              `json:"id,omitempty"`
	RequestId       *openapi_types.UUID `json:"request_id,omitempty"`
	SourceIpAddress *string             `json:"source_ip_address,omitempty"`
	Status          *EnumAuditLogStatus `json:"status,omitempty"`
}

// ModelAuthSecret defines model for model.auth-secret.
type ModelAuthSecret struct {
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	DeletedAt    *NullTime  `json:"deleted_at,omitempty"`
	DigestMethod *string    `json:"digest_method,omitempty"`
	ExpiresAt    *time.Time `json:"expires_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int32     `json:"id,omitempty"`
	TotpActivated *bool      `json:"totp_activated,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
}

// ModelAuthToken defines model for model.auth-token.
type ModelAuthToken struct {
	CreatedAt  *time.Time `json:"created_at,omitempty"`
	DeletedAt  *NullTime  `json:"deleted_at,omitempty"`
	HmacMethod *string    `json:"hmac_method,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *openapi_types.UUID `json:"id,omitempty"`
	Key        *string             `json:"key,omitempty"`
	LastAccess *time.Time          `json:"last_access,omitempty"`
	Name       *NullString         `json:"name,omitempty"`
	UpdatedAt  *time.Time          `json:"updated_at,omitempty"`
	UserId     *NullUuid           `json:"user_id,omitempty"`
}

// ModelAzureDataQualityAggregation defines model for model.azure-data-quality-aggregation.
type ModelAzureDataQualityAggregation struct {
	Apps      *int       `json:"apps,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	Devices   *int       `json:"devices,omitempty"`
	Groups    *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                *int32              `json:"id,omitempty"`
	KeyVaults         *int                `json:"key_vaults,omitempty"`
	ManagementGroups  *int                `json:"management_groups,omitempty"`
	Relationships     *int                `json:"relationships,omitempty"`
	ResourceGroups    *int                `json:"resource_groups,omitempty"`
	RunId             *openapi_types.UUID `json:"run_id,omitempty"`
	ServicePrincipals *int                `json:"service_principals,omitempty"`
	Subscriptions     *int                `json:"subscriptions,omitempty"`
	Tenants           *int                `json:"tenants,omitempty"`
	UpdatedAt         *time.Time          `json:"updated_at,omitempty"`
	Users             *int                `json:"users,omitempty"`
	Vms               *int                `json:"vms,omitempty"`
}

// ModelAzureDataQualityStat defines model for model.azure-data-quality-stat.
type ModelAzureDataQualityStat struct {
	Apps      *int       `json:"apps,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	Devices   *int       `json:"devices,omitempty"`
	Groups    *int       `json:"groups,omitempty"`

	// Id This is the unique identifier for this object.
	Id                *int32              `json:"id,omitempty"`
	KeyVaults         *int                `json:"key_vaults,omitempty"`
	ManagementGroups  *int                `json:"management_groups,omitempty"`
	Relationships     *int                `json:"relationships,omitempty"`
	ResourceGroups    *int                `json:"resource_groups,omitempty"`
	RunId             *openapi_types.UUID `json:"run_id,omitempty"`
	ServicePrincipals *int                `json:"service_principals,omitempty"`
	Subscriptions     *int                `json:"subscriptions,omitempty"`
	Tenantid          *openapi_types.UUID `json:"tenantid,omitempty"`
	UpdatedAt         *time.Time          `json:"updated_at,omitempty"`
	Users             *int                `json:"users,omitempty"`
	Vms               *int                `json:"vms,omitempty"`
}

// ModelBhGraphEdge defines model for model.bh-graph.edge.
type ModelBhGraphEdge struct {
	Color *string                            `json:"color,omitempty"`
	Data  *map[string]map[string]interface{} `json:"data,omitempty"`
	End1  *ModelBhGraphLinkEnd               `json:"end1,omitempty"`
	End2  *ModelBhGraphLinkEnd               `json:"end2,omitempty"`
	Fade  *bool                              `json:"fade,omitempty"`
	Flow  *struct {
		Velocity *int `json:"velocity,omitempty"`
	} `json:"flow,omitempty"`
	Glyphs    *[]ModelBhGraphGlyph `json:"glyphs,omitempty"`
	Id1       *string              `json:"id1,omitempty"`
	Id2       *string              `json:"id2,omitempty"`
	Label     *ModelBhGraphLabel   `json:"label,omitempty"`
	LineStyle *string              `json:"lineStyle,omitempty"`
	Width     *int                 `json:"width,omitempty"`
}

// ModelBhGraphFontIcon defines model for model.bh-graph.font-icon.
type ModelBhGraphFontIcon struct {
	Color      *string `json:"color,omitempty"`
	FontFamily *string `json:"fontFamily,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// ModelBhGraphGlyph defines model for model.bh-graph.glyph.
type ModelBhGraphGlyph struct {
	Angle    *int                    `json:"angle,omitempty"`
	Blink    *bool                   `json:"blink,omitempty"`
	Border   *ModelBhGraphItemBorder `json:"border,omitempty"`
	Color    *string                 `json:"color,omitempty"`
	FontIcon *ModelBhGraphFontIcon   `json:"fontIcon,omitempty"`
	Image    *string                 `json:"image,omitempty"`
	Label    *ModelBhGraphLabel      `json:"label,omitempty"`
	Position *string                 `json:"position,omitempty"`
	Radius   *int                    `json:"radius,omitempty"`
	Size     *int                    `json:"size,omitempty"`
}

// ModelBhGraphGraph defines model for model.bh-graph.graph.
type ModelBhGraphGraph map[string]ModelBhGraphGraph_AdditionalProperties

// ModelBhGraphGraph_AdditionalProperties defines model for model.bh-graph.graph.AdditionalProperties.
type ModelBhGraphGraph_AdditionalProperties struct {
	union json.RawMessage
}

// ModelBhGraphItem defines model for model.bh-graph.item.
type ModelBhGraphItem struct {
	Color  *string                            `json:"color,omitempty"`
	Data   *map[string]map[string]interface{} `json:"data,omitempty"`
	Fade   *bool                              `json:"fade,omitempty"`
	Glyphs *[]ModelBhGraphGlyph               `json:"glyphs,omitempty"`
}

// ModelBhGraphItemBorder defines model for model.bh-graph.item-border.
type ModelBhGraphItemBorder struct {
	Color *string `json:"color,omitempty"`
}

// ModelBhGraphLabel defines model for model.bh-graph.label.
type ModelBhGraphLabel struct {
	Bold       *bool   `json:"bold,omitempty"`
	Color      *string `json:"color,omitempty"`
	FontFamily *string `json:"fontFamily,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// ModelBhGraphLinkEnd defines model for model.bh-graph.link-end.
type ModelBhGraphLinkEnd struct {
	Arrow   *bool                `json:"arrow,omitempty"`
	BackOff *int                 `json:"backOff,omitempty"`
	Color   *string              `json:"color,omitempty"`
	Glyphs  *[]ModelBhGraphGlyph `json:"glyphs,omitempty"`
	Label   *ModelBhGraphLabel   `json:"label,omitempty"`
}

// ModelBhGraphNode defines model for model.bh-graph.node.
type ModelBhGraphNode struct {
	Border *struct {
		Color     *string `json:"color,omitempty"`
		LineStyle *string `json:"lineStyle,omitempty"`
		Width     *int    `json:"width,omitempty"`
	} `json:"border,omitempty"`
	Color       *string `json:"color,omitempty"`
	Coordinates *struct {
		Lat *int `json:"lat,omitempty"`
		Lng *int `json:"lng,omitempty"`
	} `json:"coordinates,omitempty"`
	Cutout   *bool                              `json:"cutout,omitempty"`
	Data     *map[string]map[string]interface{} `json:"data,omitempty"`
	Fade     *bool                              `json:"fade,omitempty"`
	FontIcon *ModelBhGraphFontIcon              `json:"fontIcon,omitempty"`
	Glyphs   *[]ModelBhGraphGlyph               `json:"glyphs,omitempty"`
	Halos    *[]struct {
		Color  *string `json:"color,omitempty"`
		Radius *int    `json:"radius,omitempty"`
		Width  *int    `json:"width,omitempty"`
	} `json:"halos,omitempty"`
	Image *string `json:"image,omitempty"`
	Label *struct {
		BackgroundColor *string `json:"backgroundColor,omitempty"`
		Bold            *bool   `json:"bold,omitempty"`
		Center          *bool   `json:"center,omitempty"`
		Color           *string `json:"color,omitempty"`
		FontFamily      *string `json:"fontFamily,omitempty"`
		FontSize        *int    `json:"fontSize,omitempty"`
		Text            *string `json:"text,omitempty"`
	} `json:"label,omitempty"`
	Shape *string `json:"shape,omitempty"`
	Size  *int    `json:"size,omitempty"`
}

// ModelClient defines model for model.client.
type ModelClient struct {
	CompletedJobCount *int32                   `json:"completed_job_count,omitempty"`
	ConfiguredUser    *string                  `json:"configured_user,omitempty"`
	CreatedAt         *time.Time               `json:"created_at,omitempty"`
	CurrentJob        *ModelClientScheduledJob `json:"current_job,omitempty"`
	CurrentJobId      *NullInt64               `json:"current_job_id,omitempty"`
	DeletedAt         *NullTime                `json:"deleted_at,omitempty"`
	DomainController  *NullString              `json:"domain_controller,omitempty"`
	Events            *[]ModelClientSchedule   `json:"events,omitempty"`
	Hostname          *string                  `json:"hostname,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *openapi_types.UUID `json:"id,omitempty"`
	IpAddress   *string             `json:"ip_address,omitempty"`
	LastCheckin *time.Time          `json:"last_checkin,omitempty"`
	Name        *string             `json:"name,omitempty"`
	Token       *ModelAuthToken     `json:"token,omitempty"`
	Type        *EnumClientType     `json:"type,omitempty"`
	UpdatedAt   *time.Time          `json:"updated_at,omitempty"`
	UserSid     *NullString         `json:"user_sid,omitempty"`
	Version     *string             `json:"version,omitempty"`
}

// ModelClientDisplay defines model for model.client-display.
type ModelClientDisplay struct {
	CompletedJobCount  *int32                          `json:"completed_job_count,omitempty"`
	CompletedTaskCount *int32                          `json:"completed_task_count,omitempty"`
	ConfiguredUser     *string                         `json:"configured_user,omitempty"`
	CurrentJob         *ModelClientScheduledJobDisplay `json:"current_job,omitempty"`
	CurrentJobId       *NullInt64                      `json:"current_job_id,omitempty"`
	CurrentTask        *ModelClientScheduledJobDisplay `json:"current_task,omitempty"`
	CurrentTaskId      *NullInt64                      `json:"current_task_id,omitempty"`
	DomainController   *NullString                     `json:"domain_controller,omitempty"`
	Events             *[]ModelClientScheduleDisplay   `json:"events,omitempty"`
	Hostname           *string                         `json:"hostname,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *openapi_types.UUID `json:"id,omitempty"`
	IpAddress   *string             `json:"ip_address,omitempty"`
	LastCheckin *time.Time          `json:"last_checkin,omitempty"`
	Name        *string             `json:"name,omitempty"`
	Token       *ModelAuthToken     `json:"token,omitempty"`

	// Type This enum describes the collector client type.
	Type    *EnumClientType `json:"type,omitempty"`
	UserSid *NullString     `json:"user_sid,omitempty"`
	Version *string         `json:"version,omitempty"`
}

// ModelClientSchedule defines model for model.client-schedule.
type ModelClientSchedule struct {
	AdStructureCollection  *bool               `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool               `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool               `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool               `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID `json:"client_id,omitempty"`
	CreatedAt              *time.Time          `json:"created_at,omitempty"`
	DcRegistryCollection   *bool               `json:"dc_registry_collection,omitempty"`
	DeletedAt              *NullTime           `json:"deleted_at,omitempty"`
	Domains                *[]string           `json:"domains,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int32     `json:"id,omitempty"`
	LocalGroupCollection *bool      `json:"local_group_collection,omitempty"`
	NextScheduledAt      *time.Time `json:"next_scheduled_at,omitempty"`
	Ous                  *[]string  `json:"ous,omitempty"`
	Rrule                *string    `json:"rrule,omitempty"`
	SessionCollection    *bool      `json:"session_collection,omitempty"`
	UpdatedAt            *time.Time `json:"updated_at,omitempty"`
}

// ModelClientScheduleDisplay defines model for model.client-schedule-display.
type ModelClientScheduleDisplay struct {
	AdStructureCollection  *bool                 `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                 `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                 `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                 `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID   `json:"client_id,omitempty"`
	DcRegistryCollection   *bool                 `json:"dc_registry_collection,omitempty"`
	Domains                *[]ModelDomainDetails `json:"domains,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int32            `json:"id,omitempty"`
	LocalGroupCollection *bool             `json:"local_group_collection,omitempty"`
	Ous                  *[]ModelOuDetails `json:"ous,omitempty"`
	Rrule                *string           `json:"rrule,omitempty"`
	SessionCollection    *bool             `json:"session_collection,omitempty"`
}

// ModelClientScheduledJob defines model for model.client-scheduled-job.
type ModelClientScheduledJob struct {
	AdStructureCollection  *bool                          `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                          `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                          `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                          `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID            `json:"client_id,omitempty"`
	ClientName             *string                        `json:"client_name,omitempty"`
	CreatedAt              *time.Time                     `json:"created_at,omitempty"`
	DcRegistryCollection   *bool                          `json:"dc_registry_collection,omitempty"`
	DeletedAt              *NullTime                      `json:"deleted_at,omitempty"`
	DomainController       *NullString                    `json:"domain_controller,omitempty"`
	DomainResults          *[]ModelDomainCollectionResult `json:"domain_results,omitempty"`
	Domains                *[]string                      `json:"domains,omitempty"`
	EndTime                *time.Time                     `json:"end_time,omitempty"`
	EventId                *NullInt32                     `json:"event_id,omitempty"`
	EventTitle             *string                        `json:"event_title,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int64         `json:"id,omitempty"`
	LastIngest           *time.Time     `json:"last_ingest,omitempty"`
	LocalGroupCollection *bool          `json:"local_group_collection,omitempty"`
	LogPath              *NullString    `json:"log_path,omitempty"`
	Ous                  *[]string      `json:"ous,omitempty"`
	SessionCollection    *bool          `json:"session_collection,omitempty"`
	StartTime            *time.Time     `json:"start_time,omitempty"`
	Status               *EnumJobStatus `json:"status,omitempty"`
	StatusMessage        *string        `json:"statusMessage,omitempty"`
	UpdatedAt            *time.Time     `json:"updated_at,omitempty"`
}

// ModelClientScheduledJobDisplay defines model for model.client-scheduled-job-display.
type ModelClientScheduledJobDisplay struct {
	AdStructureCollection  *bool                          `json:"ad_structure_collection,omitempty"`
	AllTrustedDomains      *bool                          `json:"all_trusted_domains,omitempty"`
	CaRegistryCollection   *bool                          `json:"ca_registry_collection,omitempty"`
	CertServicesCollection *bool                          `json:"cert_services_collection,omitempty"`
	ClientId               *openapi_types.UUID            `json:"client_id,omitempty"`
	ClientName             *string                        `json:"client_name,omitempty"`
	DcRegistryCollection   *bool                          `json:"dc_registry_collection,omitempty"`
	DomainController       *string                        `json:"domain_controller,omitempty"`
	DomainResults          *[]ModelDomainCollectionResult `json:"domain_results,omitempty"`
	Domains                *[]ModelDomainDetails          `json:"domains,omitempty"`
	EndTime                *time.Time                     `json:"end_time,omitempty"`
	EventId                *NullInt32                     `json:"event_id,omitempty"`
	ExecutionTime          *time.Time                     `json:"execution_time,omitempty"`

	// Id This is the unique identifier for this object.
	Id                   *int64            `json:"id,omitempty"`
	LocalGroupCollection *bool             `json:"local_group_collection,omitempty"`
	Ous                  *[]ModelOuDetails `json:"ous,omitempty"`
	SessionCollection    *bool             `json:"session_collection,omitempty"`
	StartTime            *time.Time        `json:"start_time,omitempty"`

	// Status This enum describes the current status of a Job. Values are:
	// - `-1` Invalid
	// - `0` Ready
	// - `1` Running
	// - `2` Complete
	// - `3` Canceled
	// - `4` Timed Out
	// - `5` Failed
	// - `6` Ingesting
	// - `7` Analyzing
	// - `8` Partially Complete
	Status        *EnumJobStatus `json:"status,omitempty"`
	StatusMessage *string        `json:"status_message,omitempty"`
}

// ModelCollectorManifest defines model for model.collector-manifest.
type ModelCollectorManifest struct {
	Latest   *string                  `json:"latest,omitempty"`
	Versions *[]ModelCollectorVersion `json:"versions,omitempty"`
}

// ModelCollectorVersion defines model for model.collector-version.
type ModelCollectorVersion struct {
	Deprecated *bool   `json:"deprecated,omitempty"`
	Sha256sum  *string `json:"sha256sum,omitempty"`
	Version    *string `json:"version,omitempty"`
}

// ModelComponentsBaseAdEntity defines model for model.components.base-ad-entity.
type ModelComponentsBaseAdEntity struct {
	Exists   *bool   `json:"exists,omitempty"`
	Name     *string `json:"name,omitempty"`
	Objectid *string `json:"objectid,omitempty"`
}

// ModelComponentsInt32Id defines model for model.components.int32.id.
type ModelComponentsInt32Id struct {
	// Id This is the unique identifier for this object.
	Id *int32 `json:"id,omitempty"`
}

// ModelComponentsInt64Id defines model for model.components.int64.id.
type ModelComponentsInt64Id struct {
	// Id This is the unique identifier for this object.
	Id *int64 `json:"id,omitempty"`
}

// ModelComponentsTimestamps defines model for model.components.timestamps.
type ModelComponentsTimestamps struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelComponentsUuid defines model for model.components.uuid.
type ModelComponentsUuid struct {
	// Id This is the unique identifier for this object.
	Id *openapi_types.UUID `json:"id,omitempty"`
}

// ModelDomainCollectionResult defines model for model.domain-collection-result.
type ModelDomainCollectionResult struct {
	// AiacaCount A count of aiacas enumerated
	AiacaCount *int `json:"aiaca_count,omitempty"`

	// CerttemplateCount A count of certtemplates enumerated
	CerttemplateCount *int `json:"certtemplate_count,omitempty"`

	// ComputerCount A count of computers enumerated
	ComputerCount *int `json:"computer_count,omitempty"`

	// ContainerCount A count of containers enumerated
	ContainerCount *int       `json:"container_count,omitempty"`
	CreatedAt      *time.Time `json:"created_at,omitempty"`
	DeletedAt      *NullTime  `json:"deleted_at,omitempty"`

	// DeletedCount A count of deleted objects enumerated
	DeletedCount *int `json:"deleted_count,omitempty"`

	// DomainName Name of the domain that was enumerated
	DomainName *string `json:"domain_name,omitempty"`

	// EnterprisecaCount A count of enterprisecas enumerated
	EnterprisecaCount *int `json:"enterpriseca_count,omitempty"`

	// GpoCount A count of gpos enumerated
	GpoCount *int `json:"gpo_count,omitempty"`

	// GroupCount A count of groups enumerated
	GroupCount *int `json:"group_count,omitempty"`

	// Id This is the unique identifier for this object.
	Id    *int64 `json:"id,omitempty"`
	JobId *int64 `json:"job_id,omitempty"`

	// Message A status message for a domain enumeration result
	Message *string `json:"message,omitempty"`

	// NtauthstoreCount A count of ntauthstores enumerated
	NtauthstoreCount *int `json:"ntauthstore_count,omitempty"`

	// OuCount A count of ous enumerated
	OuCount *int `json:"ou_count,omitempty"`

	// RootcaCount A count of rootcas enumerated
	RootcaCount *int `json:"rootca_count,omitempty"`

	// Success A boolean value indicating whether the domain enumeration succeeded
	Success   *bool      `json:"success,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UserCount A count of users enumerated
	UserCount *int `json:"user_count,omitempty"`
}

// ModelDomainDetails defines model for model.domain-details.
type ModelDomainDetails struct {
	Exists   *bool   `json:"exists,omitempty"`
	Name     *string `json:"name,omitempty"`
	Objectid *string `json:"objectid,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// ModelDomainSelector defines model for model.domain-selector.
type ModelDomainSelector struct {
	Collected *bool   `json:"collected,omitempty"`
	Id        *string `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// ModelFeatureFlag defines model for model.feature-flag.
type ModelFeatureFlag struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Enabled     *bool      `json:"enabled,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int32     `json:"id,omitempty"`
	Key           *string    `json:"key,omitempty"`
	Name          *string    `json:"name,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
	UserUpdatable *bool      `json:"user_updatable,omitempty"`
}

// ModelFileUploadJob defines model for model.file-upload-job.
type ModelFileUploadJob struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`
	EndTime   *time.Time `json:"end_time,omitempty"`

	// Id This is the unique identifier for this object.
	Id         *int64     `json:"id,omitempty"`
	LastIngest *time.Time `json:"last_ingest,omitempty"`
	StartTime  *time.Time `json:"start_time,omitempty"`

	// Status This enum describes the current status of a Job. Values are:
	// - `-1` Invalid
	// - `0` Ready
	// - `1` Running
	// - `2` Complete
	// - `3` Canceled
	// - `4` Timed Out
	// - `5` Failed
	// - `6` Ingesting
	// - `7` Analyzing
	// - `8` Partially Complete
	Status           *EnumJobStatus       `json:"status,omitempty"`
	StatusMessage    *string              `json:"status_message,omitempty"`
	UpdatedAt        *time.Time           `json:"updated_at,omitempty"`
	UserEmailAddress *openapi_types.Email `json:"user_email_address,omitempty"`
	UserId           *openapi_types.UUID  `json:"user_id,omitempty"`
}

// ModelListFinding defines model for model.list-finding.
type ModelListFinding struct {
	DomainSID     *string                            `json:"DomainSID,omitempty"`
	Finding       *string                            `json:"Finding,omitempty"`
	Principal     *string                            `json:"Principal,omitempty"`
	PrincipalKind *string                            `json:"PrincipalKind,omitempty"`
	Props         *map[string]map[string]interface{} `json:"Props,omitempty"`
	AcceptedUntil *time.Time                         `json:"accepted_until,omitempty"`
	CreatedAt     *time.Time                         `json:"created_at,omitempty"`
	DeletedAt     *NullTime                          `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelOuDetails defines model for model.ou-details.
type ModelOuDetails struct {
	Distinguishedname *string `json:"distinguishedname,omitempty"`
	Exists            *bool   `json:"exists,omitempty"`
	Name              *string `json:"name,omitempty"`
	Objectid          *string `json:"objectid,omitempty"`
	Type              *string `json:"type,omitempty"`
}

// ModelPermission defines model for model.permission.
type ModelPermission struct {
	Authority *string    `json:"authority,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	DeletedAt *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRelationshipFinding defines model for model.relationship-finding.
type ModelRelationshipFinding struct {
	AcceptedUntil        *time.Time                         `json:"AcceptedUntil,omitempty"`
	ComboGraphRelationID *NullInt64                         `json:"ComboGraphRelationID,omitempty"`
	DomainSID            *string                            `json:"DomainSID,omitempty"`
	Finding              *string                            `json:"Finding,omitempty"`
	FromPrincipal        *string                            `json:"FromPrincipal,omitempty"`
	FromPrincipalKind    *string                            `json:"FromPrincipalKind,omitempty"`
	FromPrincipalProps   *map[string]map[string]interface{} `json:"FromPrincipalProps,omitempty"`
	PrincipalHash        *string                            `json:"PrincipalHash,omitempty"`
	RelProps             *map[string]map[string]interface{} `json:"RelProps,omitempty"`
	ToPrincipal          *string                            `json:"ToPrincipal,omitempty"`
	ToPrincipalKind      *string                            `json:"ToPrincipalKind,omitempty"`
	ToPrincipalProps     *map[string]map[string]interface{} `json:"ToPrincipalProps,omitempty"`
	CreatedAt            *time.Time                         `json:"created_at,omitempty"`
	DeletedAt            *NullTime                          `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int32     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRiskCounts defines model for model.risk-counts.
type ModelRiskCounts struct {
	CompositeRisk      *float64   `json:"CompositeRisk,omitempty"`
	DomainSID          *string    `json:"DomainSID,omitempty"`
	Finding            *string    `json:"Finding,omitempty"`
	FindingCount       *int       `json:"FindingCount,omitempty"`
	ImpactedAssetCount *int       `json:"ImpactedAssetCount,omitempty"`
	CreatedAt          *time.Time `json:"created_at,omitempty"`
	DeletedAt          *NullTime  `json:"deleted_at,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64     `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ModelRiskPostureStat defines model for model.risk-posture-stat.
type ModelRiskPostureStat struct {
	CreatedAt         *time.Time `json:"created_at,omitempty"`
	CriticalRiskCount *int       `json:"critical_risk_count,omitempty"`
	DeletedAt         *NullTime  `json:"deleted_at,omitempty"`
	DomainSid         *string    `json:"domain_sid,omitempty"`
	ExposureIndex     *float64   `json:"exposure_index,omitempty"`

	// Id This is the unique identifier for this object.
	Id            *int64     `json:"id,omitempty"`
	TierZeroCount *int64     `json:"tier_zero_count,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
}

// ModelRole defines model for model.role.
type ModelRole struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id          *int32             `json:"id,omitempty"`
	Name        *string            `json:"name,omitempty"`
	Permissions *[]ModelPermission `json:"permissions,omitempty"`
	UpdatedAt   *time.Time         `json:"updated_at,omitempty"`
}

// ModelSamlProvider defines model for model.saml-provider.
type ModelSamlProvider struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	DisplayName *string    `json:"display_name,omitempty"`

	// Id This is the unique identifier for this object.
	Id                         *int32     `json:"id,omitempty"`
	IdpIssuerUri               *string    `json:"idp_issuer_uri,omitempty"`
	IdpSsoUri                  *string    `json:"idp_sso_uri,omitempty"`
	Name                       *string    `json:"name,omitempty"`
	PrincipalAttributeMappings *[]string  `json:"principal_attribute_mappings,omitempty"`
	SpAcsUri                   *string    `json:"sp_acs_uri,omitempty"`
	SpIssuerUri                *string    `json:"sp_issuer_uri,omitempty"`
	SpMetadataUri              *string    `json:"sp_metadata_uri,omitempty"`
	SpSsoUri                   *string    `json:"sp_sso_uri,omitempty"`
	UpdatedAt                  *time.Time `json:"updated_at,omitempty"`
}

// ModelSamlSignOnEndpoint defines model for model.saml-sign-on-endpoint.
type ModelSamlSignOnEndpoint struct {
	IdpUrl *string `json:"idp_url,omitempty"`
	Name   *string `json:"name,omitempty"`
}

// ModelSavedQuery defines model for model.saved-query.
type ModelSavedQuery struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	DeletedAt   *NullTime  `json:"deleted_at,omitempty"`
	Description *string    `json:"description,omitempty"`

	// Id This is the unique identifier for this object.
	Id        *int64              `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Query     *string             `json:"query,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	UserId    *openapi_types.UUID `json:"user_id,omitempty"`
}

// ModelSearchResult defines model for model.search-result.
type ModelSearchResult struct {
	Distinguishedname *string `json:"distinguishedname,omitempty"`
	Name              *string `json:"name,omitempty"`
	Objectid          *string `json:"objectid,omitempty"`
	SystemTags        *string `json:"system_tags,omitempty"`
	Type              *string `json:"type,omitempty"`
}

// ModelUnifiedGraphEdge defines model for model.unified-graph.edge.
type ModelUnifiedGraphEdge struct {
	Kind       *string                            `json:"kind,omitempty"`
	Label      *string                            `json:"label,omitempty"`
	LastSeen   *time.Time                         `json:"lastSeen,omitempty"`
	Properties *map[string]map[string]interface{} `json:"properties,omitempty"`
	Source     *string                            `json:"source,omitempty"`
	Target     *string                            `json:"target,omitempty"`
}

// ModelUnifiedGraphGraph defines model for model.unified-graph.graph.
type ModelUnifiedGraphGraph struct {
	Edges *[]ModelUnifiedGraphEdge          `json:"edges,omitempty"`
	Nodes *map[string]ModelUnifiedGraphNode `json:"nodes,omitempty"`
}

// ModelUnifiedGraphNode defines model for model.unified-graph.node.
type ModelUnifiedGraphNode struct {
	IsTierZero *string                            `json:"isTierZero,omitempty"`
	Kind       *string                            `json:"kind,omitempty"`
	Label      *string                            `json:"label,omitempty"`
	LastSeen   *time.Time                         `json:"lastSeen,omitempty"`
	ObjectId   *string                            `json:"objectId,omitempty"`
	Properties *map[string]map[string]interface{} `json:"properties,omitempty"`
}

// ModelUser defines model for model.user.
type ModelUser struct {
	AuthSecret   *ModelAuthSecret `json:"AuthSecret,omitempty"`
	CreatedAt    *time.Time       `json:"created_at,omitempty"`
	DeletedAt    *NullTime        `json:"deleted_at,omitempty"`
	EmailAddress *NullString      `json:"email_address,omitempty"`
	EulaAccepted *bool            `json:"eula_accepted,omitempty"`
	FirstName    *NullString      `json:"first_name,omitempty"`

	// Id This is the unique identifier for this object.
	Id             *openapi_types.UUID `json:"id,omitempty"`
	IsDisabled     *bool               `json:"is_disabled,omitempty"`
	LastLogin      *time.Time          `json:"last_login,omitempty"`
	LastName       *NullString         `json:"last_name,omitempty"`
	PrincipalName  *string             `json:"principal_name,omitempty"`
	Roles          *[]ModelRole        `json:"roles,omitempty"`
	SamlProviderId *NullInt32          `json:"saml_provider_id,omitempty"`
	UpdatedAt      *time.Time          `json:"updated_at,omitempty"`
}

// NullInt32 defines model for null.int32.
type NullInt32 struct {
	Int32 *int32 `json:"int32,omitempty"`

	// Valid Valid is true if `int32` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullInt64 defines model for null.int64.
type NullInt64 struct {
	Int64 *int64 `json:"int64,omitempty"`

	// Valid Valid is true if `int64` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullString defines model for null.string.
type NullString struct {
	String *string `json:"string,omitempty"`

	// Valid Valid is true if `string`` is not `null`
	Valid *bool `json:"valid,omitempty"`
}

// NullTime defines model for null.time.
type NullTime struct {
	// Time An RFC-3339 formatted string
	Time *time.Time `json:"time,omitempty"`

	// Valid Valid is true if `time` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// NullUuid defines model for null.uuid.
type NullUuid struct {
	Uuid *openapi_types.UUID `json:"uuid,omitempty"`

	// Valid Valid is true if `uuid` is not `null`.
	Valid *bool `json:"valid,omitempty"`
}

// HeaderPrefer defines model for header.prefer.
type HeaderPrefer = int

// PathObjectId The unique object identifier
type PathObjectId = string

// QueryClientsHydrateDomains defines model for query.clients.hydrate-domains.
type QueryClientsHydrateDomains = bool

// QueryClientsHydrateOus defines model for query.clients.hydrate-ous.
type QueryClientsHydrateOus = bool

// QueryClientsJobAdStructureCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobAdStructureCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobCaRegistryCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobCaRegistryCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobCertServicesCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobCertServicesCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobClientId Filter results by column string-formatted uuid value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobClientId = ApiParamsPredicateFilterUuid

// QueryClientsJobDcRegistryCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobDcRegistryCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobDomainController Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobDomainController = ApiParamsPredicateFilterString

// QueryClientsJobEndTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobEndTime = ApiParamsPredicateFilterTime

// QueryClientsJobEventId Filter results by column integer value. Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobEventId = ApiParamsPredicateFilterInteger

// QueryClientsJobEventTitle Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobEventTitle = ApiParamsPredicateFilterString

// QueryClientsJobExecutionTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobExecutionTime = ApiParamsPredicateFilterTime

// QueryClientsJobLastIngest Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobLastIngest = ApiParamsPredicateFilterTime

// QueryClientsJobLocalGroupCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobLocalGroupCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobLogPath Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobLogPath = ApiParamsPredicateFilterString

// QueryClientsJobSessionCollection Filter results by column boolean value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobSessionCollection = ApiParamsPredicateFilterBoolean

// QueryClientsJobStartTime Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryClientsJobStartTime = ApiParamsPredicateFilterTime

// QueryClientsJobStatus Filter results by column string value. Valid filter predicates are `eq`, `neq`.
type QueryClientsJobStatus = ApiParamsPredicateFilterString

// QueryCreatedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryCreatedAt = ApiParamsPredicateFilterTime

// QueryDeletedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryDeletedAt = ApiParamsPredicateFilterTime

// QueryEntityLimit defines model for query.entity.limit.
type QueryEntityLimit = int

// QueryEntitySkip defines model for query.entity.skip.
type QueryEntitySkip = int

// QueryEntitySortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order.
// See parameter description for details about which columns are sortable.
type QueryEntitySortBy = ApiParamsQuerySortBy

// QueryEntityType defines model for query.entity.type.
type QueryEntityType string

// QueryHydrateCounts defines model for query.hydrate-counts.
type QueryHydrateCounts = bool

// QueryLimit The limit of results requested by the client.
type QueryLimit = ApiParamsQueryLimit

// QuerySkip The number of items to skip in a paginated response.
type QuerySkip = ApiParamsQuerySkip

// QueryUpdatedAt Filter results by column timestamp value formatted as an RFC-3339 string.
// Valid filter predicates are `eq`, `neq`, `gt`, `gte`, `lt`, `lte`.
type QueryUpdatedAt = ApiParamsPredicateFilterTime

// BadRequest defines model for bad-request.
type BadRequest = ApiErrorWrapper

// EntityInfoQueryResults defines model for entity-info-query-results.
type EntityInfoQueryResults struct {
	Data *struct {
		Props *map[string]map[string]interface{} `json:"props,omitempty"`
	} `json:"data,omitempty"`
}

// ErrorResponse defines model for error-response.
type ErrorResponse = ApiErrorWrapper

// Forbidden defines model for forbidden.
type Forbidden = ApiErrorWrapper

// InternalServerError defines model for internal-server-error.
type InternalServerError = ApiErrorWrapper

// NotFound defines model for not-found.
type NotFound = ApiErrorWrapper

// RelatedEntityQueryResults defines model for related-entity-query-results.
type RelatedEntityQueryResults struct {
	union json.RawMessage
}

// TooManyRequests defines model for too-many-requests.
type TooManyRequests = ApiErrorWrapper

// Unauthorized defines model for unauthorized.
type Unauthorized = ApiErrorWrapper

// AcceptEulaParams defines parameters for AcceptEula.
type AcceptEulaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAdDomainDataQualityStatsParams defines parameters for GetAdDomainDataQualityStats.
type GetAdDomainDataQualityStatsParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityParams defines parameters for GetAiaCaEntity.
type GetAiaCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityControllersParams defines parameters for GetAiaCaEntityControllers.
type GetAiaCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetAiaCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAiaCaEntityControllersParamsType defines parameters for GetAiaCaEntityControllers.
type GetAiaCaEntityControllersParamsType string

// StartAnalysisParams defines parameters for StartAnalysis.
type StartAnalysisParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupsParams defines parameters for ListAssetGroups.
type ListAssetGroupsParams struct {
	// SortBy Sortable columns are `name`, `tag`, and `member_count`.
	SortBy      *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name        *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Tag         *ApiParamsPredicateFilterString  `form:"tag,omitempty" json:"tag,omitempty"`
	SystemGroup *ApiParamsPredicateFilterString  `form:"system_group,omitempty" json:"system_group,omitempty"`
	MemberCount *ApiParamsPredicateFilterInteger `form:"member_count,omitempty" json:"member_count,omitempty"`
	Id          *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAssetGroupParams defines parameters for CreateAssetGroup.
type CreateAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAssetGroupParams defines parameters for DeleteAssetGroup.
type DeleteAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupParams defines parameters for GetAssetGroup.
type GetAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupJSONBody defines parameters for UpdateAssetGroup.
type UpdateAssetGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
}

// UpdateAssetGroupParams defines parameters for UpdateAssetGroup.
type UpdateAssetGroupParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupCollectionsParams defines parameters for ListAssetGroupCollections.
type ListAssetGroupCollectionsParams struct {
	SortBy *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id     *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupComboNodeParams defines parameters for GetAssetGroupComboNode.
type GetAssetGroupComboNodeParams struct {
	// Domainsid Filter by Domain security identifier.
	Domainsid *string `form:"domainsid,omitempty" json:"domainsid,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAssetGroupCustomMemberCountParams defines parameters for GetAssetGroupCustomMemberCount.
type GetAssetGroupCustomMemberCountParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupMembersParams defines parameters for ListAssetGroupMembers.
type ListAssetGroupMembersParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `object_id`, `asset_group_id`, `primary_kind`, `environment_id`, `environment_kind`, and `name`.
	SortBy          *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	ObjectId        *ApiParamsPredicateFilterString `form:"object_id,omitempty" json:"object_id,omitempty"`
	PrimaryKind     *ApiParamsPredicateFilterString `form:"primary_kind,omitempty" json:"primary_kind,omitempty"`
	EnvironmentId   *ApiParamsPredicateFilterString `form:"environment_id,omitempty" json:"environment_id,omitempty"`
	EnvironmentKind *ApiParamsPredicateFilterString `form:"environment_kind,omitempty" json:"environment_kind,omitempty"`
	Name            *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	CustomMember    *ApiParamsPredicateFilterString `form:"custom_member,omitempty" json:"custom_member,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAssetGroupMemberCountByKindParams defines parameters for ListAssetGroupMemberCountByKind.
type ListAssetGroupMemberCountByKindParams struct {
	ObjectId        *ApiParamsPredicateFilterString `form:"object_id,omitempty" json:"object_id,omitempty"`
	EnvironmentId   *ApiParamsPredicateFilterString `form:"environment_id,omitempty" json:"environment_id,omitempty"`
	PrimaryKind     *ApiParamsPredicateFilterString `form:"primary_kind,omitempty" json:"primary_kind,omitempty"`
	EnvironmentKind *ApiParamsPredicateFilterString `form:"environment_kind,omitempty" json:"environment_kind,omitempty"`
	Name            *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	CustomMember    *ApiParamsPredicateFilterString `form:"custom_member,omitempty" json:"custom_member,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupSelectorsDeprecatedJSONBody defines parameters for UpdateAssetGroupSelectorsDeprecated.
type UpdateAssetGroupSelectorsDeprecatedJSONBody = []ModelAssetGroupSelectorSpec

// UpdateAssetGroupSelectorsDeprecatedParams defines parameters for UpdateAssetGroupSelectorsDeprecated.
type UpdateAssetGroupSelectorsDeprecatedParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAssetGroupSelectorsJSONBody defines parameters for UpdateAssetGroupSelectors.
type UpdateAssetGroupSelectorsJSONBody = []ModelAssetGroupSelectorSpec

// UpdateAssetGroupSelectorsParams defines parameters for UpdateAssetGroupSelectors.
type UpdateAssetGroupSelectorsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAssetGroupSelectorParams defines parameters for DeleteAssetGroupSelector.
type DeleteAssetGroupSelectorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAttackPathTypesParams defines parameters for ListAttackPathTypes.
type ListAttackPathTypesParams struct {
	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy  *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding *ApiParamsPredicateFilterString `form:"finding,omitempty" json:"finding,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// StartAnalysisBheParams defines parameters for StartAnalysisBhe.
type StartAnalysisBheParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateAttackPathRiskJSONBody defines parameters for UpdateAttackPathRisk.
type UpdateAttackPathRiskJSONBody struct {
	AcceptUntil *time.Time `json:"accept_until,omitempty"`
	Accepted    *bool      `json:"accepted,omitempty"`
	RiskType    *string    `json:"risk_type,omitempty"`
}

// UpdateAttackPathRiskParams defines parameters for UpdateAttackPathRisk.
type UpdateAttackPathRiskParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// SortBy Sortable columns are `id`, `actor_id`, `actor_name`, `actor_email`, `action`, `request_id`, `created_at`, `source`, and `status`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Before Return logs created before the specified time. Value should be in the RFC-3339 format. If not supplied, this will default to the current time.
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`

	// After Return logs created after the specified time. Value should be in the RFC-3339 format. If not supplied, this will default to 1 year before the current time.
	After      *time.Time                      `form:"after,omitempty" json:"after,omitempty"`
	Id         *ApiParamsPredicateFilterString `form:"id,omitempty" json:"id,omitempty"`
	ActorId    *ApiParamsPredicateFilterString `form:"actor_id,omitempty" json:"actor_id,omitempty"`
	ActorName  *ApiParamsPredicateFilterString `form:"actor_name,omitempty" json:"actor_name,omitempty"`
	ActorEmail *ApiParamsPredicateFilterString `form:"actor_email,omitempty" json:"actor_email,omitempty"`
	Action     *ApiParamsPredicateFilterString `form:"action,omitempty" json:"action,omitempty"`
	RequestId  *ApiParamsPredicateFilterString `form:"request_id,omitempty" json:"request_id,omitempty"`
	Source     *ApiParamsPredicateFilterString `form:"source,omitempty" json:"source,omitempty"`

	// Status Filter results by column value. Valid filter predicates are `eq`, `neq`. Valid values are `success` and `failure`.
	Status *ApiParamsPredicateFilterString `form:"status,omitempty" json:"status,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAvailableDomainsParams defines parameters for GetAvailableDomains.
type GetAvailableDomainsParams struct {
	// SortBy Sortable columns are objectid, name.
	SortBy    *ApiParamsPredicateFilterString `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Objectid  *ApiParamsPredicateFilterString `form:"objectid,omitempty" json:"objectid,omitempty"`
	Name      *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	Collected *ApiParamsPredicateFilterString `form:"collected,omitempty" json:"collected,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureTenantDataQualityStatsParams defines parameters for GetAzureTenantDataQualityStats.
type GetAzureTenantDataQualityStatsParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureEntityParams defines parameters for GetAzureEntity.
type GetAzureEntityParams struct {
	// ObjectId The object ID of the entity being operated on.
	ObjectId string `form:"object_id" json:"object_id"`

	// Counts Returns related entity counts. Does not work with `related_entity_type` parameter.
	Counts *bool `form:"counts,omitempty" json:"counts,omitempty"`

	// RelatedEntityType Flags the query to return related entity information based on the type passed.
	RelatedEntityType *string `form:"related_entity_type,omitempty" json:"related_entity_type,omitempty"`

	// Type The type of return data expected. Only works with `related_entity_type` parameter.
	Type *GetAzureEntityParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	// Only compatible with `related_entity_type` and `type=list`
	Skip *ApiParamsQuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	// Only compatible with `related_entity_type` and `type=list`
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetAzureEntityParamsType defines parameters for GetAzureEntity.
type GetAzureEntityParamsType string

// GetEntityParams defines parameters for GetEntity.
type GetEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllablesParams defines parameters for GetEntityControllables.
type GetEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllablesParamsType defines parameters for GetEntityControllables.
type GetEntityControllablesParamsType string

// GetEntityControllersParams defines parameters for GetEntityControllers.
type GetEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEntityControllersParamsType defines parameters for GetEntityControllers.
type GetEntityControllersParamsType string

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// SortBy Sortable columns are first_name, last_name, email_address, principal_name, last_login, created_at, updated_at, deleted_at.
	SortBy        *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	FirstName     *ApiParamsPredicateFilterString `form:"first_name,omitempty" json:"first_name,omitempty"`
	LastName      *ApiParamsPredicateFilterString `form:"last_name,omitempty" json:"last_name,omitempty"`
	EmailAddress  *ApiParamsPredicateFilterString `form:"email_address,omitempty" json:"email_address,omitempty"`
	PrincipalName *ApiParamsPredicateFilterString `form:"principal_name,omitempty" json:"principal_name,omitempty"`
	Id            *ApiParamsPredicateFilterUuid   `form:"id,omitempty" json:"id,omitempty"`
	LastLogin     *ApiParamsPredicateFilterTime   `form:"last_login,omitempty" json:"last_login,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	EmailAddress       *openapi_types.Email `json:"email_address,omitempty"`
	FirstName          *string              `json:"first_name,omitempty"`
	IsDisabled         *bool                `json:"is_disabled,omitempty"`
	LastName           *string              `json:"last_name,omitempty"`
	NeedsPasswordReset *bool                `json:"needs_password_reset,omitempty"`
	Principal          *string              `json:"principal,omitempty"`
	Roles              *[]int32             `json:"roles,omitempty"`
	SamlProviderId     *string              `json:"saml_provider_id,omitempty"`
	Secret             *string              `json:"secret,omitempty"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateUserParams defines parameters for UpdateUser.
type UpdateUserParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// RemoveUserMfaJSONBody defines parameters for RemoveUserMfa.
type RemoveUserMfaJSONBody struct {
	Secret *string `json:"secret,omitempty"`
}

// RemoveUserMfaParams defines parameters for RemoveUserMfa.
type RemoveUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// AddUserMfaJSONBody defines parameters for AddUserMfa.
type AddUserMfaJSONBody struct {
	Secret *string `json:"secret,omitempty"`
}

// AddUserMfaParams defines parameters for AddUserMfa.
type AddUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetMfaActivationStatusParams defines parameters for GetMfaActivationStatus.
type GetMfaActivationStatusParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ActivateUserMfaJSONBody defines parameters for ActivateUserMfa.
type ActivateUserMfaJSONBody struct {
	Otp *string `json:"otp,omitempty"`
}

// ActivateUserMfaParams defines parameters for ActivateUserMfa.
type ActivateUserMfaParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteUserSecretParams defines parameters for DeleteUserSecret.
type DeleteUserSecretParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateOrSetUserSecretParams defines parameters for CreateOrSetUserSecret.
type CreateOrSetUserSecretParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityParams defines parameters for GetCertTemplateEntity.
type GetCertTemplateEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityControllersParams defines parameters for GetCertTemplateEntityControllers.
type GetCertTemplateEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetCertTemplateEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCertTemplateEntityControllersParamsType defines parameters for GetCertTemplateEntityControllers.
type GetCertTemplateEntityControllersParamsType string

// DeleteBloodHoundDatabaseJSONBody defines parameters for DeleteBloodHoundDatabase.
type DeleteBloodHoundDatabaseJSONBody struct {
	DeleteAssetGroupSelectors *[]int `json:"deleteAssetGroupSelectors,omitempty"`
	DeleteCollectedGraphData  *bool  `json:"deleteCollectedGraphData,omitempty"`
	DeleteDataQualityHistory  *bool  `json:"deleteDataQualityHistory,omitempty"`
	DeleteFileIngestHistory   *bool  `json:"deleteFileIngestHistory,omitempty"`
}

// DeleteBloodHoundDatabaseParams defines parameters for DeleteBloodHoundDatabase.
type DeleteBloodHoundDatabaseParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientsParams defines parameters for ListClients.
type ListClientsParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `name`, `ip_address`, `hostname`, `configured_user`, `last_checkin`, `completed_job_count`, `created_at`, `updated_at`, `deleted_at`.
	SortBy            *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name              *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	IpAddress         *ApiParamsPredicateFilterString  `form:"ip_address,omitempty" json:"ip_address,omitempty"`
	Hostname          *ApiParamsPredicateFilterString  `form:"hostname,omitempty" json:"hostname,omitempty"`
	ConfiguredUser    *ApiParamsPredicateFilterString  `form:"configured_user,omitempty" json:"configured_user,omitempty"`
	Version           *ApiParamsPredicateFilterString  `form:"version,omitempty" json:"version,omitempty"`
	UserSid           *ApiParamsPredicateFilterString  `form:"user_sid,omitempty" json:"user_sid,omitempty"`
	LastCheckin       *ApiParamsPredicateFilterString  `form:"last_checkin,omitempty" json:"last_checkin,omitempty"`
	CurrentJobId      *ApiParamsPredicateFilterInteger `form:"current_job_id,omitempty" json:"current_job_id,omitempty"`
	CompletedJobCount *ApiParamsPredicateFilterInteger `form:"completed_job_count,omitempty" json:"completed_job_count,omitempty"`
	DomainController  *ApiParamsPredicateFilterString  `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Id                *ApiParamsPredicateFilterUuid    `form:"id,omitempty" json:"id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientJSONBody defines parameters for CreateClient.
type CreateClientJSONBody struct {
	DomainController *string                `json:"domain_controller,omitempty"`
	Events           *[]ModelClientSchedule `json:"events,omitempty"`
	Name             *string                `json:"name,omitempty"`

	// Type This enum describes the collector client type.
	Type *EnumClientType `json:"type,omitempty"`
}

// CreateClientParams defines parameters for CreateClient.
type CreateClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LogClientErrorJSONBody defines parameters for LogClientError.
type LogClientErrorJSONBody struct {
	Additional *map[string]string `json:"additional,omitempty"`
	TaskError  *string            `json:"task_error,omitempty"`
}

// LogClientErrorParams defines parameters for LogClientError.
type LogClientErrorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientInfoJSONBody defines parameters for UpdateClientInfo.
type UpdateClientInfoJSONBody struct {
	Address  *string `json:"address,omitempty"`
	Hostname *string `json:"hostname,omitempty"`
	Username *string `json:"username,omitempty"`
	Usersid  *string `json:"usersid,omitempty"`
	Version  *string `json:"version,omitempty"`
}

// UpdateClientInfoParams defines parameters for UpdateClientInfo.
type UpdateClientInfoParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteClientParams defines parameters for DeleteClient.
type DeleteClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientParams defines parameters for GetClient.
type GetClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientJSONBody defines parameters for UpdateClient.
type UpdateClientJSONBody struct {
	DomainController *string `json:"domain_controller,omitempty"`
	Name             *string `json:"name,omitempty"`
}

// UpdateClientParams defines parameters for UpdateClient.
type UpdateClientParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientCompletedJobsParams defines parameters for ListClientCompletedJobs.
type ListClientCompletedJobsParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientCompletedTasksParams defines parameters for ListClientCompletedTasks.
type ListClientCompletedTasksParams struct {
	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduledJobParams defines parameters for CreateClientScheduledJob.
type CreateClientScheduledJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduledTaskParams defines parameters for CreateClientScheduledTask.
type CreateClientScheduledTaskParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ReplaceClientTokenParams defines parameters for ReplaceClientToken.
type ReplaceClientTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCollectorManifestParams defines parameters for GetCollectorManifest.
type GetCollectorManifestParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DownloadCollectorParams defines parameters for DownloadCollector.
type DownloadCollectorParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCollectorChecksumParams defines parameters for GetCollectorChecksum.
type GetCollectorChecksumParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetCompletenessStatsParams defines parameters for GetCompletenessStats.
type GetCompletenessStatsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityParams defines parameters for GetComputerEntity.
type GetComputerEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminRightsParams defines parameters for GetComputerEntityAdminRights.
type GetComputerEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminRightsParamsType defines parameters for GetComputerEntityAdminRights.
type GetComputerEntityAdminRightsParamsType string

// GetComputerEntityAdminsParams defines parameters for GetComputerEntityAdmins.
type GetComputerEntityAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityAdminsParamsType defines parameters for GetComputerEntityAdmins.
type GetComputerEntityAdminsParamsType string

// GetComputerEntityConstrainedDelegationRightsParams defines parameters for GetComputerEntityConstrainedDelegationRights.
type GetComputerEntityConstrainedDelegationRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityConstrainedDelegationRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityConstrainedDelegationRightsParamsType defines parameters for GetComputerEntityConstrainedDelegationRights.
type GetComputerEntityConstrainedDelegationRightsParamsType string

// GetComputerEntityConstrainedUsersParams defines parameters for GetComputerEntityConstrainedUsers.
type GetComputerEntityConstrainedUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityConstrainedUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityConstrainedUsersParamsType defines parameters for GetComputerEntityConstrainedUsers.
type GetComputerEntityConstrainedUsersParamsType string

// GetComputerEntityControllablesParams defines parameters for GetComputerEntityControllables.
type GetComputerEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityControllablesParamsType defines parameters for GetComputerEntityControllables.
type GetComputerEntityControllablesParamsType string

// GetComputerEntityControllersParams defines parameters for GetComputerEntityControllers.
type GetComputerEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityControllersParamsType defines parameters for GetComputerEntityControllers.
type GetComputerEntityControllersParamsType string

// GetComputerEntityDcomRightsParams defines parameters for GetComputerEntityDcomRights.
type GetComputerEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityDcomRightsParamsType defines parameters for GetComputerEntityDcomRights.
type GetComputerEntityDcomRightsParamsType string

// GetComputerEntityDcomUsersParams defines parameters for GetComputerEntityDcomUsers.
type GetComputerEntityDcomUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityDcomUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityDcomUsersParamsType defines parameters for GetComputerEntityDcomUsers.
type GetComputerEntityDcomUsersParamsType string

// GetComputerEntityGroupMembershipParams defines parameters for GetComputerEntityGroupMembership.
type GetComputerEntityGroupMembershipParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityGroupMembershipParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityGroupMembershipParamsType defines parameters for GetComputerEntityGroupMembership.
type GetComputerEntityGroupMembershipParamsType string

// GetComputerEntityPsRemoteRightsParams defines parameters for GetComputerEntityPsRemoteRights.
type GetComputerEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityPsRemoteRightsParamsType defines parameters for GetComputerEntityPsRemoteRights.
type GetComputerEntityPsRemoteRightsParamsType string

// GetComputerEntityPsRemoteUsersParams defines parameters for GetComputerEntityPsRemoteUsers.
type GetComputerEntityPsRemoteUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityPsRemoteUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityPsRemoteUsersParamsType defines parameters for GetComputerEntityPsRemoteUsers.
type GetComputerEntityPsRemoteUsersParamsType string

// GetComputerEntityRdpRightsParams defines parameters for GetComputerEntityRdpRights.
type GetComputerEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityRdpRightsParamsType defines parameters for GetComputerEntityRdpRights.
type GetComputerEntityRdpRightsParamsType string

// GetComputerEntityRdpUsersParams defines parameters for GetComputerEntityRdpUsers.
type GetComputerEntityRdpUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntityRdpUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntityRdpUsersParamsType defines parameters for GetComputerEntityRdpUsers.
type GetComputerEntityRdpUsersParamsType string

// GetComputerEntitySessionsParams defines parameters for GetComputerEntitySessions.
type GetComputerEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntitySessionsParamsType defines parameters for GetComputerEntitySessions.
type GetComputerEntitySessionsParamsType string

// GetComputerEntitySqlAdminsParams defines parameters for GetComputerEntitySqlAdmins.
type GetComputerEntitySqlAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetComputerEntitySqlAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComputerEntitySqlAdminsParamsType defines parameters for GetComputerEntitySqlAdmins.
type GetComputerEntitySqlAdminsParamsType string

// ListAppConfigParamsParams defines parameters for ListAppConfigParams.
type ListAppConfigParamsParams struct {
	// Parameter Parameter filter. Must follow the convention: parameter=eq:value
	Parameter *string `form:"parameter,omitempty" json:"parameter,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// SetAppConfigParamParams defines parameters for SetAppConfigParam.
type SetAppConfigParamParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityParams defines parameters for GetContainerEntity.
type GetContainerEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityControllersParams defines parameters for GetContainerEntityControllers.
type GetContainerEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetContainerEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetContainerEntityControllersParamsType defines parameters for GetContainerEntityControllers.
type GetContainerEntityControllersParamsType string

// GetDatapipeStatusParams defines parameters for GetDatapipeStatus.
type GetDatapipeStatusParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ExportAttackPathFindingsParams defines parameters for ExportAttackPathFindings.
type ExportAttackPathFindingsParams struct {
	// Finding Finding Type
	Finding string `form:"finding" json:"finding"`

	// FilterAccepted Risk acceptance filter
	FilterAccepted *EnumRiskAcceptance `form:"filterAccepted,omitempty" json:"filterAccepted,omitempty"`

	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAvailableAttackPathTypesForDomainParams defines parameters for ListAvailableAttackPathTypesForDomain.
type ListAvailableAttackPathTypesForDomainParams struct {
	// SortBy Sort by column. The only sortable column is `finding`.
	SortBy  *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding *ApiParamsPredicateFilterString `form:"finding,omitempty" json:"finding,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListDomainAttackPathsDetailsParams defines parameters for ListDomainAttackPathsDetails.
type ListDomainAttackPathsDetailsParams struct {
	FindingDeprecated *ApiParamsPredicateFilterString `form:"finding,omitempty" json:"finding,omitempty"`

	// SortBy Sortable columns are `domain_sid`, `index`, `AcceptedUntil`, `id`, `created_at`, `updated_at`, `deleted_at`. Relationship risks can be sorted on `FromPrincipal` and `ToPrincipal` in addition to the sortable columns for List Risks.
	SortBy                  *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	FromPrincipalDeprecated *ApiParamsPredicateFilterString  `form:"FromPrincipal,omitempty" json:"FromPrincipal,omitempty"`
	ToPrincipalDeprecated   *ApiParamsPredicateFilterString  `form:"ToPrincipal,omitempty" json:"ToPrincipal,omitempty"`
	FromPrincipal           *ApiParamsPredicateFilterString  `form:"from_principal,omitempty" json:"from_principal,omitempty"`
	ToPrincipal             *ApiParamsPredicateFilterString  `form:"to_principal,omitempty" json:"to_principal,omitempty"`
	PrincipalsHash          *ApiParamsPredicateFilterString  `form:"principals_hash,omitempty" json:"principals_hash,omitempty"`
	Accepted                *ApiParamsPredicateFilterString  `form:"Accepted,omitempty" json:"Accepted,omitempty"`
	AcceptedUntilDeprecated *ApiParamsPredicateFilterTime    `form:"AcceptedUntil,omitempty" json:"AcceptedUntil,omitempty"`
	AcceptedUntil           *ApiParamsPredicateFilterTime    `form:"accepted_until,omitempty" json:"accepted_until,omitempty"`
	Principal               *ApiParamsPredicateFilterString  `form:"Principal,omitempty" json:"Principal,omitempty"`
	Finding                 *ApiParamsPredicateFilterString  `form:"Finding,omitempty" json:"Finding,omitempty"`
	DomainSid               *ApiParamsPredicateFilterString  `form:"domain_sid,omitempty" json:"domain_sid,omitempty"`
	Id                      *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAttackPathSparklineValuesParams defines parameters for ListAttackPathSparklineValues.
type ListAttackPathSparklineValuesParams struct {
	// SortBy Sortable columns are `CompositeRisk`, `FindingCount`, `ImpactedAssetCount`, `domain_sid`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy  *ApiParamsQuerySortBy          `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Finding ApiParamsPredicateFilterString `form:"finding" json:"finding"`

	// From Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	From *ApiParamsPredicateFilterTime `form:"from,omitempty" json:"from,omitempty"`

	// To Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	To *ApiParamsPredicateFilterTime `form:"to,omitempty" json:"to,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityParams defines parameters for GetDomainEntity.
type GetDomainEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateDomainEntityJSONBody defines parameters for UpdateDomainEntity.
type UpdateDomainEntityJSONBody struct {
	Collected *bool `json:"collected,omitempty"`
}

// UpdateDomainEntityParams defines parameters for UpdateDomainEntity.
type UpdateDomainEntityParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityComputersParams defines parameters for GetDomainEntityComputers.
type GetDomainEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityComputersParamsType defines parameters for GetDomainEntityComputers.
type GetDomainEntityComputersParamsType string

// GetDomainEntityControllersParams defines parameters for GetDomainEntityControllers.
type GetDomainEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityControllersParamsType defines parameters for GetDomainEntityControllers.
type GetDomainEntityControllersParamsType string

// GetDomainEntityDcSyncersParams defines parameters for GetDomainEntityDcSyncers.
type GetDomainEntityDcSyncersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityDcSyncersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityDcSyncersParamsType defines parameters for GetDomainEntityDcSyncers.
type GetDomainEntityDcSyncersParamsType string

// GetDomainEntityForeignAdminsParams defines parameters for GetDomainEntityForeignAdmins.
type GetDomainEntityForeignAdminsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignAdminsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignAdminsParamsType defines parameters for GetDomainEntityForeignAdmins.
type GetDomainEntityForeignAdminsParamsType string

// GetDomainEntityForeignGpoControllersParams defines parameters for GetDomainEntityForeignGpoControllers.
type GetDomainEntityForeignGpoControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignGpoControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignGpoControllersParamsType defines parameters for GetDomainEntityForeignGpoControllers.
type GetDomainEntityForeignGpoControllersParamsType string

// GetDomainEntityForeignGroupsParams defines parameters for GetDomainEntityForeignGroups.
type GetDomainEntityForeignGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignGroupsParamsType defines parameters for GetDomainEntityForeignGroups.
type GetDomainEntityForeignGroupsParamsType string

// GetDomainEntityForeignUsersParams defines parameters for GetDomainEntityForeignUsers.
type GetDomainEntityForeignUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityForeignUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityForeignUsersParamsType defines parameters for GetDomainEntityForeignUsers.
type GetDomainEntityForeignUsersParamsType string

// GetDomainEntityGposParams defines parameters for GetDomainEntityGpos.
type GetDomainEntityGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityGposParamsType defines parameters for GetDomainEntityGpos.
type GetDomainEntityGposParamsType string

// GetDomainEntityGroupsParams defines parameters for GetDomainEntityGroups.
type GetDomainEntityGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityGroupsParamsType defines parameters for GetDomainEntityGroups.
type GetDomainEntityGroupsParamsType string

// GetDomainEntityInboundTrustsParams defines parameters for GetDomainEntityInboundTrusts.
type GetDomainEntityInboundTrustsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityInboundTrustsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityInboundTrustsParamsType defines parameters for GetDomainEntityInboundTrusts.
type GetDomainEntityInboundTrustsParamsType string

// GetDomainEntityLinkedGposParams defines parameters for GetDomainEntityLinkedGpos.
type GetDomainEntityLinkedGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityLinkedGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityLinkedGposParamsType defines parameters for GetDomainEntityLinkedGpos.
type GetDomainEntityLinkedGposParamsType string

// GetDomainEntityOusParams defines parameters for GetDomainEntityOus.
type GetDomainEntityOusParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityOusParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityOusParamsType defines parameters for GetDomainEntityOus.
type GetDomainEntityOusParamsType string

// GetDomainEntityOutboundTrustsParams defines parameters for GetDomainEntityOutboundTrusts.
type GetDomainEntityOutboundTrustsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityOutboundTrustsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityOutboundTrustsParamsType defines parameters for GetDomainEntityOutboundTrusts.
type GetDomainEntityOutboundTrustsParamsType string

// GetDomainEntityUsersParams defines parameters for GetDomainEntityUsers.
type GetDomainEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetDomainEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetDomainEntityUsersParamsType defines parameters for GetDomainEntityUsers.
type GetDomainEntityUsersParamsType string

// GetEnterpriseCaEntityParams defines parameters for GetEnterpriseCaEntity.
type GetEnterpriseCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEnterpriseCaEntityControllersParams defines parameters for GetEnterpriseCaEntityControllers.
type GetEnterpriseCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetEnterpriseCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetEnterpriseCaEntityControllersParamsType defines parameters for GetEnterpriseCaEntityControllers.
type GetEnterpriseCaEntityControllersParamsType string

// ListClientSchedulesParams defines parameters for ListClientSchedules.
type ListClientSchedulesParams struct {
	// SortBy Sortable columns are `next_scheduled_at`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Id                     *ApiParamsPredicateFilterInteger       `form:"id,omitempty" json:"id,omitempty"`
	Rrule                  *ApiParamsPredicateFilterString        `form:"rrule,omitempty" json:"rrule,omitempty"`
	NextScheduledAt        *ApiParamsPredicateFilterTime          `form:"next_scheduled_at,omitempty" json:"next_scheduled_at,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateClientScheduleParams defines parameters for CreateClientSchedule.
type CreateClientScheduleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteClientEventParams defines parameters for DeleteClientEvent.
type DeleteClientEventParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientScheduleParams defines parameters for GetClientSchedule.
type GetClientScheduleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateClientEventParams defines parameters for UpdateClientEvent.
type UpdateClientEventParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListFeatureFlagsParams defines parameters for ListFeatureFlags.
type ListFeatureFlagsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ToggleFeatureFlagParams defines parameters for ToggleFeatureFlag.
type ToggleFeatureFlagParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListFileUploadJobsParams defines parameters for ListFileUploadJobs.
type ListFileUploadJobsParams struct {
	// SortBy Sortable columns are `user_email_address`, `status`, `status_message`, `start_time`, `end_time`, `last_ingest`, `id`, `created_at`, `updated_at`, and `deleted_at`.
	SortBy           *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	UserId           *ApiParamsPredicateFilterString  `form:"user_id,omitempty" json:"user_id,omitempty"`
	UserEmailAddress *ApiParamsPredicateFilterString  `form:"user_email_address,omitempty" json:"user_email_address,omitempty"`
	Status           *ApiParamsPredicateFilterInteger `form:"status,omitempty" json:"status,omitempty"`
	StatusMessage    *ApiParamsPredicateFilterString  `form:"status_message,omitempty" json:"status_message,omitempty"`
	StartTime        *ApiParamsPredicateFilterTime    `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime          *ApiParamsPredicateFilterTime    `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest       *ApiParamsPredicateFilterTime    `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`
	Id               *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAcceptedFileUploadTypesParams defines parameters for ListAcceptedFileUploadTypes.
type ListAcceptedFileUploadTypesParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateFileUploadJobParams defines parameters for CreateFileUploadJob.
type CreateFileUploadJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UploadFileToJobJSONBody defines parameters for UploadFileToJob.
type UploadFileToJobJSONBody = map[string]interface{}

// UploadFileToJobParams defines parameters for UploadFileToJob.
type UploadFileToJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`

	// ContentType Content type header, used to specify the type of content being sent by the client.
	ContentType string `json:"Content-Type"`
}

// EndFileUploadJobParams defines parameters for EndFileUploadJob.
type EndFileUploadJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityParams defines parameters for GetGpoEntity.
type GetGpoEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityComputersParams defines parameters for GetGpoEntityComputers.
type GetGpoEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityComputersParamsType defines parameters for GetGpoEntityComputers.
type GetGpoEntityComputersParamsType string

// GetGpoEntityControllersParams defines parameters for GetGpoEntityControllers.
type GetGpoEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityControllersParamsType defines parameters for GetGpoEntityControllers.
type GetGpoEntityControllersParamsType string

// GetGpoEntityOusParams defines parameters for GetGpoEntityOus.
type GetGpoEntityOusParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityOusParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityOusParamsType defines parameters for GetGpoEntityOus.
type GetGpoEntityOusParamsType string

// GetGpoEntityTierZeroParams defines parameters for GetGpoEntityTierZero.
type GetGpoEntityTierZeroParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityTierZeroParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityTierZeroParamsType defines parameters for GetGpoEntityTierZero.
type GetGpoEntityTierZeroParamsType string

// GetGpoEntityUsersParams defines parameters for GetGpoEntityUsers.
type GetGpoEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGpoEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGpoEntityUsersParamsType defines parameters for GetGpoEntityUsers.
type GetGpoEntityUsersParamsType string

// GetSearchResultParams defines parameters for GetSearchResult.
type GetSearchResultParams struct {
	// SearchQuery Search query
	SearchQuery string `form:"search_query" json:"search_query"`

	// Type The type of search strategy to use. Default is `fuzzy`.
	Type *GetSearchResultParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSearchResultParamsType defines parameters for GetSearchResult.
type GetSearchResultParamsType string

// RunCypherQueryJSONBody defines parameters for RunCypherQuery.
type RunCypherQueryJSONBody struct {
	IncludeProperties *bool   `json:"include_properties,omitempty"`
	Query             *string `json:"query,omitempty"`
}

// RunCypherQueryParams defines parameters for RunCypherQuery.
type RunCypherQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPathCompositionParams defines parameters for GetPathComposition.
type GetPathCompositionParams struct {
	// SourceNode The ID of the starting node.
	SourceNode int32 `form:"source_node" json:"source_node"`

	// TargetNode The ID of the ending node.
	TargetNode int32 `form:"target_node" json:"target_node"`

	// EdgeType The type of edge to show the composition for.
	EdgeType string `form:"edge_type" json:"edge_type"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetShortestPathParams defines parameters for GetShortestPath.
type GetShortestPathParams struct {
	// StartNode The start node objectId
	StartNode int32 `form:"start_node" json:"start_node"`

	// EndNode The end node objectId
	EndNode           int32                             `form:"end_node" json:"end_node"`
	RelationshipKinds *ApiParamsPredicateFilterContains `form:"relationship_kinds,omitempty" json:"relationship_kinds,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityParams defines parameters for GetGroupEntity.
type GetGroupEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityAdminRightsParams defines parameters for GetGroupEntityAdminRights.
type GetGroupEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityAdminRightsParamsType defines parameters for GetGroupEntityAdminRights.
type GetGroupEntityAdminRightsParamsType string

// GetGroupEntityControllablesParams defines parameters for GetGroupEntityControllables.
type GetGroupEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityControllablesParamsType defines parameters for GetGroupEntityControllables.
type GetGroupEntityControllablesParamsType string

// GetGroupEntityControllersParams defines parameters for GetGroupEntityControllers.
type GetGroupEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityControllersParamsType defines parameters for GetGroupEntityControllers.
type GetGroupEntityControllersParamsType string

// GetGroupEntityDcomRightsParams defines parameters for GetGroupEntityDcomRights.
type GetGroupEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityDcomRightsParamsType defines parameters for GetGroupEntityDcomRights.
type GetGroupEntityDcomRightsParamsType string

// GetGroupEntityMembersParams defines parameters for GetGroupEntityMembers.
type GetGroupEntityMembersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityMembersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityMembersParamsType defines parameters for GetGroupEntityMembers.
type GetGroupEntityMembersParamsType string

// GetGroupEntityMembershipsParams defines parameters for GetGroupEntityMemberships.
type GetGroupEntityMembershipsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityMembershipsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityMembershipsParamsType defines parameters for GetGroupEntityMemberships.
type GetGroupEntityMembershipsParamsType string

// GetGroupEntityPsRemoteRightsParams defines parameters for GetGroupEntityPsRemoteRights.
type GetGroupEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityPsRemoteRightsParamsType defines parameters for GetGroupEntityPsRemoteRights.
type GetGroupEntityPsRemoteRightsParamsType string

// GetGroupEntityRdpRightsParams defines parameters for GetGroupEntityRdpRights.
type GetGroupEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntityRdpRightsParamsType defines parameters for GetGroupEntityRdpRights.
type GetGroupEntityRdpRightsParamsType string

// GetGroupEntitySessionsParams defines parameters for GetGroupEntitySessions.
type GetGroupEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetGroupEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetGroupEntitySessionsParamsType defines parameters for GetGroupEntitySessions.
type GetGroupEntitySessionsParamsType string

// IngestDataParams defines parameters for IngestData.
type IngestDataParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobsParams defines parameters for GetClientJobs.
type GetClientJobsParams struct {
	// SortBy Sortable columns are `client_name`, `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAvailableClientJobsParams defines parameters for ListAvailableClientJobs.
type ListAvailableClientJobsParams struct {
	// SortBy Sortable columns are `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, and `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientCurrentJobParams defines parameters for GetClientCurrentJob.
type GetClientCurrentJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// EndClientJobParams defines parameters for EndClientJob.
type EndClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListClientFinishedJobsParams defines parameters for ListClientFinishedJobs.
type ListClientFinishedJobsParams struct {
	// SortBy Sortable columns are `client_name`, `event_id`, `execution_time`, `status`, `start_time`, `end_time`, `log_path`, `domain_controller`, `event_title`, `last_ingest`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy                 *ApiParamsQuerySortBy                  `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	LogPath                *QueryClientsJobLogPath                `form:"log_path,omitempty" json:"log_path,omitempty"`
	SessionCollection      *QueryClientsJobSessionCollection      `form:"session_collection,omitempty" json:"session_collection,omitempty"`
	LocalGroupCollection   *QueryClientsJobLocalGroupCollection   `form:"local_group_collection,omitempty" json:"local_group_collection,omitempty"`
	CertServicesCollection *QueryClientsJobCertServicesCollection `form:"cert_services_collection,omitempty" json:"cert_services_collection,omitempty"`
	CaRegistryCollection   *QueryClientsJobCaRegistryCollection   `form:"ca_registry_collection,omitempty" json:"ca_registry_collection,omitempty"`
	DcRegistryCollection   *QueryClientsJobDcRegistryCollection   `form:"dc_registry_collection,omitempty" json:"dc_registry_collection,omitempty"`
	AdStructureCollection  *QueryClientsJobAdStructureCollection  `form:"ad_structure_collection,omitempty" json:"ad_structure_collection,omitempty"`
	DomainController       *QueryClientsJobDomainController       `form:"domain_controller,omitempty" json:"domain_controller,omitempty"`
	Status                 *QueryClientsJobStatus                 `form:"status,omitempty" json:"status,omitempty"`
	EventTitle             *QueryClientsJobEventTitle             `form:"event_title,omitempty" json:"event_title,omitempty"`
	ClientId               *QueryClientsJobClientId               `form:"client_id,omitempty" json:"client_id,omitempty"`
	EventId                *QueryClientsJobEventId                `form:"event_id,omitempty" json:"event_id,omitempty"`
	ExecutionTime          *QueryClientsJobExecutionTime          `form:"execution_time,omitempty" json:"execution_time,omitempty"`
	StartTime              *QueryClientsJobStartTime              `form:"start_time,omitempty" json:"start_time,omitempty"`
	EndTime                *QueryClientsJobEndTime                `form:"end_time,omitempty" json:"end_time,omitempty"`
	LastIngest             *QueryClientsJobLastIngest             `form:"last_ingest,omitempty" json:"last_ingest,omitempty"`

	// HydrateDomains When a value of `true` is passed, any Domains associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same Domains will only return as a list of `objectid`s.
	HydrateDomains *QueryClientsHydrateDomains `form:"hydrate_domains,omitempty" json:"hydrate_domains,omitempty"`

	// HydrateOus When a value of `true` is passed, any OUs associated with scheduled and finished jobs for each client will have expanded properties including `name` and `type`. When a value of `false` is passed, these same OUs will only return as a list of `objectid`s.
	HydrateOus *QueryClientsHydrateOus `form:"hydrate_ous,omitempty" json:"hydrate_ous,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// StartClientJobJSONBody defines parameters for StartClientJob.
type StartClientJobJSONBody struct {
	Id *int64 `json:"id,omitempty"`
}

// StartClientJobParams defines parameters for StartClientJob.
type StartClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobParams defines parameters for GetClientJob.
type GetClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CancelClientJobParams defines parameters for CancelClientJob.
type CancelClientJobParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetClientJobLogParams defines parameters for GetClientJobLog.
type GetClientJobLogParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	// LoginMethod The type of login. Currently only `secret` is supported.
	LoginMethod LoginJSONBodyLoginMethod `json:"login_method"`

	// Otp The One Time Password for a single login. This field can be used instead of `secret`
	Otp *string `json:"otp,omitempty"`

	// Secret The password for the user. This field can be used instead of `otp`.
	Secret   *string `json:"secret,omitempty"`
	Username string  `json:"username"`
}

// LoginParams defines parameters for Login.
type LoginParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// LoginJSONBodyLoginMethod defines parameters for Login.
type LoginJSONBodyLoginMethod string

// LogoutParams defines parameters for Logout.
type LogoutParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetLatestTierZeroComboNodeParams defines parameters for GetLatestTierZeroComboNode.
type GetLatestTierZeroComboNodeParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetComboTreeGraphParams defines parameters for GetComboTreeGraph.
type GetComboTreeGraphParams struct {
	// NodeId Node ID
	NodeId *int64 `form:"node_id,omitempty" json:"node_id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetMetaEntityParams defines parameters for GetMetaEntity.
type GetMetaEntityParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityParams defines parameters for GetNtAuthStoreEntity.
type GetNtAuthStoreEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityControllersParams defines parameters for GetNtAuthStoreEntityControllers.
type GetNtAuthStoreEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetNtAuthStoreEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetNtAuthStoreEntityControllersParamsType defines parameters for GetNtAuthStoreEntityControllers.
type GetNtAuthStoreEntityControllersParamsType string

// GetOuEntityParams defines parameters for GetOuEntity.
type GetOuEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityComputersParams defines parameters for GetOuEntityComputers.
type GetOuEntityComputersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityComputersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityComputersParamsType defines parameters for GetOuEntityComputers.
type GetOuEntityComputersParamsType string

// GetOuEntityGposParams defines parameters for GetOuEntityGpos.
type GetOuEntityGposParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityGposParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityGposParamsType defines parameters for GetOuEntityGpos.
type GetOuEntityGposParamsType string

// GetOuEntityGroupsParams defines parameters for GetOuEntityGroups.
type GetOuEntityGroupsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityGroupsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityGroupsParamsType defines parameters for GetOuEntityGroups.
type GetOuEntityGroupsParamsType string

// GetOuEntityUsersParams defines parameters for GetOuEntityUsers.
type GetOuEntityUsersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetOuEntityUsersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetOuEntityUsersParamsType defines parameters for GetOuEntityUsers.
type GetOuEntityUsersParamsType string

// PathfindingParams defines parameters for Pathfinding.
type PathfindingParams struct {
	// StartNode Start Node
	StartNode string `form:"start_node" json:"start_node"`

	// EndNode End Node
	EndNode string `form:"end_node" json:"end_node"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListPermissionsParams defines parameters for ListPermissions.
type ListPermissionsParams struct {
	// SortBy Sortable columns are `authority`, `name`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy    *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Authority *ApiParamsPredicateFilterString  `form:"authority,omitempty" json:"authority,omitempty"`
	Name      *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Id        *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPermissionParams defines parameters for GetPermission.
type GetPermissionParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPlatformDataQualityAggregateParams defines parameters for GetPlatformDataQualityAggregate.
type GetPlatformDataQualityAggregateParams struct {
	// SortBy Sortable columns are created_at, updated_at.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Start Beginning datetime of range (inclusive) in RFC-3339 format; Defaults to current datetime minus 30 days
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End Ending datetime of range (exclusive) in RFC-3339 format; Defaults to current datetime
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetPostureStatsParams defines parameters for GetPostureStats.
type GetPostureStatsParams struct {
	// SortBy Sortable columns are `domain_sid`, `exposure_index`, `tier_zero_count`, `critical_risk_count`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy *ApiParamsQuerySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// FromDeprecated Lower bound for created_at; to return posture stats starting at a specific date/time
	FromDeprecated *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// ToDeprecated Upper bound for created_at; to return posture stats upto a specific date/time
	ToDeprecated      *time.Time                       `form:"to,omitempty" json:"to,omitempty"`
	DomainSid         *ApiParamsPredicateFilterString  `form:"domain_sid,omitempty" json:"domain_sid,omitempty"`
	ExposureIndex     *ApiParamsPredicateFilterInteger `form:"exposure_index,omitempty" json:"exposure_index,omitempty"`
	TierZeroCount     *ApiParamsPredicateFilterInteger `form:"tier_zero_count,omitempty" json:"tier_zero_count,omitempty"`
	CriticalRiskCount *ApiParamsPredicateFilterInteger `form:"critical_risk_count,omitempty" json:"critical_risk_count,omitempty"`
	Id                *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {
	// SortBy Sortable columns are `name`, `description`, `id`, `created_at`, `updated_at`, `deleted_at`.
	SortBy *ApiParamsQuerySortBy            `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name   *ApiParamsPredicateFilterString  `form:"name,omitempty" json:"name,omitempty"`
	Id     *ApiParamsPredicateFilterInteger `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRoleParams defines parameters for GetRole.
type GetRoleParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityParams defines parameters for GetRootCaEntity.
type GetRootCaEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityControllersParams defines parameters for GetRootCaEntityControllers.
type GetRootCaEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetRootCaEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetRootCaEntityControllersParamsType defines parameters for GetRootCaEntityControllers.
type GetRootCaEntityControllersParamsType string

// ListSamlProvidersParams defines parameters for ListSamlProviders.
type ListSamlProvidersParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateSamlProviderMultipartBody defines parameters for CreateSamlProvider.
type CreateSamlProviderMultipartBody struct {
	// Metadata Metadata XML file.
	Metadata *openapi_types.File `json:"metadata,omitempty"`

	// Name Name of the new SAML provider.
	Name *string `json:"name,omitempty"`
}

// DeleteSamlProviderParams defines parameters for DeleteSamlProvider.
type DeleteSamlProviderParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSamlProviderParams defines parameters for GetSamlProvider.
type GetSamlProviderParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSamlSignSignOnEndpointsParams defines parameters for GetSamlSignSignOnEndpoints.
type GetSamlSignSignOnEndpointsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListSavedQueriesParams defines parameters for ListSavedQueries.
type ListSavedQueriesParams struct {
	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Sortable columns are user_id, name, query, id, created_at, updated_at, deleted_at.
	SortBy *ApiParamsQuerySortBy             `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name   *ApiParamsPredicateFilterString   `form:"name,omitempty" json:"name,omitempty"`
	Query  *ApiParamsPredicateFilterString   `form:"query,omitempty" json:"query,omitempty"`
	UserId *ApiParamsPredicateFilterString   `form:"user_id,omitempty" json:"user_id,omitempty"`
	Scope  *ApiParamsPredicateFilterContains `form:"scope,omitempty" json:"scope,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateSavedQueryParams defines parameters for CreateSavedQuery.
type CreateSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteSavedQueryParams defines parameters for DeleteSavedQuery.
type DeleteSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// UpdateSavedQueryParams defines parameters for UpdateSavedQuery.
type UpdateSavedQueryParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteSavedQueryPermissionsJSONBody defines parameters for DeleteSavedQueryPermissions.
type DeleteSavedQueryPermissionsJSONBody struct {
	// UserIds A list of user ids that will have their permission revoked from the given saved query
	UserIds *[]openapi_types.UUID `json:"user_ids,omitempty"`
}

// DeleteSavedQueryPermissionsParams defines parameters for DeleteSavedQueryPermissions.
type DeleteSavedQueryPermissionsParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Q Search parameter for the name or object ID of a node.
	Q string `form:"q" json:"q"`

	// Type Node type.
	// Some AD examples: `Base`, `User`, `Computer`, `Group`, `Container`.
	// Some Azure examples: `AZBase`, `AZApp`, `AZDevice`.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Skip This query parameter is used for determining the number of objects to skip in pagination.
	Skip *QuerySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit This query parameter is used for setting an upper limit of objects returned in paginated responses.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetSelfParams defines parameters for GetSelf.
type GetSelfParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetApiSpecParams defines parameters for GetApiSpec.
type GetApiSpecParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// ListAuthTokensParams defines parameters for ListAuthTokens.
type ListAuthTokensParams struct {
	// UserId Provide a user id to filter tokens by. This filter is only honored for Admin users.
	UserId *ApiParamsPredicateFilterUuid `form:"user_id,omitempty" json:"user_id,omitempty"`

	// SortBy Sortable columns are `user_id`, `client_id`, `name`, `last_access`, `created_at`, `updated_at`, `deleted_at`.
	SortBy     *ApiParamsQuerySortBy           `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	Name       *ApiParamsPredicateFilterString `form:"name,omitempty" json:"name,omitempty"`
	Key        *ApiParamsPredicateFilterString `form:"key,omitempty" json:"key,omitempty"`
	HmacMethod *ApiParamsPredicateFilterString `form:"hmac_method,omitempty" json:"hmac_method,omitempty"`
	LastAccess *ApiParamsPredicateFilterTime   `form:"last_access,omitempty" json:"last_access,omitempty"`
	Id         *ApiParamsPredicateFilterUuid   `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter results by `created_at` value. See filter schema details for valid predicates.
	CreatedAt *QueryCreatedAt `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter results by `updated_at` value. See filter schema details for valid predicates.
	UpdatedAt *QueryUpdatedAt `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter results by `deleted_at` value. See filter schema details for valid predicates.
	DeletedAt *QueryDeletedAt `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAuthTokenJSONBody defines parameters for CreateAuthToken.
type CreateAuthTokenJSONBody struct {
	TokenName *string             `json:"token_name,omitempty"`
	UserId    *openapi_types.UUID `json:"user_id,omitempty"`
}

// CreateAuthTokenParams defines parameters for CreateAuthToken.
type CreateAuthTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// DeleteAuthTokenParams defines parameters for DeleteAuthToken.
type DeleteAuthTokenParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityParams defines parameters for GetUserEntity.
type GetUserEntityParams struct {
	// Counts Include counts of related entities. Default value is `true`.
	Counts *QueryHydrateCounts `form:"counts,omitempty" json:"counts,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityAdminRightsParams defines parameters for GetUserEntityAdminRights.
type GetUserEntityAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityAdminRightsParamsType defines parameters for GetUserEntityAdminRights.
type GetUserEntityAdminRightsParamsType string

// GetUserEntityConstrainedDelegationRightsParams defines parameters for GetUserEntityConstrainedDelegationRights.
type GetUserEntityConstrainedDelegationRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityConstrainedDelegationRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityConstrainedDelegationRightsParamsType defines parameters for GetUserEntityConstrainedDelegationRights.
type GetUserEntityConstrainedDelegationRightsParamsType string

// GetUserEntityControllablesParams defines parameters for GetUserEntityControllables.
type GetUserEntityControllablesParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityControllablesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityControllablesParamsType defines parameters for GetUserEntityControllables.
type GetUserEntityControllablesParamsType string

// GetUserEntityControllersParams defines parameters for GetUserEntityControllers.
type GetUserEntityControllersParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityControllersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityControllersParamsType defines parameters for GetUserEntityControllers.
type GetUserEntityControllersParamsType string

// GetUserEntityDcomRightsParams defines parameters for GetUserEntityDcomRights.
type GetUserEntityDcomRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityDcomRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityDcomRightsParamsType defines parameters for GetUserEntityDcomRights.
type GetUserEntityDcomRightsParamsType string

// GetUserEntityMembershipParams defines parameters for GetUserEntityMembership.
type GetUserEntityMembershipParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityMembershipParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityMembershipParamsType defines parameters for GetUserEntityMembership.
type GetUserEntityMembershipParamsType string

// GetUserEntityPsRemoteRightsParams defines parameters for GetUserEntityPsRemoteRights.
type GetUserEntityPsRemoteRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityPsRemoteRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityPsRemoteRightsParamsType defines parameters for GetUserEntityPsRemoteRights.
type GetUserEntityPsRemoteRightsParamsType string

// GetUserEntityRdpRightsParams defines parameters for GetUserEntityRdpRights.
type GetUserEntityRdpRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntityRdpRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntityRdpRightsParamsType defines parameters for GetUserEntityRdpRights.
type GetUserEntityRdpRightsParamsType string

// GetUserEntitySessionsParams defines parameters for GetUserEntitySessions.
type GetUserEntitySessionsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntitySessionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntitySessionsParamsType defines parameters for GetUserEntitySessions.
type GetUserEntitySessionsParamsType string

// GetUserEntitySqlAdminRightsParams defines parameters for GetUserEntitySqlAdminRights.
type GetUserEntitySqlAdminRightsParams struct {
	// Skip The number of entries to skip for pagination. Only available for `type=list`.
	Skip *QueryEntitySkip `form:"skip,omitempty" json:"skip,omitempty"`

	// Limit The number of entries to limit in the response. Only available for `type=list`.
	Limit *QueryEntityLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type The type of return data requested. If no type is provided, query will default to `list`,
	// but invalid types will result in a `count` query. Some entity query endpoints do not
	// support the `graph` type.
	Type *GetUserEntitySqlAdminRightsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// SortBy Sort by column. Can be used multiple times; prepend a hyphen for descending order. Columns available
	// for sorting are dependent on the entity object kind.
	SortBy *QueryEntitySortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// GetUserEntitySqlAdminRightsParamsType defines parameters for GetUserEntitySqlAdminRights.
type GetUserEntitySqlAdminRightsParamsType string

// GetApiVersionParams defines parameters for GetApiVersion.
type GetApiVersionParams struct {
	// Prefer Prefer header, used to specify a custom timeout in seconds using the wait parameter as per RFC7240.
	Prefer *HeaderPrefer `json:"Prefer,omitempty"`
}

// CreateAssetGroupJSONRequestBody defines body for CreateAssetGroup for application/json ContentType.
type CreateAssetGroupJSONRequestBody = ModelAssetGroup

// UpdateAssetGroupJSONRequestBody defines body for UpdateAssetGroup for application/json ContentType.
type UpdateAssetGroupJSONRequestBody UpdateAssetGroupJSONBody

// UpdateAssetGroupSelectorsDeprecatedJSONRequestBody defines body for UpdateAssetGroupSelectorsDeprecated for application/json ContentType.
type UpdateAssetGroupSelectorsDeprecatedJSONRequestBody = UpdateAssetGroupSelectorsDeprecatedJSONBody

// UpdateAssetGroupSelectorsJSONRequestBody defines body for UpdateAssetGroupSelectors for application/json ContentType.
type UpdateAssetGroupSelectorsJSONRequestBody = UpdateAssetGroupSelectorsJSONBody

// UpdateAttackPathRiskJSONRequestBody defines body for UpdateAttackPathRisk for application/json ContentType.
type UpdateAttackPathRiskJSONRequestBody UpdateAttackPathRiskJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = ApiRequestsUserUpdate

// RemoveUserMfaJSONRequestBody defines body for RemoveUserMfa for application/json ContentType.
type RemoveUserMfaJSONRequestBody RemoveUserMfaJSONBody

// AddUserMfaJSONRequestBody defines body for AddUserMfa for application/json ContentType.
type AddUserMfaJSONRequestBody AddUserMfaJSONBody

// ActivateUserMfaJSONRequestBody defines body for ActivateUserMfa for application/json ContentType.
type ActivateUserMfaJSONRequestBody ActivateUserMfaJSONBody

// CreateOrSetUserSecretJSONRequestBody defines body for CreateOrSetUserSecret for application/json ContentType.
type CreateOrSetUserSecretJSONRequestBody = ApiRequestsUserSetSecret

// DeleteBloodHoundDatabaseJSONRequestBody defines body for DeleteBloodHoundDatabase for application/json ContentType.
type DeleteBloodHoundDatabaseJSONRequestBody DeleteBloodHoundDatabaseJSONBody

// CreateClientJSONRequestBody defines body for CreateClient for application/json ContentType.
type CreateClientJSONRequestBody CreateClientJSONBody

// LogClientErrorJSONRequestBody defines body for LogClientError for application/json ContentType.
type LogClientErrorJSONRequestBody LogClientErrorJSONBody

// UpdateClientInfoJSONRequestBody defines body for UpdateClientInfo for application/json ContentType.
type UpdateClientInfoJSONRequestBody UpdateClientInfoJSONBody

// UpdateClientJSONRequestBody defines body for UpdateClient for application/json ContentType.
type UpdateClientJSONRequestBody UpdateClientJSONBody

// CreateClientScheduledJobJSONRequestBody defines body for CreateClientScheduledJob for application/json ContentType.
type CreateClientScheduledJobJSONRequestBody = ModelClientScheduledJob

// CreateClientScheduledTaskJSONRequestBody defines body for CreateClientScheduledTask for application/json ContentType.
type CreateClientScheduledTaskJSONRequestBody = ModelClientScheduledJob

// SetAppConfigParamJSONRequestBody defines body for SetAppConfigParam for application/json ContentType.
type SetAppConfigParamJSONRequestBody = ModelAppConfigParam

// UpdateDomainEntityJSONRequestBody defines body for UpdateDomainEntity for application/json ContentType.
type UpdateDomainEntityJSONRequestBody UpdateDomainEntityJSONBody

// CreateClientScheduleJSONRequestBody defines body for CreateClientSchedule for application/json ContentType.
type CreateClientScheduleJSONRequestBody = ModelClientSchedule

// UpdateClientEventJSONRequestBody defines body for UpdateClientEvent for application/json ContentType.
type UpdateClientEventJSONRequestBody = ModelClientSchedule

// UploadFileToJobJSONRequestBody defines body for UploadFileToJob for application/json ContentType.
type UploadFileToJobJSONRequestBody = UploadFileToJobJSONBody

// RunCypherQueryJSONRequestBody defines body for RunCypherQuery for application/json ContentType.
type RunCypherQueryJSONRequestBody RunCypherQueryJSONBody

// StartClientJobJSONRequestBody defines body for StartClientJob for application/json ContentType.
type StartClientJobJSONRequestBody StartClientJobJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreateSamlProviderMultipartRequestBody defines body for CreateSamlProvider for multipart/form-data ContentType.
type CreateSamlProviderMultipartRequestBody CreateSamlProviderMultipartBody

// CreateSavedQueryJSONRequestBody defines body for CreateSavedQuery for application/json ContentType.
type CreateSavedQueryJSONRequestBody = ModelSavedQuery

// UpdateSavedQueryJSONRequestBody defines body for UpdateSavedQuery for application/json ContentType.
type UpdateSavedQueryJSONRequestBody = ModelSavedQuery

// DeleteSavedQueryPermissionsJSONRequestBody defines body for DeleteSavedQueryPermissions for application/json ContentType.
type DeleteSavedQueryPermissionsJSONRequestBody DeleteSavedQueryPermissionsJSONBody

// CreateAuthTokenJSONRequestBody defines body for CreateAuthToken for application/json ContentType.
type CreateAuthTokenJSONRequestBody CreateAuthTokenJSONBody

// Getter for additional properties for ApiResponseRelatedEntityQueryResultsGraphResponse. Returns the specified
// element and whether it was found
func (a ApiResponseRelatedEntityQueryResultsGraphResponse) Get(fieldName string) (value ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ApiResponseRelatedEntityQueryResultsGraphResponse
func (a *ApiResponseRelatedEntityQueryResultsGraphResponse) Set(fieldName string, value ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ApiResponseRelatedEntityQueryResultsGraphResponse to handle AdditionalProperties
func (a *ApiResponseRelatedEntityQueryResultsGraphResponse) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties)
		for fieldName, fieldBuf := range object {
			var fieldVal ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ApiResponseRelatedEntityQueryResultsGraphResponse to handle AdditionalProperties
func (a ApiResponseRelatedEntityQueryResultsGraphResponse) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsModelUser returns the union data inside the ApiResponseAuthenticatedRequester_Data as a ModelUser
func (t ApiResponseAuthenticatedRequester_Data) AsModelUser() (ModelUser, error) {
	var body ModelUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelUser overwrites any union data inside the ApiResponseAuthenticatedRequester_Data as the provided ModelUser
func (t *ApiResponseAuthenticatedRequester_Data) FromModelUser(v ModelUser) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelUser performs a merge with any union data inside the ApiResponseAuthenticatedRequester_Data, using the provided ModelUser
func (t *ApiResponseAuthenticatedRequester_Data) MergeModelUser(v ModelUser) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelClient returns the union data inside the ApiResponseAuthenticatedRequester_Data as a ModelClient
func (t ApiResponseAuthenticatedRequester_Data) AsModelClient() (ModelClient, error) {
	var body ModelClient
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelClient overwrites any union data inside the ApiResponseAuthenticatedRequester_Data as the provided ModelClient
func (t *ApiResponseAuthenticatedRequester_Data) FromModelClient(v ModelClient) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelClient performs a merge with any union data inside the ApiResponseAuthenticatedRequester_Data, using the provided ModelClient
func (t *ApiResponseAuthenticatedRequester_Data) MergeModelClient(v ModelClient) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseAuthenticatedRequester_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseAuthenticatedRequester_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelAdDataQualityAggregation returns the union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item as a ModelAdDataQualityAggregation
func (t ApiResponseDataQualityPlatformAggregate_Data_Data_Item) AsModelAdDataQualityAggregation() (ModelAdDataQualityAggregation, error) {
	var body ModelAdDataQualityAggregation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelAdDataQualityAggregation overwrites any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item as the provided ModelAdDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) FromModelAdDataQualityAggregation(v ModelAdDataQualityAggregation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelAdDataQualityAggregation performs a merge with any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item, using the provided ModelAdDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) MergeModelAdDataQualityAggregation(v ModelAdDataQualityAggregation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelAzureDataQualityAggregation returns the union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item as a ModelAzureDataQualityAggregation
func (t ApiResponseDataQualityPlatformAggregate_Data_Data_Item) AsModelAzureDataQualityAggregation() (ModelAzureDataQualityAggregation, error) {
	var body ModelAzureDataQualityAggregation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelAzureDataQualityAggregation overwrites any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item as the provided ModelAzureDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) FromModelAzureDataQualityAggregation(v ModelAzureDataQualityAggregation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelAzureDataQualityAggregation performs a merge with any union data inside the ApiResponseDataQualityPlatformAggregate_Data_Data_Item, using the provided ModelAzureDataQualityAggregation
func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) MergeModelAzureDataQualityAggregation(v ModelAzureDataQualityAggregation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseDataQualityPlatformAggregate_Data_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseDataQualityPlatformAggregate_Data_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelListFinding returns the union data inside the ApiResponseFinding_Data as a ModelListFinding
func (t ApiResponseFinding_Data) AsModelListFinding() (ModelListFinding, error) {
	var body ModelListFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelListFinding overwrites any union data inside the ApiResponseFinding_Data as the provided ModelListFinding
func (t *ApiResponseFinding_Data) FromModelListFinding(v ModelListFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelListFinding performs a merge with any union data inside the ApiResponseFinding_Data, using the provided ModelListFinding
func (t *ApiResponseFinding_Data) MergeModelListFinding(v ModelListFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelRelationshipFinding returns the union data inside the ApiResponseFinding_Data as a ModelRelationshipFinding
func (t ApiResponseFinding_Data) AsModelRelationshipFinding() (ModelRelationshipFinding, error) {
	var body ModelRelationshipFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelRelationshipFinding overwrites any union data inside the ApiResponseFinding_Data as the provided ModelRelationshipFinding
func (t *ApiResponseFinding_Data) FromModelRelationshipFinding(v ModelRelationshipFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelRelationshipFinding performs a merge with any union data inside the ApiResponseFinding_Data, using the provided ModelRelationshipFinding
func (t *ApiResponseFinding_Data) MergeModelRelationshipFinding(v ModelRelationshipFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseFinding_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseFinding_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelBhGraphNode returns the union data inside the ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties as a ModelBhGraphNode
func (t ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) AsModelBhGraphNode() (ModelBhGraphNode, error) {
	var body ModelBhGraphNode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelBhGraphNode overwrites any union data inside the ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties as the provided ModelBhGraphNode
func (t *ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) FromModelBhGraphNode(v ModelBhGraphNode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelBhGraphNode performs a merge with any union data inside the ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties, using the provided ModelBhGraphNode
func (t *ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) MergeModelBhGraphNode(v ModelBhGraphNode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelBhGraphEdge returns the union data inside the ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties as a ModelBhGraphEdge
func (t ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) AsModelBhGraphEdge() (ModelBhGraphEdge, error) {
	var body ModelBhGraphEdge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelBhGraphEdge overwrites any union data inside the ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties as the provided ModelBhGraphEdge
func (t *ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) FromModelBhGraphEdge(v ModelBhGraphEdge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelBhGraphEdge performs a merge with any union data inside the ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties, using the provided ModelBhGraphEdge
func (t *ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) MergeModelBhGraphEdge(v ModelBhGraphEdge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApiResponseRelatedEntityQueryResultsGraphResponse_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelBhGraphNode returns the union data inside the ModelBhGraphGraph_AdditionalProperties as a ModelBhGraphNode
func (t ModelBhGraphGraph_AdditionalProperties) AsModelBhGraphNode() (ModelBhGraphNode, error) {
	var body ModelBhGraphNode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelBhGraphNode overwrites any union data inside the ModelBhGraphGraph_AdditionalProperties as the provided ModelBhGraphNode
func (t *ModelBhGraphGraph_AdditionalProperties) FromModelBhGraphNode(v ModelBhGraphNode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelBhGraphNode performs a merge with any union data inside the ModelBhGraphGraph_AdditionalProperties, using the provided ModelBhGraphNode
func (t *ModelBhGraphGraph_AdditionalProperties) MergeModelBhGraphNode(v ModelBhGraphNode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelBhGraphEdge returns the union data inside the ModelBhGraphGraph_AdditionalProperties as a ModelBhGraphEdge
func (t ModelBhGraphGraph_AdditionalProperties) AsModelBhGraphEdge() (ModelBhGraphEdge, error) {
	var body ModelBhGraphEdge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelBhGraphEdge overwrites any union data inside the ModelBhGraphGraph_AdditionalProperties as the provided ModelBhGraphEdge
func (t *ModelBhGraphGraph_AdditionalProperties) FromModelBhGraphEdge(v ModelBhGraphEdge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelBhGraphEdge performs a merge with any union data inside the ModelBhGraphGraph_AdditionalProperties, using the provided ModelBhGraphEdge
func (t *ModelBhGraphGraph_AdditionalProperties) MergeModelBhGraphEdge(v ModelBhGraphEdge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModelBhGraphGraph_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModelBhGraphGraph_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsApiResponseRelatedEntityQueryResultsGraphResponse returns the union data inside the RelatedEntityQueryResults as a ApiResponseRelatedEntityQueryResultsGraphResponse
func (t RelatedEntityQueryResults) AsApiResponseRelatedEntityQueryResultsGraphResponse() (ApiResponseRelatedEntityQueryResultsGraphResponse, error) {
	var body ApiResponseRelatedEntityQueryResultsGraphResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiResponseRelatedEntityQueryResultsGraphResponse overwrites any union data inside the RelatedEntityQueryResults as the provided ApiResponseRelatedEntityQueryResultsGraphResponse
func (t *RelatedEntityQueryResults) FromApiResponseRelatedEntityQueryResultsGraphResponse(v ApiResponseRelatedEntityQueryResultsGraphResponse) error {
	v.Type = "graph-response"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiResponseRelatedEntityQueryResultsGraphResponse performs a merge with any union data inside the RelatedEntityQueryResults, using the provided ApiResponseRelatedEntityQueryResultsGraphResponse
func (t *RelatedEntityQueryResults) MergeApiResponseRelatedEntityQueryResultsGraphResponse(v ApiResponseRelatedEntityQueryResultsGraphResponse) error {
	v.Type = "graph-response"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsApiResponseRelatedEntityQueryResultsCountResponse returns the union data inside the RelatedEntityQueryResults as a ApiResponseRelatedEntityQueryResultsCountResponse
func (t RelatedEntityQueryResults) AsApiResponseRelatedEntityQueryResultsCountResponse() (ApiResponseRelatedEntityQueryResultsCountResponse, error) {
	var body ApiResponseRelatedEntityQueryResultsCountResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromApiResponseRelatedEntityQueryResultsCountResponse overwrites any union data inside the RelatedEntityQueryResults as the provided ApiResponseRelatedEntityQueryResultsCountResponse
func (t *RelatedEntityQueryResults) FromApiResponseRelatedEntityQueryResultsCountResponse(v ApiResponseRelatedEntityQueryResultsCountResponse) error {
	v.Type = "count-response"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeApiResponseRelatedEntityQueryResultsCountResponse performs a merge with any union data inside the RelatedEntityQueryResults, using the provided ApiResponseRelatedEntityQueryResultsCountResponse
func (t *RelatedEntityQueryResults) MergeApiResponseRelatedEntityQueryResultsCountResponse(v ApiResponseRelatedEntityQueryResultsCountResponse) error {
	v.Type = "count-response"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RelatedEntityQueryResults) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RelatedEntityQueryResults) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "count-response":
		return t.AsApiResponseRelatedEntityQueryResultsCountResponse()
	case "graph-response":
		return t.AsApiResponseRelatedEntityQueryResultsGraphResponse()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RelatedEntityQueryResults) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RelatedEntityQueryResults) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AcceptEula request
	AcceptEula(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdDomainDataQualityStats request
	GetAdDomainDataQualityStats(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiaCaEntity request
	GetAiaCaEntity(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAiaCaEntityControllers request
	GetAiaCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartAnalysis request
	StartAnalysis(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroups request
	ListAssetGroups(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssetGroupWithBody request with any body
	CreateAssetGroupWithBody(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAssetGroup(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetGroup request
	DeleteAssetGroup(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroup request
	GetAssetGroup(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupWithBody request with any body
	UpdateAssetGroupWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroup(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupCollections request
	ListAssetGroupCollections(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroupComboNode request
	GetAssetGroupComboNode(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetGroupCustomMemberCount request
	GetAssetGroupCustomMemberCount(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupMembers request
	ListAssetGroupMembers(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetGroupMemberCountByKind request
	ListAssetGroupMemberCountByKind(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupSelectorsDeprecatedWithBody request with any body
	UpdateAssetGroupSelectorsDeprecatedWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroupSelectorsDeprecated(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetGroupSelectorsWithBody request with any body
	UpdateAssetGroupSelectorsWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetGroupSelectors(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetGroupSelector request
	DeleteAssetGroupSelector(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttackPathTypes request
	ListAttackPathTypes(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartAnalysisBhe request
	StartAnalysisBhe(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAttackPathRiskWithBody request with any body
	UpdateAttackPathRiskWithBody(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAttackPathRisk(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableDomains request
	GetAvailableDomains(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAzureTenantDataQualityStats request
	GetAzureTenantDataQualityStats(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAzureEntity request
	GetAzureEntity(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntity request
	GetEntity(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntityControllables request
	GetEntityControllables(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntityControllers request
	GetEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserMfaWithBody request with any body
	RemoveUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveUserMfa(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserMfaWithBody request with any body
	AddUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserMfa(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMfaActivationStatus request
	GetMfaActivationStatus(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateUserMfaWithBody request with any body
	ActivateUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateUserMfa(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserSecret request
	DeleteUserSecret(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrSetUserSecretWithBody request with any body
	CreateOrSetUserSecretWithBody(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrSetUserSecret(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertTemplateEntity request
	GetCertTemplateEntity(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertTemplateEntityControllers request
	GetCertTemplateEntityControllers(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBloodHoundDatabaseWithBody request with any body
	DeleteBloodHoundDatabaseWithBody(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteBloodHoundDatabase(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClients request
	ListClients(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientWithBody request with any body
	CreateClientWithBody(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClient(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogClientErrorWithBody request with any body
	LogClientErrorWithBody(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogClientError(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientInfoWithBody request with any body
	UpdateClientInfoWithBody(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClientInfo(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClient request
	DeleteClient(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClient request
	GetClient(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientWithBody request with any body
	UpdateClientWithBody(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClient(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientCompletedJobs request
	ListClientCompletedJobs(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientCompletedTasks request
	ListClientCompletedTasks(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduledJobWithBody request with any body
	CreateClientScheduledJobWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientScheduledJob(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduledTaskWithBody request with any body
	CreateClientScheduledTaskWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientScheduledTask(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceClientToken request
	ReplaceClientToken(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorManifest request
	GetCollectorManifest(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadCollector request
	DownloadCollector(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorChecksum request
	GetCollectorChecksum(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletenessStats request
	GetCompletenessStats(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntity request
	GetComputerEntity(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityAdminRights request
	GetComputerEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityAdmins request
	GetComputerEntityAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityConstrainedDelegationRights request
	GetComputerEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityConstrainedUsers request
	GetComputerEntityConstrainedUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityControllables request
	GetComputerEntityControllables(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityControllers request
	GetComputerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityDcomRights request
	GetComputerEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityDcomUsers request
	GetComputerEntityDcomUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityGroupMembership request
	GetComputerEntityGroupMembership(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityPsRemoteRights request
	GetComputerEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityPsRemoteUsers request
	GetComputerEntityPsRemoteUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityRdpRights request
	GetComputerEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntityRdpUsers request
	GetComputerEntityRdpUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntitySessions request
	GetComputerEntitySessions(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComputerEntitySqlAdmins request
	GetComputerEntitySqlAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppConfigParams request
	ListAppConfigParams(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAppConfigParamWithBody request with any body
	SetAppConfigParamWithBody(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAppConfigParam(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerEntity request
	GetContainerEntity(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerEntityControllers request
	GetContainerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatapipeStatus request
	GetDatapipeStatus(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportAttackPathFindings request
	ExportAttackPathFindings(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableAttackPathTypesForDomain request
	ListAvailableAttackPathTypesForDomain(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDomainAttackPathsDetails request
	ListDomainAttackPathsDetails(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAttackPathSparklineValues request
	ListAttackPathSparklineValues(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntity request
	GetDomainEntity(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDomainEntityWithBody request with any body
	UpdateDomainEntityWithBody(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDomainEntity(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityComputers request
	GetDomainEntityComputers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityControllers request
	GetDomainEntityControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityDcSyncers request
	GetDomainEntityDcSyncers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignAdmins request
	GetDomainEntityForeignAdmins(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignGpoControllers request
	GetDomainEntityForeignGpoControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignGroups request
	GetDomainEntityForeignGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityForeignUsers request
	GetDomainEntityForeignUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityGpos request
	GetDomainEntityGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityGroups request
	GetDomainEntityGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityInboundTrusts request
	GetDomainEntityInboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityLinkedGpos request
	GetDomainEntityLinkedGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityOus request
	GetDomainEntityOus(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityOutboundTrusts request
	GetDomainEntityOutboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomainEntityUsers request
	GetDomainEntityUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnterpriseCaEntity request
	GetEnterpriseCaEntity(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnterpriseCaEntityControllers request
	GetEnterpriseCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientSchedules request
	ListClientSchedules(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientScheduleWithBody request with any body
	CreateClientScheduleWithBody(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientSchedule(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientEvent request
	DeleteClientEvent(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientSchedule request
	GetClientSchedule(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientEventWithBody request with any body
	UpdateClientEventWithBody(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClientEvent(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFeatureFlags request
	ListFeatureFlags(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleFeatureFlag request
	ToggleFeatureFlag(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFileUploadJobs request
	ListFileUploadJobs(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAcceptedFileUploadTypes request
	ListAcceptedFileUploadTypes(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFileUploadJob request
	CreateFileUploadJob(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFileToJobWithBody request with any body
	UploadFileToJobWithBody(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadFileToJob(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndFileUploadJob request
	EndFileUploadJob(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntity request
	GetGpoEntity(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityComputers request
	GetGpoEntityComputers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityControllers request
	GetGpoEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityOus request
	GetGpoEntityOus(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityTierZero request
	GetGpoEntityTierZero(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGpoEntityUsers request
	GetGpoEntityUsers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResult request
	GetSearchResult(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunCypherQueryWithBody request with any body
	RunCypherQueryWithBody(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunCypherQuery(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPathComposition request
	GetPathComposition(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShortestPath request
	GetShortestPath(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntity request
	GetGroupEntity(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityAdminRights request
	GetGroupEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityControllables request
	GetGroupEntityControllables(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityControllers request
	GetGroupEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityDcomRights request
	GetGroupEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityMembers request
	GetGroupEntityMembers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityMemberships request
	GetGroupEntityMemberships(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityPsRemoteRights request
	GetGroupEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntityRdpRights request
	GetGroupEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupEntitySessions request
	GetGroupEntitySessions(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IngestData request
	IngestData(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJobs request
	GetClientJobs(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAvailableClientJobs request
	ListAvailableClientJobs(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientCurrentJob request
	GetClientCurrentJob(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndClientJob request
	EndClientJob(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientFinishedJobs request
	ListClientFinishedJobs(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartClientJobWithBody request with any body
	StartClientJobWithBody(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartClientJob(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJob request
	GetClientJob(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelClientJob request
	CancelClientJob(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientJobLog request
	GetClientJobLog(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestTierZeroComboNode request
	GetLatestTierZeroComboNode(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComboTreeGraph request
	GetComboTreeGraph(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetaEntity request
	GetMetaEntity(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNtAuthStoreEntity request
	GetNtAuthStoreEntity(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNtAuthStoreEntityControllers request
	GetNtAuthStoreEntityControllers(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntity request
	GetOuEntity(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityComputers request
	GetOuEntityComputers(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityGpos request
	GetOuEntityGpos(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityGroups request
	GetOuEntityGroups(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOuEntityUsers request
	GetOuEntityUsers(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pathfinding request
	Pathfinding(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissions request
	ListPermissions(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermission request
	GetPermission(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformDataQualityAggregate request
	GetPlatformDataQualityAggregate(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostureStats request
	GetPostureStats(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootCaEntity request
	GetRootCaEntity(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootCaEntityControllers request
	GetRootCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSamlProviders request
	ListSamlProviders(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSamlProviderWithBody request with any body
	CreateSamlProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSamlProvider request
	DeleteSamlProvider(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlProvider request
	GetSamlProvider(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlSignSignOnEndpoints request
	GetSamlSignSignOnEndpoints(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSavedQueries request
	ListSavedQueries(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSavedQueryWithBody request with any body
	CreateSavedQueryWithBody(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSavedQuery(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSavedQuery request
	DeleteSavedQuery(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSavedQueryWithBody request with any body
	UpdateSavedQueryWithBody(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSavedQuery(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSavedQueryPermissionsWithBody request with any body
	DeleteSavedQueryPermissionsWithBody(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSavedQueryPermissions(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelf request
	GetSelf(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiSpec request
	GetApiSpec(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuthTokens request
	ListAuthTokens(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthTokenWithBody request with any body
	CreateAuthTokenWithBody(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuthToken(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthToken request
	DeleteAuthToken(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntity request
	GetUserEntity(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityAdminRights request
	GetUserEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityConstrainedDelegationRights request
	GetUserEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityControllables request
	GetUserEntityControllables(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityControllers request
	GetUserEntityControllers(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityDcomRights request
	GetUserEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityMembership request
	GetUserEntityMembership(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityPsRemoteRights request
	GetUserEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntityRdpRights request
	GetUserEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntitySessions request
	GetUserEntitySessions(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEntitySqlAdminRights request
	GetUserEntitySqlAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiVersion request
	GetApiVersion(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AcceptEula(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptEulaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdDomainDataQualityStats(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdDomainDataQualityStatsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiaCaEntity(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiaCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAiaCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAiaCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartAnalysis(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartAnalysisRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroups(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssetGroupWithBody(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssetGroup(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetGroup(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetGroupRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroup(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroup(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupCollections(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupCollectionsRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroupComboNode(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupComboNodeRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetGroupCustomMemberCount(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetGroupCustomMemberCountRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupMembers(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupMembersRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetGroupMemberCountByKind(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetGroupMemberCountByKindRequest(c.Server, assetGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsDeprecatedWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsDeprecated(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsDeprecatedRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectorsWithBody(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsRequestWithBody(c.Server, assetGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetGroupSelectors(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetGroupSelectorsRequest(c.Server, assetGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetGroupSelector(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetGroupSelectorRequest(c.Server, assetGroupId, assetGroupSelectorId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttackPathTypes(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttackPathTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartAnalysisBhe(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartAnalysisBheRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttackPathRiskWithBody(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttackPathRiskRequestWithBody(c.Server, attackPathId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAttackPathRisk(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAttackPathRiskRequest(c.Server, attackPathId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableDomains(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAzureTenantDataQualityStats(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAzureTenantDataQualityStatsRequest(c.Server, tenantId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAzureEntity(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAzureEntityRequest(c.Server, entityType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntity(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntityControllables(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserMfa(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserMfa(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMfaActivationStatus(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMfaActivationStatusRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateUserMfaWithBody(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateUserMfaRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateUserMfa(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateUserMfaRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserSecret(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserSecretRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrSetUserSecretWithBody(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrSetUserSecretRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrSetUserSecret(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrSetUserSecretRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertTemplateEntity(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertTemplateEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertTemplateEntityControllers(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertTemplateEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBloodHoundDatabaseWithBody(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBloodHoundDatabaseRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBloodHoundDatabase(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBloodHoundDatabaseRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClients(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientWithBody(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClient(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogClientErrorWithBody(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogClientErrorRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogClientError(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogClientErrorRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientInfoWithBody(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientInfoRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientInfo(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientInfoRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClient(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClient(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientWithBody(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClient(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientCompletedJobs(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientCompletedJobsRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientCompletedTasks(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientCompletedTasksRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledJobWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledJobRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledJob(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledJobRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledTaskWithBody(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledTaskRequestWithBody(c.Server, clientId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduledTask(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduledTaskRequest(c.Server, clientId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceClientToken(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceClientTokenRequest(c.Server, clientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorManifest(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorManifestRequest(c.Server, collectorType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadCollector(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadCollectorRequest(c.Server, collectorType, releaseTag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorChecksum(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorChecksumRequest(c.Server, collectorType, releaseTag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletenessStats(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletenessStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntity(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityConstrainedDelegationRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityConstrainedUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityConstrainedUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityControllables(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityDcomUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityDcomUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityGroupMembership(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityGroupMembershipRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityPsRemoteUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityPsRemoteUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntityRdpUsers(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntityRdpUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntitySessions(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComputerEntitySqlAdmins(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComputerEntitySqlAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppConfigParams(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppConfigParamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppConfigParamWithBody(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppConfigParamRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppConfigParam(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppConfigParamRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerEntity(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerEntityControllers(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatapipeStatus(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatapipeStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAttackPathFindings(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAttackPathFindingsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableAttackPathTypesForDomain(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableAttackPathTypesForDomainRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDomainAttackPathsDetails(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDomainAttackPathsDetailsRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAttackPathSparklineValues(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAttackPathSparklineValuesRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntity(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainEntityWithBody(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainEntityRequestWithBody(c.Server, objectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainEntity(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainEntityRequest(c.Server, objectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityComputers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityDcSyncers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityDcSyncersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignAdmins(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignAdminsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignGpoControllers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignGpoControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityForeignUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityForeignUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityGroups(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityInboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityInboundTrustsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityLinkedGpos(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityLinkedGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityOus(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityOusRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityOutboundTrusts(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityOutboundTrustsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomainEntityUsers(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnterpriseCaEntity(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnterpriseCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnterpriseCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnterpriseCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientSchedules(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientScheduleWithBody(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientSchedule(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientScheduleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientEvent(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientEventRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientSchedule(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientScheduleRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientEventWithBody(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientEventRequestWithBody(c.Server, eventId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientEvent(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientEventRequest(c.Server, eventId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFeatureFlags(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFeatureFlagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleFeatureFlag(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleFeatureFlagRequest(c.Server, featureId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFileUploadJobs(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFileUploadJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAcceptedFileUploadTypes(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAcceptedFileUploadTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFileUploadJob(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFileUploadJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileToJobWithBody(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileToJobRequestWithBody(c.Server, fileUploadJobId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFileToJob(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFileToJobRequest(c.Server, fileUploadJobId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndFileUploadJob(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndFileUploadJobRequest(c.Server, fileUploadJobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntity(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityComputers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityOus(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityOusRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityTierZero(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityTierZeroRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGpoEntityUsers(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGpoEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResult(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunCypherQueryWithBody(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunCypherQueryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunCypherQuery(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunCypherQueryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPathComposition(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPathCompositionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShortestPath(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShortestPathRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntity(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityControllables(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityControllers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityMembers(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityMembersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityMemberships(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityMembershipsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupEntitySessions(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestData(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJobs(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAvailableClientJobs(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableClientJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientCurrentJob(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientCurrentJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndClientJob(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndClientJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientFinishedJobs(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientFinishedJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartClientJobWithBody(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartClientJobRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartClientJob(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartClientJobRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJob(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelClientJob(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelClientJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientJobLog(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientJobLogRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestTierZeroComboNode(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestTierZeroComboNodeRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComboTreeGraph(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComboTreeGraphRequest(c.Server, domainId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetaEntity(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNtAuthStoreEntity(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNtAuthStoreEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNtAuthStoreEntityControllers(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNtAuthStoreEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntity(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityComputers(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityComputersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityGpos(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityGposRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityGroups(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityGroupsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOuEntityUsers(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOuEntityUsersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pathfinding(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPathfindingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissions(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermission(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionRequest(c.Server, permissionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformDataQualityAggregate(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformDataQualityAggregateRequest(c.Server, platformId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostureStats(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostureStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, roleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootCaEntity(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootCaEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootCaEntityControllers(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootCaEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSamlProviders(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSamlProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSamlProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSamlProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSamlProvider(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSamlProviderRequest(c.Server, samlProviderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlProvider(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlProviderRequest(c.Server, samlProviderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlSignSignOnEndpoints(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlSignSignOnEndpointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSavedQueries(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSavedQueriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSavedQueryWithBody(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSavedQueryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSavedQuery(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSavedQueryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQuery(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryRequest(c.Server, savedQueryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSavedQueryWithBody(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSavedQueryRequestWithBody(c.Server, savedQueryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSavedQuery(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSavedQueryRequest(c.Server, savedQueryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQueryPermissionsWithBody(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryPermissionsRequestWithBody(c.Server, savedQueryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQueryPermissions(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryPermissionsRequest(c.Server, savedQueryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelf(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelfRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiSpec(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiSpecRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuthTokens(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuthTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthTokenWithBody(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthToken(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthToken(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthTokenRequest(c.Server, tokenId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntity(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityConstrainedDelegationRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityConstrainedDelegationRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityControllables(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityControllablesRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityControllers(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityControllersRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityDcomRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityDcomRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityMembership(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityMembershipRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityPsRemoteRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityPsRemoteRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntityRdpRights(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntityRdpRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntitySessions(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntitySessionsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEntitySqlAdminRights(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEntitySqlAdminRightsRequest(c.Server, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiVersion(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAcceptEulaRequest generates requests for AcceptEula
func NewAcceptEulaRequest(server string, params *AcceptEulaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/accept-eula")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAdDomainDataQualityStatsRequest generates requests for GetAdDomainDataQualityStats
func NewGetAdDomainDataQualityStatsRequest(server string, domainId string, params *GetAdDomainDataQualityStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ad-domains/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAiaCaEntityRequest generates requests for GetAiaCaEntity
func NewGetAiaCaEntityRequest(server string, objectId PathObjectId, params *GetAiaCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/aiacas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAiaCaEntityControllersRequest generates requests for GetAiaCaEntityControllers
func NewGetAiaCaEntityControllersRequest(server string, objectId PathObjectId, params *GetAiaCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/aiacas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartAnalysisRequest generates requests for StartAnalysis
func NewStartAnalysisRequest(server string, params *StartAnalysisParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/analysis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupsRequest generates requests for ListAssetGroups
func NewListAssetGroupsRequest(server string, params *ListAssetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SystemGroup != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "system_group", runtime.ParamLocationQuery, *params.SystemGroup); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "member_count", runtime.ParamLocationQuery, *params.MemberCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAssetGroupRequest calls the generic CreateAssetGroup builder with application/json body
func NewCreateAssetGroupRequest(server string, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAssetGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAssetGroupRequestWithBody generates requests for CreateAssetGroup with any type of body
func NewCreateAssetGroupRequestWithBody(server string, params *CreateAssetGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAssetGroupRequest generates requests for DeleteAssetGroup
func NewDeleteAssetGroupRequest(server string, assetGroupId int32, params *DeleteAssetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupRequest generates requests for GetAssetGroup
func NewGetAssetGroupRequest(server string, assetGroupId int32, params *GetAssetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupRequest calls the generic UpdateAssetGroup builder with application/json body
func NewUpdateAssetGroupRequest(server string, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupRequestWithBody generates requests for UpdateAssetGroup with any type of body
func NewUpdateAssetGroupRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupCollectionsRequest generates requests for ListAssetGroupCollections
func NewListAssetGroupCollectionsRequest(server string, assetGroupId int32, params *ListAssetGroupCollectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/collections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupComboNodeRequest generates requests for GetAssetGroupComboNode
func NewGetAssetGroupComboNodeRequest(server string, assetGroupId int32, params *GetAssetGroupComboNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/combo-node", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Domainsid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainsid", runtime.ParamLocationQuery, *params.Domainsid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAssetGroupCustomMemberCountRequest generates requests for GetAssetGroupCustomMemberCount
func NewGetAssetGroupCustomMemberCountRequest(server string, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/custom-selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupMembersRequest generates requests for ListAssetGroupMembers
func NewListAssetGroupMembersRequest(server string, assetGroupId int32, params *ListAssetGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, *params.ObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_kind", runtime.ParamLocationQuery, *params.PrimaryKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_id", runtime.ParamLocationQuery, *params.EnvironmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_kind", runtime.ParamLocationQuery, *params.EnvironmentKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_member", runtime.ParamLocationQuery, *params.CustomMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAssetGroupMemberCountByKindRequest generates requests for ListAssetGroupMemberCountByKind
func NewListAssetGroupMemberCountByKindRequest(server string, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/members/counts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, *params.ObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_id", runtime.ParamLocationQuery, *params.EnvironmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrimaryKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "primary_kind", runtime.ParamLocationQuery, *params.PrimaryKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment_kind", runtime.ParamLocationQuery, *params.EnvironmentKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomMember != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_member", runtime.ParamLocationQuery, *params.CustomMember); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupSelectorsDeprecatedRequest calls the generic UpdateAssetGroupSelectorsDeprecated builder with application/json body
func NewUpdateAssetGroupSelectorsDeprecatedRequest(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody generates requests for UpdateAssetGroupSelectorsDeprecated with any type of body
func NewUpdateAssetGroupSelectorsDeprecatedRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAssetGroupSelectorsRequest calls the generic UpdateAssetGroupSelectors builder with application/json body
func NewUpdateAssetGroupSelectorsRequest(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetGroupSelectorsRequestWithBody(server, assetGroupId, params, "application/json", bodyReader)
}

// NewUpdateAssetGroupSelectorsRequestWithBody generates requests for UpdateAssetGroupSelectors with any type of body
func NewUpdateAssetGroupSelectorsRequestWithBody(server string, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAssetGroupSelectorRequest generates requests for DeleteAssetGroupSelector
func NewDeleteAssetGroupSelectorRequest(server string, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_group_id", runtime.ParamLocationPath, assetGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "asset_group_selector_id", runtime.ParamLocationPath, assetGroupSelectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/asset-groups/%s/selectors/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAttackPathTypesRequest generates requests for ListAttackPathTypes
func NewListAttackPathTypesRequest(server string, params *ListAttackPathTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-path-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartAnalysisBheRequest generates requests for StartAnalysisBhe
func NewStartAnalysisBheRequest(server string, params *StartAnalysisBheParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-paths")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateAttackPathRiskRequest calls the generic UpdateAttackPathRisk builder with application/json body
func NewUpdateAttackPathRiskRequest(server string, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAttackPathRiskRequestWithBody(server, attackPathId, params, "application/json", bodyReader)
}

// NewUpdateAttackPathRiskRequestWithBody generates requests for UpdateAttackPathRisk with any type of body
func NewUpdateAttackPathRiskRequestWithBody(server string, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "attack_path_id", runtime.ParamLocationPath, attackPathId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/attack-paths/%s/acceptance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/audit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_id", runtime.ParamLocationQuery, *params.ActorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_name", runtime.ParamLocationQuery, *params.ActorName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_email", runtime.ParamLocationQuery, *params.ActorEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "request_id", runtime.ParamLocationQuery, *params.RequestId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAvailableDomainsRequest generates requests for GetAvailableDomains
func NewGetAvailableDomainsRequest(server string, params *GetAvailableDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/available-domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Objectid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objectid", runtime.ParamLocationQuery, *params.Objectid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Collected != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collected", runtime.ParamLocationQuery, *params.Collected); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAzureTenantDataQualityStatsRequest generates requests for GetAzureTenantDataQualityStats
func NewGetAzureTenantDataQualityStatsRequest(server string, tenantId string, params *GetAzureTenantDataQualityStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant_id", runtime.ParamLocationPath, tenantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/azure-tenants/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetAzureEntityRequest generates requests for GetAzureEntity
func NewGetAzureEntityRequest(server string, entityType string, params *GetAzureEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity_type", runtime.ParamLocationPath, entityType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/azure/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, params.ObjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelatedEntityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "related_entity_type", runtime.ParamLocationQuery, *params.RelatedEntityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityRequest generates requests for GetEntity
func NewGetEntityRequest(server string, objectId PathObjectId, params *GetEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityControllablesRequest generates requests for GetEntityControllables
func NewGetEntityControllablesRequest(server string, objectId PathObjectId, params *GetEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEntityControllersRequest generates requests for GetEntityControllers
func NewGetEntityControllersRequest(server string, objectId PathObjectId, params *GetEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/base/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_name", runtime.ParamLocationQuery, *params.FirstName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_name", runtime.ParamLocationQuery, *params.LastName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email_address", runtime.ParamLocationQuery, *params.EmailAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrincipalName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principal_name", runtime.ParamLocationQuery, *params.PrincipalName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastLogin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_login", runtime.ParamLocationQuery, *params.LastLogin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId openapi_types.UUID, params *DeleteUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId openapi_types.UUID, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewRemoveUserMfaRequest calls the generic RemoveUserMfa builder with application/json body
func NewRemoveUserMfaRequest(server string, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewRemoveUserMfaRequestWithBody generates requests for RemoveUserMfa with any type of body
func NewRemoveUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewAddUserMfaRequest calls the generic AddUserMfa builder with application/json body
func NewAddUserMfaRequest(server string, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewAddUserMfaRequestWithBody generates requests for AddUserMfa with any type of body
func NewAddUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetMfaActivationStatusRequest generates requests for GetMfaActivationStatus
func NewGetMfaActivationStatusRequest(server string, userId openapi_types.UUID, params *GetMfaActivationStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa-activation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewActivateUserMfaRequest calls the generic ActivateUserMfa builder with application/json body
func NewActivateUserMfaRequest(server string, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateUserMfaRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewActivateUserMfaRequestWithBody generates requests for ActivateUserMfa with any type of body
func NewActivateUserMfaRequestWithBody(server string, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/mfa-activation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteUserSecretRequest generates requests for DeleteUserSecret
func NewDeleteUserSecretRequest(server string, userId openapi_types.UUID, params *DeleteUserSecretParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateOrSetUserSecretRequest calls the generic CreateOrSetUserSecret builder with application/json body
func NewCreateOrSetUserSecretRequest(server string, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrSetUserSecretRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewCreateOrSetUserSecretRequestWithBody generates requests for CreateOrSetUserSecret with any type of body
func NewCreateOrSetUserSecretRequestWithBody(server string, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/bloodhound-users/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCertTemplateEntityRequest generates requests for GetCertTemplateEntity
func NewGetCertTemplateEntityRequest(server string, objectId PathObjectId, params *GetCertTemplateEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/certtemplates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCertTemplateEntityControllersRequest generates requests for GetCertTemplateEntityControllers
func NewGetCertTemplateEntityControllersRequest(server string, objectId PathObjectId, params *GetCertTemplateEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/certtemplates/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteBloodHoundDatabaseRequest calls the generic DeleteBloodHoundDatabase builder with application/json body
func NewDeleteBloodHoundDatabaseRequest(server string, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteBloodHoundDatabaseRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteBloodHoundDatabaseRequestWithBody generates requests for DeleteBloodHoundDatabase with any type of body
func NewDeleteBloodHoundDatabaseRequestWithBody(server string, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clear-database")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientsRequest generates requests for ListClients
func NewListClientsRequest(server string, params *ListClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip_address", runtime.ParamLocationQuery, *params.IpAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostname", runtime.ParamLocationQuery, *params.Hostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConfiguredUser != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configured_user", runtime.ParamLocationQuery, *params.ConfiguredUser); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_sid", runtime.ParamLocationQuery, *params.UserSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastCheckin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_checkin", runtime.ParamLocationQuery, *params.LastCheckin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentJobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current_job_id", runtime.ParamLocationQuery, *params.CurrentJobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedJobCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completed_job_count", runtime.ParamLocationQuery, *params.CompletedJobCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientRequest calls the generic CreateClient builder with application/json body
func NewCreateClientRequest(server string, params *CreateClientParams, body CreateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateClientRequestWithBody generates requests for CreateClient with any type of body
func NewCreateClientRequestWithBody(server string, params *CreateClientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLogClientErrorRequest calls the generic LogClientError builder with application/json body
func NewLogClientErrorRequest(server string, params *LogClientErrorParams, body LogClientErrorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLogClientErrorRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLogClientErrorRequestWithBody generates requests for LogClientError with any type of body
func NewLogClientErrorRequestWithBody(server string, params *LogClientErrorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/error")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientInfoRequest calls the generic UpdateClientInfo builder with application/json body
func NewUpdateClientInfoRequest(server string, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientInfoRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateClientInfoRequestWithBody generates requests for UpdateClientInfo with any type of body
func NewUpdateClientInfoRequestWithBody(server string, params *UpdateClientInfoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteClientRequest generates requests for DeleteClient
func NewDeleteClientRequest(server string, clientId openapi_types.UUID, params *DeleteClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientRequest generates requests for GetClient
func NewGetClientRequest(server string, clientId openapi_types.UUID, params *GetClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientRequest calls the generic UpdateClient builder with application/json body
func NewUpdateClientRequest(server string, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewUpdateClientRequestWithBody generates requests for UpdateClient with any type of body
func NewUpdateClientRequestWithBody(server string, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientCompletedJobsRequest generates requests for ListClientCompletedJobs
func NewListClientCompletedJobsRequest(server string, clientId openapi_types.UUID, params *ListClientCompletedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/completed-jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientCompletedTasksRequest generates requests for ListClientCompletedTasks
func NewListClientCompletedTasksRequest(server string, clientId openapi_types.UUID, params *ListClientCompletedTasksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/completed-tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduledJobRequest calls the generic CreateClientScheduledJob builder with application/json body
func NewCreateClientScheduledJobRequest(server string, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduledJobRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewCreateClientScheduledJobRequestWithBody generates requests for CreateClientScheduledJob with any type of body
func NewCreateClientScheduledJobRequestWithBody(server string, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/jobs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduledTaskRequest calls the generic CreateClientScheduledTask builder with application/json body
func NewCreateClientScheduledTaskRequest(server string, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduledTaskRequestWithBody(server, clientId, params, "application/json", bodyReader)
}

// NewCreateClientScheduledTaskRequestWithBody generates requests for CreateClientScheduledTask with any type of body
func NewCreateClientScheduledTaskRequestWithBody(server string, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewReplaceClientTokenRequest generates requests for ReplaceClientToken
func NewReplaceClientTokenRequest(server string, clientId openapi_types.UUID, params *ReplaceClientTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/clients/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCollectorManifestRequest generates requests for GetCollectorManifest
func NewGetCollectorManifestRequest(server string, collectorType EnumClientType, params *GetCollectorManifestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDownloadCollectorRequest generates requests for DownloadCollector
func NewDownloadCollectorRequest(server string, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "release_tag", runtime.ParamLocationPath, releaseTag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCollectorChecksumRequest generates requests for GetCollectorChecksum
func NewGetCollectorChecksumRequest(server string, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collector_type", runtime.ParamLocationPath, collectorType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "release_tag", runtime.ParamLocationPath, releaseTag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/collectors/%s/%s/checksum", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetCompletenessStatsRequest generates requests for GetCompletenessStats
func NewGetCompletenessStatsRequest(server string, params *GetCompletenessStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/completeness")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRequest generates requests for GetComputerEntity
func NewGetComputerEntityRequest(server string, objectId PathObjectId, params *GetComputerEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityAdminRightsRequest generates requests for GetComputerEntityAdminRights
func NewGetComputerEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityAdminsRequest generates requests for GetComputerEntityAdmins
func NewGetComputerEntityAdminsRequest(server string, objectId PathObjectId, params *GetComputerEntityAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/admin-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityConstrainedDelegationRightsRequest generates requests for GetComputerEntityConstrainedDelegationRights
func NewGetComputerEntityConstrainedDelegationRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/constrained-delegation-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityConstrainedUsersRequest generates requests for GetComputerEntityConstrainedUsers
func NewGetComputerEntityConstrainedUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/constrained-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityControllablesRequest generates requests for GetComputerEntityControllables
func NewGetComputerEntityControllablesRequest(server string, objectId PathObjectId, params *GetComputerEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityControllersRequest generates requests for GetComputerEntityControllers
func NewGetComputerEntityControllersRequest(server string, objectId PathObjectId, params *GetComputerEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityDcomRightsRequest generates requests for GetComputerEntityDcomRights
func NewGetComputerEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityDcomUsersRequest generates requests for GetComputerEntityDcomUsers
func NewGetComputerEntityDcomUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityDcomUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/dcom-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityGroupMembershipRequest generates requests for GetComputerEntityGroupMembership
func NewGetComputerEntityGroupMembershipRequest(server string, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/group-membership", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityPsRemoteRightsRequest generates requests for GetComputerEntityPsRemoteRights
func NewGetComputerEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityPsRemoteUsersRequest generates requests for GetComputerEntityPsRemoteUsers
func NewGetComputerEntityPsRemoteUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/ps-remote-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRdpRightsRequest generates requests for GetComputerEntityRdpRights
func NewGetComputerEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetComputerEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntityRdpUsersRequest generates requests for GetComputerEntityRdpUsers
func NewGetComputerEntityRdpUsersRequest(server string, objectId PathObjectId, params *GetComputerEntityRdpUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/rdp-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntitySessionsRequest generates requests for GetComputerEntitySessions
func NewGetComputerEntitySessionsRequest(server string, objectId PathObjectId, params *GetComputerEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComputerEntitySqlAdminsRequest generates requests for GetComputerEntitySqlAdmins
func NewGetComputerEntitySqlAdminsRequest(server string, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/computers/%s/sql-admins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAppConfigParamsRequest generates requests for ListAppConfigParams
func NewListAppConfigParamsRequest(server string, params *ListAppConfigParamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Parameter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parameter", runtime.ParamLocationQuery, *params.Parameter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewSetAppConfigParamRequest calls the generic SetAppConfigParam builder with application/json body
func NewSetAppConfigParamRequest(server string, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAppConfigParamRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSetAppConfigParamRequestWithBody generates requests for SetAppConfigParam with any type of body
func NewSetAppConfigParamRequestWithBody(server string, params *SetAppConfigParamParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetContainerEntityRequest generates requests for GetContainerEntity
func NewGetContainerEntityRequest(server string, objectId PathObjectId, params *GetContainerEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetContainerEntityControllersRequest generates requests for GetContainerEntityControllers
func NewGetContainerEntityControllersRequest(server string, objectId PathObjectId, params *GetContainerEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/containers/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDatapipeStatusRequest generates requests for GetDatapipeStatus
func NewGetDatapipeStatusRequest(server string, params *GetDatapipeStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/datapipe/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewExportAttackPathFindingsRequest generates requests for ExportAttackPathFindings
func NewExportAttackPathFindingsRequest(server string, domainId string, params *ExportAttackPathFindingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/attack-path-findings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FilterAccepted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterAccepted", runtime.ParamLocationQuery, *params.FilterAccepted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAvailableAttackPathTypesForDomainRequest generates requests for ListAvailableAttackPathTypesForDomain
func NewListAvailableAttackPathTypesForDomainRequest(server string, domainId string, params *ListAvailableAttackPathTypesForDomainParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/available-types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListDomainAttackPathsDetailsRequest generates requests for ListDomainAttackPathsDetails
func NewListDomainAttackPathsDetailsRequest(server string, domainId string, params *ListDomainAttackPathsDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/details", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FindingDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, *params.FindingDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromPrincipalDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "FromPrincipal", runtime.ParamLocationQuery, *params.FromPrincipalDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToPrincipalDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ToPrincipal", runtime.ParamLocationQuery, *params.ToPrincipalDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromPrincipal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_principal", runtime.ParamLocationQuery, *params.FromPrincipal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToPrincipal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_principal", runtime.ParamLocationQuery, *params.ToPrincipal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrincipalsHash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principals_hash", runtime.ParamLocationQuery, *params.PrincipalsHash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accepted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Accepted", runtime.ParamLocationQuery, *params.Accepted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AcceptedUntilDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "AcceptedUntil", runtime.ParamLocationQuery, *params.AcceptedUntilDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AcceptedUntil != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepted_until", runtime.ParamLocationQuery, *params.AcceptedUntil); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Principal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Principal", runtime.ParamLocationQuery, *params.Principal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Finding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Finding", runtime.ParamLocationQuery, *params.Finding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_sid", runtime.ParamLocationQuery, *params.DomainSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAttackPathSparklineValuesRequest generates requests for ListAttackPathSparklineValues
func NewListAttackPathSparklineValuesRequest(server string, domainId string, params *ListAttackPathSparklineValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/sparkline", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finding", runtime.ParamLocationQuery, params.Finding); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityRequest generates requests for GetDomainEntity
func NewGetDomainEntityRequest(server string, objectId PathObjectId, params *GetDomainEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateDomainEntityRequest calls the generic UpdateDomainEntity builder with application/json body
func NewUpdateDomainEntityRequest(server string, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDomainEntityRequestWithBody(server, objectId, params, "application/json", bodyReader)
}

// NewUpdateDomainEntityRequestWithBody generates requests for UpdateDomainEntity with any type of body
func NewUpdateDomainEntityRequestWithBody(server string, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityComputersRequest generates requests for GetDomainEntityComputers
func NewGetDomainEntityComputersRequest(server string, objectId PathObjectId, params *GetDomainEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityControllersRequest generates requests for GetDomainEntityControllers
func NewGetDomainEntityControllersRequest(server string, objectId PathObjectId, params *GetDomainEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityDcSyncersRequest generates requests for GetDomainEntityDcSyncers
func NewGetDomainEntityDcSyncersRequest(server string, objectId PathObjectId, params *GetDomainEntityDcSyncersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/dc-syncers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignAdminsRequest generates requests for GetDomainEntityForeignAdmins
func NewGetDomainEntityForeignAdminsRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-admins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignGpoControllersRequest generates requests for GetDomainEntityForeignGpoControllers
func NewGetDomainEntityForeignGpoControllersRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-gpo-controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignGroupsRequest generates requests for GetDomainEntityForeignGroups
func NewGetDomainEntityForeignGroupsRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityForeignUsersRequest generates requests for GetDomainEntityForeignUsers
func NewGetDomainEntityForeignUsersRequest(server string, objectId PathObjectId, params *GetDomainEntityForeignUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/foreign-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityGposRequest generates requests for GetDomainEntityGpos
func NewGetDomainEntityGposRequest(server string, objectId PathObjectId, params *GetDomainEntityGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityGroupsRequest generates requests for GetDomainEntityGroups
func NewGetDomainEntityGroupsRequest(server string, objectId PathObjectId, params *GetDomainEntityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityInboundTrustsRequest generates requests for GetDomainEntityInboundTrusts
func NewGetDomainEntityInboundTrustsRequest(server string, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/inbound-trusts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityLinkedGposRequest generates requests for GetDomainEntityLinkedGpos
func NewGetDomainEntityLinkedGposRequest(server string, objectId PathObjectId, params *GetDomainEntityLinkedGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/linked-gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityOusRequest generates requests for GetDomainEntityOus
func NewGetDomainEntityOusRequest(server string, objectId PathObjectId, params *GetDomainEntityOusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/ous", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityOutboundTrustsRequest generates requests for GetDomainEntityOutboundTrusts
func NewGetDomainEntityOutboundTrustsRequest(server string, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/outbound-trusts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetDomainEntityUsersRequest generates requests for GetDomainEntityUsers
func NewGetDomainEntityUsersRequest(server string, objectId PathObjectId, params *GetDomainEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/domains/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEnterpriseCaEntityRequest generates requests for GetEnterpriseCaEntity
func NewGetEnterpriseCaEntityRequest(server string, objectId PathObjectId, params *GetEnterpriseCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/enterprisecas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetEnterpriseCaEntityControllersRequest generates requests for GetEnterpriseCaEntityControllers
func NewGetEnterpriseCaEntityControllersRequest(server string, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/enterprisecas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientSchedulesRequest generates requests for ListClientSchedules
func NewListClientSchedulesRequest(server string, params *ListClientSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rrule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rrule", runtime.ParamLocationQuery, *params.Rrule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextScheduledAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_scheduled_at", runtime.ParamLocationQuery, *params.NextScheduledAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientScheduleRequest calls the generic CreateClientSchedule builder with application/json body
func NewCreateClientScheduleRequest(server string, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientScheduleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateClientScheduleRequestWithBody generates requests for CreateClientSchedule with any type of body
func NewCreateClientScheduleRequestWithBody(server string, params *CreateClientScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteClientEventRequest generates requests for DeleteClientEvent
func NewDeleteClientEventRequest(server string, eventId int32, params *DeleteClientEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientScheduleRequest generates requests for GetClientSchedule
func NewGetClientScheduleRequest(server string, eventId int32, params *GetClientScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateClientEventRequest calls the generic UpdateClientEvent builder with application/json body
func NewUpdateClientEventRequest(server string, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientEventRequestWithBody(server, eventId, params, "application/json", bodyReader)
}

// NewUpdateClientEventRequestWithBody generates requests for UpdateClientEvent with any type of body
func NewUpdateClientEventRequestWithBody(server string, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListFeatureFlagsRequest generates requests for ListFeatureFlags
func NewListFeatureFlagsRequest(server string, params *ListFeatureFlagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewToggleFeatureFlagRequest generates requests for ToggleFeatureFlag
func NewToggleFeatureFlagRequest(server string, featureId int32, params *ToggleFeatureFlagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "feature_id", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/features/%s/toggle", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListFileUploadJobsRequest generates requests for ListFileUploadJobs
func NewListFileUploadJobsRequest(server string, params *ListFileUploadJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserEmailAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_email_address", runtime.ParamLocationQuery, *params.UserEmailAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusMessage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status_message", runtime.ParamLocationQuery, *params.StatusMessage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAcceptedFileUploadTypesRequest generates requests for ListAcceptedFileUploadTypes
func NewListAcceptedFileUploadTypesRequest(server string, params *ListAcceptedFileUploadTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/accepted-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateFileUploadJobRequest generates requests for CreateFileUploadJob
func NewCreateFileUploadJobRequest(server string, params *CreateFileUploadJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUploadFileToJobRequest calls the generic UploadFileToJob builder with application/json body
func NewUploadFileToJobRequest(server string, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadFileToJobRequestWithBody(server, fileUploadJobId, params, "application/json", bodyReader)
}

// NewUploadFileToJobRequestWithBody generates requests for UploadFileToJob with any type of body
func NewUploadFileToJobRequestWithBody(server string, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_upload_job_id", runtime.ParamLocationPath, fileUploadJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam1)

	}

	return req, nil
}

// NewEndFileUploadJobRequest generates requests for EndFileUploadJob
func NewEndFileUploadJobRequest(server string, fileUploadJobId int64, params *EndFileUploadJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_upload_job_id", runtime.ParamLocationPath, fileUploadJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/file-upload/%s/end", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityRequest generates requests for GetGpoEntity
func NewGetGpoEntityRequest(server string, objectId PathObjectId, params *GetGpoEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityComputersRequest generates requests for GetGpoEntityComputers
func NewGetGpoEntityComputersRequest(server string, objectId PathObjectId, params *GetGpoEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityControllersRequest generates requests for GetGpoEntityControllers
func NewGetGpoEntityControllersRequest(server string, objectId PathObjectId, params *GetGpoEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityOusRequest generates requests for GetGpoEntityOus
func NewGetGpoEntityOusRequest(server string, objectId PathObjectId, params *GetGpoEntityOusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/ous", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityTierZeroRequest generates requests for GetGpoEntityTierZero
func NewGetGpoEntityTierZeroRequest(server string, objectId PathObjectId, params *GetGpoEntityTierZeroParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/tier-zero", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGpoEntityUsersRequest generates requests for GetGpoEntityUsers
func NewGetGpoEntityUsersRequest(server string, objectId PathObjectId, params *GetGpoEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/gpos/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSearchResultRequest generates requests for GetSearchResult
func NewGetSearchResultRequest(server string, params *GetSearchResultParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graph-search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_query", runtime.ParamLocationQuery, params.SearchQuery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewRunCypherQueryRequest calls the generic RunCypherQuery builder with application/json body
func NewRunCypherQueryRequest(server string, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunCypherQueryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRunCypherQueryRequestWithBody generates requests for RunCypherQuery with any type of body
func NewRunCypherQueryRequestWithBody(server string, params *RunCypherQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/cypher")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPathCompositionRequest generates requests for GetPathComposition
func NewGetPathCompositionRequest(server string, params *GetPathCompositionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/edge-composition")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_node", runtime.ParamLocationQuery, params.SourceNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_node", runtime.ParamLocationQuery, params.TargetNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "edge_type", runtime.ParamLocationQuery, params.EdgeType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetShortestPathRequest generates requests for GetShortestPath
func NewGetShortestPathRequest(server string, params *GetShortestPathParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/graphs/shortest-path")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_node", runtime.ParamLocationQuery, params.StartNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_node", runtime.ParamLocationQuery, params.EndNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RelationshipKinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relationship_kinds", runtime.ParamLocationQuery, *params.RelationshipKinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityRequest generates requests for GetGroupEntity
func NewGetGroupEntityRequest(server string, objectId PathObjectId, params *GetGroupEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityAdminRightsRequest generates requests for GetGroupEntityAdminRights
func NewGetGroupEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityControllablesRequest generates requests for GetGroupEntityControllables
func NewGetGroupEntityControllablesRequest(server string, objectId PathObjectId, params *GetGroupEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityControllersRequest generates requests for GetGroupEntityControllers
func NewGetGroupEntityControllersRequest(server string, objectId PathObjectId, params *GetGroupEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityDcomRightsRequest generates requests for GetGroupEntityDcomRights
func NewGetGroupEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityMembersRequest generates requests for GetGroupEntityMembers
func NewGetGroupEntityMembersRequest(server string, objectId PathObjectId, params *GetGroupEntityMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityMembershipsRequest generates requests for GetGroupEntityMemberships
func NewGetGroupEntityMembershipsRequest(server string, objectId PathObjectId, params *GetGroupEntityMembershipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityPsRemoteRightsRequest generates requests for GetGroupEntityPsRemoteRights
func NewGetGroupEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntityRdpRightsRequest generates requests for GetGroupEntityRdpRights
func NewGetGroupEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetGroupEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetGroupEntitySessionsRequest generates requests for GetGroupEntitySessions
func NewGetGroupEntitySessionsRequest(server string, objectId PathObjectId, params *GetGroupEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/groups/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewIngestDataRequest generates requests for IngestData
func NewIngestDataRequest(server string, params *IngestDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ingest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobsRequest generates requests for GetClientJobs
func NewGetClientJobsRequest(server string, params *GetClientJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAvailableClientJobsRequest generates requests for ListAvailableClientJobs
func NewListAvailableClientJobsRequest(server string, params *ListAvailableClientJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/available")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientCurrentJobRequest generates requests for GetClientCurrentJob
func NewGetClientCurrentJobRequest(server string, params *GetClientCurrentJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewEndClientJobRequest generates requests for EndClientJob
func NewEndClientJobRequest(server string, params *EndClientJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/end")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListClientFinishedJobsRequest generates requests for ListClientFinishedJobs
func NewListClientFinishedJobsRequest(server string, params *ListClientFinishedJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/finished")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_path", runtime.ParamLocationQuery, *params.LogPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SessionCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_collection", runtime.ParamLocationQuery, *params.SessionCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalGroupCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_group_collection", runtime.ParamLocationQuery, *params.LocalGroupCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertServicesCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_services_collection", runtime.ParamLocationQuery, *params.CertServicesCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ca_registry_collection", runtime.ParamLocationQuery, *params.CaRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DcRegistryCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dc_registry_collection", runtime.ParamLocationQuery, *params.DcRegistryCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdStructureCollection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ad_structure_collection", runtime.ParamLocationQuery, *params.AdStructureCollection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainController != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_controller", runtime.ParamLocationQuery, *params.DomainController); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTitle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_title", runtime.ParamLocationQuery, *params.EventTitle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "execution_time", runtime.ParamLocationQuery, *params.ExecutionTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastIngest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_ingest", runtime.ParamLocationQuery, *params.LastIngest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateDomains != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_domains", runtime.ParamLocationQuery, *params.HydrateDomains); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HydrateOus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hydrate_ous", runtime.ParamLocationQuery, *params.HydrateOus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewStartClientJobRequest calls the generic StartClientJob builder with application/json body
func NewStartClientJobRequest(server string, params *StartClientJobParams, body StartClientJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartClientJobRequestWithBody(server, params, "application/json", bodyReader)
}

// NewStartClientJobRequestWithBody generates requests for StartClientJob with any type of body
func NewStartClientJobRequestWithBody(server string, params *StartClientJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobRequest generates requests for GetClientJob
func NewGetClientJobRequest(server string, jobId int64, params *GetClientJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCancelClientJobRequest generates requests for CancelClientJob
func NewCancelClientJobRequest(server string, jobId int64, params *CancelClientJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetClientJobLogRequest generates requests for GetClientJobLog
func NewGetClientJobLogRequest(server string, jobId int64, params *GetClientJobLogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/jobs/%s/log", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, params *LoginParams, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, params *LoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string, params *LogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetLatestTierZeroComboNodeRequest generates requests for GetLatestTierZeroComboNode
func NewGetLatestTierZeroComboNodeRequest(server string, domainId string, params *GetLatestTierZeroComboNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta-nodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetComboTreeGraphRequest generates requests for GetComboTreeGraph
func NewGetComboTreeGraphRequest(server string, domainId string, params *GetComboTreeGraphParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain_id", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta-trees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NodeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "node_id", runtime.ParamLocationQuery, *params.NodeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetMetaEntityRequest generates requests for GetMetaEntity
func NewGetMetaEntityRequest(server string, objectId PathObjectId, params *GetMetaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/meta/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetNtAuthStoreEntityRequest generates requests for GetNtAuthStoreEntity
func NewGetNtAuthStoreEntityRequest(server string, objectId PathObjectId, params *GetNtAuthStoreEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ntauthstores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetNtAuthStoreEntityControllersRequest generates requests for GetNtAuthStoreEntityControllers
func NewGetNtAuthStoreEntityControllersRequest(server string, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ntauthstores/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityRequest generates requests for GetOuEntity
func NewGetOuEntityRequest(server string, objectId PathObjectId, params *GetOuEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityComputersRequest generates requests for GetOuEntityComputers
func NewGetOuEntityComputersRequest(server string, objectId PathObjectId, params *GetOuEntityComputersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/computers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityGposRequest generates requests for GetOuEntityGpos
func NewGetOuEntityGposRequest(server string, objectId PathObjectId, params *GetOuEntityGposParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/gpos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityGroupsRequest generates requests for GetOuEntityGroups
func NewGetOuEntityGroupsRequest(server string, objectId PathObjectId, params *GetOuEntityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetOuEntityUsersRequest generates requests for GetOuEntityUsers
func NewGetOuEntityUsersRequest(server string, objectId PathObjectId, params *GetOuEntityUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/ous/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewPathfindingRequest generates requests for Pathfinding
func NewPathfindingRequest(server string, params *PathfindingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/pathfinding")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_node", runtime.ParamLocationQuery, params.StartNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_node", runtime.ParamLocationQuery, params.EndNode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListPermissionsRequest generates requests for ListPermissions
func NewListPermissionsRequest(server string, params *ListPermissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authority", runtime.ParamLocationQuery, *params.Authority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPermissionRequest generates requests for GetPermission
func NewGetPermissionRequest(server string, permissionId int32, params *GetPermissionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPlatformDataQualityAggregateRequest generates requests for GetPlatformDataQualityAggregate
func NewGetPlatformDataQualityAggregateRequest(server string, platformId string, params *GetPlatformDataQualityAggregateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform_id", runtime.ParamLocationPath, platformId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/platform/%s/data-quality-stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetPostureStatsRequest generates requests for GetPostureStats
func NewGetPostureStatsRequest(server string, params *GetPostureStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/posture-stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.FromDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToDeprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.ToDeprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainSid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_sid", runtime.ParamLocationQuery, *params.DomainSid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExposureIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exposure_index", runtime.ParamLocationQuery, *params.ExposureIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TierZeroCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tier_zero_count", runtime.ParamLocationQuery, *params.TierZeroCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CriticalRiskCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "critical_risk_count", runtime.ParamLocationQuery, *params.CriticalRiskCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string, params *ListRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, roleId int32, params *GetRoleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "role_id", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRootCaEntityRequest generates requests for GetRootCaEntity
func NewGetRootCaEntityRequest(server string, objectId PathObjectId, params *GetRootCaEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/rootcas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetRootCaEntityControllersRequest generates requests for GetRootCaEntityControllers
func NewGetRootCaEntityControllersRequest(server string, objectId PathObjectId, params *GetRootCaEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/rootcas/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListSamlProvidersRequest generates requests for ListSamlProviders
func NewListSamlProvidersRequest(server string, params *ListSamlProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSamlProviderRequestWithBody generates requests for CreateSamlProvider with any type of body
func NewCreateSamlProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSamlProviderRequest generates requests for DeleteSamlProvider
func NewDeleteSamlProviderRequest(server string, samlProviderId int32, params *DeleteSamlProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saml_provider_id", runtime.ParamLocationPath, samlProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSamlProviderRequest generates requests for GetSamlProvider
func NewGetSamlProviderRequest(server string, samlProviderId int32, params *GetSamlProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saml_provider_id", runtime.ParamLocationPath, samlProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSamlSignSignOnEndpointsRequest generates requests for GetSamlSignSignOnEndpoints
func NewGetSamlSignSignOnEndpointsRequest(server string, params *GetSamlSignSignOnEndpointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saml/sso")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListSavedQueriesRequest generates requests for ListSavedQueries
func NewListSavedQueriesRequest(server string, params *ListSavedQueriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSavedQueryRequest calls the generic CreateSavedQuery builder with application/json body
func NewCreateSavedQueryRequest(server string, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSavedQueryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSavedQueryRequestWithBody generates requests for CreateSavedQuery with any type of body
func NewCreateSavedQueryRequestWithBody(server string, params *CreateSavedQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSavedQueryRequest generates requests for DeleteSavedQuery
func NewDeleteSavedQueryRequest(server string, savedQueryId int32, params *DeleteSavedQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSavedQueryRequest calls the generic UpdateSavedQuery builder with application/json body
func NewUpdateSavedQueryRequest(server string, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSavedQueryRequestWithBody(server, savedQueryId, params, "application/json", bodyReader)
}

// NewUpdateSavedQueryRequestWithBody generates requests for UpdateSavedQuery with any type of body
func NewUpdateSavedQueryRequestWithBody(server string, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSavedQueryPermissionsRequest calls the generic DeleteSavedQueryPermissions builder with application/json body
func NewDeleteSavedQueryPermissionsRequest(server string, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSavedQueryPermissionsRequestWithBody(server, savedQueryId, params, "application/json", bodyReader)
}

// NewDeleteSavedQueryPermissionsRequestWithBody generates requests for DeleteSavedQueryPermissions with any type of body
func NewDeleteSavedQueryPermissionsRequestWithBody(server string, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "saved_query_id", runtime.ParamLocationPath, savedQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/saved-queries/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetSelfRequest generates requests for GetSelf
func NewGetSelfRequest(server string, params *GetSelfParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiSpecRequest generates requests for GetApiSpec
func NewGetApiSpecRequest(server string, params *GetApiSpecParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/spec/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewListAuthTokensRequest generates requests for ListAuthTokens
func NewListAuthTokensRequest(server string, params *ListAuthTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HmacMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hmac_method", runtime.ParamLocationQuery, *params.HmacMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastAccess != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_access", runtime.ParamLocationQuery, *params.LastAccess); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewCreateAuthTokenRequest calls the generic CreateAuthToken builder with application/json body
func NewCreateAuthTokenRequest(server string, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuthTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAuthTokenRequestWithBody generates requests for CreateAuthToken with any type of body
func NewCreateAuthTokenRequestWithBody(server string, params *CreateAuthTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteAuthTokenRequest generates requests for DeleteAuthToken
func NewDeleteAuthTokenRequest(server string, tokenId openapi_types.UUID, params *DeleteAuthTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityRequest generates requests for GetUserEntity
func NewGetUserEntityRequest(server string, objectId PathObjectId, params *GetUserEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Counts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "counts", runtime.ParamLocationQuery, *params.Counts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityAdminRightsRequest generates requests for GetUserEntityAdminRights
func NewGetUserEntityAdminRightsRequest(server string, objectId PathObjectId, params *GetUserEntityAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityConstrainedDelegationRightsRequest generates requests for GetUserEntityConstrainedDelegationRights
func NewGetUserEntityConstrainedDelegationRightsRequest(server string, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/constrained-delegation-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityControllablesRequest generates requests for GetUserEntityControllables
func NewGetUserEntityControllablesRequest(server string, objectId PathObjectId, params *GetUserEntityControllablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/controllables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityControllersRequest generates requests for GetUserEntityControllers
func NewGetUserEntityControllersRequest(server string, objectId PathObjectId, params *GetUserEntityControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityDcomRightsRequest generates requests for GetUserEntityDcomRights
func NewGetUserEntityDcomRightsRequest(server string, objectId PathObjectId, params *GetUserEntityDcomRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/dcom-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityMembershipRequest generates requests for GetUserEntityMembership
func NewGetUserEntityMembershipRequest(server string, objectId PathObjectId, params *GetUserEntityMembershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityPsRemoteRightsRequest generates requests for GetUserEntityPsRemoteRights
func NewGetUserEntityPsRemoteRightsRequest(server string, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/ps-remote-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntityRdpRightsRequest generates requests for GetUserEntityRdpRights
func NewGetUserEntityRdpRightsRequest(server string, objectId PathObjectId, params *GetUserEntityRdpRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/rdp-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntitySessionsRequest generates requests for GetUserEntitySessions
func NewGetUserEntitySessionsRequest(server string, objectId PathObjectId, params *GetUserEntitySessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserEntitySqlAdminRightsRequest generates requests for GetUserEntitySqlAdminRights
func NewGetUserEntitySqlAdminRightsRequest(server string, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s/sql-admin-rights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiVersionRequest generates requests for GetApiVersion
func NewGetApiVersionRequest(server string, params *GetApiVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Prefer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Prefer", runtime.ParamLocationHeader, *params.Prefer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Prefer", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AcceptEulaWithResponse request
	AcceptEulaWithResponse(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*AcceptEulaResponse, error)

	// GetAdDomainDataQualityStatsWithResponse request
	GetAdDomainDataQualityStatsWithResponse(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAdDomainDataQualityStatsResponse, error)

	// GetAiaCaEntityWithResponse request
	GetAiaCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityResponse, error)

	// GetAiaCaEntityControllersWithResponse request
	GetAiaCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityControllersResponse, error)

	// StartAnalysisWithResponse request
	StartAnalysisWithResponse(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*StartAnalysisResponse, error)

	// ListAssetGroupsWithResponse request
	ListAssetGroupsWithResponse(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupsResponse, error)

	// CreateAssetGroupWithBodyWithResponse request with any body
	CreateAssetGroupWithBodyWithResponse(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error)

	CreateAssetGroupWithResponse(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error)

	// DeleteAssetGroupWithResponse request
	DeleteAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupResponse, error)

	// GetAssetGroupWithResponse request
	GetAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*GetAssetGroupResponse, error)

	// UpdateAssetGroupWithBodyWithResponse request with any body
	UpdateAssetGroupWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error)

	UpdateAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error)

	// ListAssetGroupCollectionsWithResponse request
	ListAssetGroupCollectionsWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupCollectionsResponse, error)

	// GetAssetGroupComboNodeWithResponse request
	GetAssetGroupComboNodeWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*GetAssetGroupComboNodeResponse, error)

	// GetAssetGroupCustomMemberCountWithResponse request
	GetAssetGroupCustomMemberCountWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*GetAssetGroupCustomMemberCountResponse, error)

	// ListAssetGroupMembersWithResponse request
	ListAssetGroupMembersWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMembersResponse, error)

	// ListAssetGroupMemberCountByKindWithResponse request
	ListAssetGroupMemberCountByKindWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMemberCountByKindResponse, error)

	// UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse request with any body
	UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error)

	UpdateAssetGroupSelectorsDeprecatedWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error)

	// UpdateAssetGroupSelectorsWithBodyWithResponse request with any body
	UpdateAssetGroupSelectorsWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error)

	UpdateAssetGroupSelectorsWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error)

	// DeleteAssetGroupSelectorWithResponse request
	DeleteAssetGroupSelectorWithResponse(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupSelectorResponse, error)

	// ListAttackPathTypesWithResponse request
	ListAttackPathTypesWithResponse(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*ListAttackPathTypesResponse, error)

	// StartAnalysisBheWithResponse request
	StartAnalysisBheWithResponse(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*StartAnalysisBheResponse, error)

	// UpdateAttackPathRiskWithBodyWithResponse request with any body
	UpdateAttackPathRiskWithBodyWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error)

	UpdateAttackPathRiskWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error)

	// ListAuditLogsWithResponse request
	ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)

	// GetAvailableDomainsWithResponse request
	GetAvailableDomainsWithResponse(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*GetAvailableDomainsResponse, error)

	// GetAzureTenantDataQualityStatsWithResponse request
	GetAzureTenantDataQualityStatsWithResponse(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAzureTenantDataQualityStatsResponse, error)

	// GetAzureEntityWithResponse request
	GetAzureEntityWithResponse(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*GetAzureEntityResponse, error)

	// GetEntityWithResponse request
	GetEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*GetEntityResponse, error)

	// GetEntityControllablesWithResponse request
	GetEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetEntityControllablesResponse, error)

	// GetEntityControllersWithResponse request
	GetEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEntityControllersResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// RemoveUserMfaWithBodyWithResponse request with any body
	RemoveUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error)

	RemoveUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error)

	// AddUserMfaWithBodyWithResponse request with any body
	AddUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error)

	AddUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error)

	// GetMfaActivationStatusWithResponse request
	GetMfaActivationStatusWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*GetMfaActivationStatusResponse, error)

	// ActivateUserMfaWithBodyWithResponse request with any body
	ActivateUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error)

	ActivateUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error)

	// DeleteUserSecretWithResponse request
	DeleteUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*DeleteUserSecretResponse, error)

	// CreateOrSetUserSecretWithBodyWithResponse request with any body
	CreateOrSetUserSecretWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error)

	CreateOrSetUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error)

	// GetCertTemplateEntityWithResponse request
	GetCertTemplateEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityResponse, error)

	// GetCertTemplateEntityControllersWithResponse request
	GetCertTemplateEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityControllersResponse, error)

	// DeleteBloodHoundDatabaseWithBodyWithResponse request with any body
	DeleteBloodHoundDatabaseWithBodyWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error)

	DeleteBloodHoundDatabaseWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error)

	// ListClientsWithResponse request
	ListClientsWithResponse(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*ListClientsResponse, error)

	// CreateClientWithBodyWithResponse request with any body
	CreateClientWithBodyWithResponse(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	CreateClientWithResponse(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	// LogClientErrorWithBodyWithResponse request with any body
	LogClientErrorWithBodyWithResponse(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error)

	LogClientErrorWithResponse(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error)

	// UpdateClientInfoWithBodyWithResponse request with any body
	UpdateClientInfoWithBodyWithResponse(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error)

	UpdateClientInfoWithResponse(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error)

	// DeleteClientWithResponse request
	DeleteClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*DeleteClientResponse, error)

	// GetClientWithResponse request
	GetClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error)

	// UpdateClientWithBodyWithResponse request with any body
	UpdateClientWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error)

	UpdateClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error)

	// ListClientCompletedJobsWithResponse request
	ListClientCompletedJobsWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListClientCompletedJobsResponse, error)

	// ListClientCompletedTasksWithResponse request
	ListClientCompletedTasksWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*ListClientCompletedTasksResponse, error)

	// CreateClientScheduledJobWithBodyWithResponse request with any body
	CreateClientScheduledJobWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error)

	CreateClientScheduledJobWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error)

	// CreateClientScheduledTaskWithBodyWithResponse request with any body
	CreateClientScheduledTaskWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error)

	CreateClientScheduledTaskWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error)

	// ReplaceClientTokenWithResponse request
	ReplaceClientTokenWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*ReplaceClientTokenResponse, error)

	// GetCollectorManifestWithResponse request
	GetCollectorManifestWithResponse(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*GetCollectorManifestResponse, error)

	// DownloadCollectorWithResponse request
	DownloadCollectorWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*DownloadCollectorResponse, error)

	// GetCollectorChecksumWithResponse request
	GetCollectorChecksumWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*GetCollectorChecksumResponse, error)

	// GetCompletenessStatsWithResponse request
	GetCompletenessStatsWithResponse(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*GetCompletenessStatsResponse, error)

	// GetComputerEntityWithResponse request
	GetComputerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*GetComputerEntityResponse, error)

	// GetComputerEntityAdminRightsWithResponse request
	GetComputerEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminRightsResponse, error)

	// GetComputerEntityAdminsWithResponse request
	GetComputerEntityAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminsResponse, error)

	// GetComputerEntityConstrainedDelegationRightsWithResponse request
	GetComputerEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedDelegationRightsResponse, error)

	// GetComputerEntityConstrainedUsersWithResponse request
	GetComputerEntityConstrainedUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedUsersResponse, error)

	// GetComputerEntityControllablesWithResponse request
	GetComputerEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllablesResponse, error)

	// GetComputerEntityControllersWithResponse request
	GetComputerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllersResponse, error)

	// GetComputerEntityDcomRightsWithResponse request
	GetComputerEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomRightsResponse, error)

	// GetComputerEntityDcomUsersWithResponse request
	GetComputerEntityDcomUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomUsersResponse, error)

	// GetComputerEntityGroupMembershipWithResponse request
	GetComputerEntityGroupMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*GetComputerEntityGroupMembershipResponse, error)

	// GetComputerEntityPsRemoteRightsWithResponse request
	GetComputerEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteRightsResponse, error)

	// GetComputerEntityPsRemoteUsersWithResponse request
	GetComputerEntityPsRemoteUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteUsersResponse, error)

	// GetComputerEntityRdpRightsWithResponse request
	GetComputerEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpRightsResponse, error)

	// GetComputerEntityRdpUsersWithResponse request
	GetComputerEntityRdpUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpUsersResponse, error)

	// GetComputerEntitySessionsWithResponse request
	GetComputerEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySessionsResponse, error)

	// GetComputerEntitySqlAdminsWithResponse request
	GetComputerEntitySqlAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySqlAdminsResponse, error)

	// ListAppConfigParamsWithResponse request
	ListAppConfigParamsWithResponse(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*ListAppConfigParamsResponse, error)

	// SetAppConfigParamWithBodyWithResponse request with any body
	SetAppConfigParamWithBodyWithResponse(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error)

	SetAppConfigParamWithResponse(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error)

	// GetContainerEntityWithResponse request
	GetContainerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*GetContainerEntityResponse, error)

	// GetContainerEntityControllersWithResponse request
	GetContainerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetContainerEntityControllersResponse, error)

	// GetDatapipeStatusWithResponse request
	GetDatapipeStatusWithResponse(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*GetDatapipeStatusResponse, error)

	// ExportAttackPathFindingsWithResponse request
	ExportAttackPathFindingsWithResponse(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*ExportAttackPathFindingsResponse, error)

	// ListAvailableAttackPathTypesForDomainWithResponse request
	ListAvailableAttackPathTypesForDomainWithResponse(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*ListAvailableAttackPathTypesForDomainResponse, error)

	// ListDomainAttackPathsDetailsWithResponse request
	ListDomainAttackPathsDetailsWithResponse(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*ListDomainAttackPathsDetailsResponse, error)

	// ListAttackPathSparklineValuesWithResponse request
	ListAttackPathSparklineValuesWithResponse(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*ListAttackPathSparklineValuesResponse, error)

	// GetDomainEntityWithResponse request
	GetDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*GetDomainEntityResponse, error)

	// UpdateDomainEntityWithBodyWithResponse request with any body
	UpdateDomainEntityWithBodyWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error)

	UpdateDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error)

	// GetDomainEntityComputersWithResponse request
	GetDomainEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityComputersResponse, error)

	// GetDomainEntityControllersWithResponse request
	GetDomainEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityControllersResponse, error)

	// GetDomainEntityDcSyncersWithResponse request
	GetDomainEntityDcSyncersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityDcSyncersResponse, error)

	// GetDomainEntityForeignAdminsWithResponse request
	GetDomainEntityForeignAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignAdminsResponse, error)

	// GetDomainEntityForeignGpoControllersWithResponse request
	GetDomainEntityForeignGpoControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGpoControllersResponse, error)

	// GetDomainEntityForeignGroupsWithResponse request
	GetDomainEntityForeignGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGroupsResponse, error)

	// GetDomainEntityForeignUsersWithResponse request
	GetDomainEntityForeignUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignUsersResponse, error)

	// GetDomainEntityGposWithResponse request
	GetDomainEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGposResponse, error)

	// GetDomainEntityGroupsWithResponse request
	GetDomainEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGroupsResponse, error)

	// GetDomainEntityInboundTrustsWithResponse request
	GetDomainEntityInboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityInboundTrustsResponse, error)

	// GetDomainEntityLinkedGposWithResponse request
	GetDomainEntityLinkedGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityLinkedGposResponse, error)

	// GetDomainEntityOusWithResponse request
	GetDomainEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOusResponse, error)

	// GetDomainEntityOutboundTrustsWithResponse request
	GetDomainEntityOutboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOutboundTrustsResponse, error)

	// GetDomainEntityUsersWithResponse request
	GetDomainEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityUsersResponse, error)

	// GetEnterpriseCaEntityWithResponse request
	GetEnterpriseCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityResponse, error)

	// GetEnterpriseCaEntityControllersWithResponse request
	GetEnterpriseCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityControllersResponse, error)

	// ListClientSchedulesWithResponse request
	ListClientSchedulesWithResponse(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*ListClientSchedulesResponse, error)

	// CreateClientScheduleWithBodyWithResponse request with any body
	CreateClientScheduleWithBodyWithResponse(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error)

	CreateClientScheduleWithResponse(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error)

	// DeleteClientEventWithResponse request
	DeleteClientEventWithResponse(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*DeleteClientEventResponse, error)

	// GetClientScheduleWithResponse request
	GetClientScheduleWithResponse(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*GetClientScheduleResponse, error)

	// UpdateClientEventWithBodyWithResponse request with any body
	UpdateClientEventWithBodyWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error)

	UpdateClientEventWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error)

	// ListFeatureFlagsWithResponse request
	ListFeatureFlagsWithResponse(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*ListFeatureFlagsResponse, error)

	// ToggleFeatureFlagWithResponse request
	ToggleFeatureFlagWithResponse(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*ToggleFeatureFlagResponse, error)

	// ListFileUploadJobsWithResponse request
	ListFileUploadJobsWithResponse(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*ListFileUploadJobsResponse, error)

	// ListAcceptedFileUploadTypesWithResponse request
	ListAcceptedFileUploadTypesWithResponse(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*ListAcceptedFileUploadTypesResponse, error)

	// CreateFileUploadJobWithResponse request
	CreateFileUploadJobWithResponse(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*CreateFileUploadJobResponse, error)

	// UploadFileToJobWithBodyWithResponse request with any body
	UploadFileToJobWithBodyWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error)

	UploadFileToJobWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error)

	// EndFileUploadJobWithResponse request
	EndFileUploadJobWithResponse(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*EndFileUploadJobResponse, error)

	// GetGpoEntityWithResponse request
	GetGpoEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*GetGpoEntityResponse, error)

	// GetGpoEntityComputersWithResponse request
	GetGpoEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityComputersResponse, error)

	// GetGpoEntityControllersWithResponse request
	GetGpoEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityControllersResponse, error)

	// GetGpoEntityOusWithResponse request
	GetGpoEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*GetGpoEntityOusResponse, error)

	// GetGpoEntityTierZeroWithResponse request
	GetGpoEntityTierZeroWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*GetGpoEntityTierZeroResponse, error)

	// GetGpoEntityUsersWithResponse request
	GetGpoEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityUsersResponse, error)

	// GetSearchResultWithResponse request
	GetSearchResultWithResponse(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*GetSearchResultResponse, error)

	// RunCypherQueryWithBodyWithResponse request with any body
	RunCypherQueryWithBodyWithResponse(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error)

	RunCypherQueryWithResponse(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error)

	// GetPathCompositionWithResponse request
	GetPathCompositionWithResponse(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*GetPathCompositionResponse, error)

	// GetShortestPathWithResponse request
	GetShortestPathWithResponse(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*GetShortestPathResponse, error)

	// GetGroupEntityWithResponse request
	GetGroupEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*GetGroupEntityResponse, error)

	// GetGroupEntityAdminRightsWithResponse request
	GetGroupEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityAdminRightsResponse, error)

	// GetGroupEntityControllablesWithResponse request
	GetGroupEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllablesResponse, error)

	// GetGroupEntityControllersWithResponse request
	GetGroupEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllersResponse, error)

	// GetGroupEntityDcomRightsWithResponse request
	GetGroupEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityDcomRightsResponse, error)

	// GetGroupEntityMembersWithResponse request
	GetGroupEntityMembersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembersResponse, error)

	// GetGroupEntityMembershipsWithResponse request
	GetGroupEntityMembershipsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembershipsResponse, error)

	// GetGroupEntityPsRemoteRightsWithResponse request
	GetGroupEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityPsRemoteRightsResponse, error)

	// GetGroupEntityRdpRightsWithResponse request
	GetGroupEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityRdpRightsResponse, error)

	// GetGroupEntitySessionsWithResponse request
	GetGroupEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetGroupEntitySessionsResponse, error)

	// IngestDataWithResponse request
	IngestDataWithResponse(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*IngestDataResponse, error)

	// GetClientJobsWithResponse request
	GetClientJobsWithResponse(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*GetClientJobsResponse, error)

	// ListAvailableClientJobsWithResponse request
	ListAvailableClientJobsWithResponse(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*ListAvailableClientJobsResponse, error)

	// GetClientCurrentJobWithResponse request
	GetClientCurrentJobWithResponse(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*GetClientCurrentJobResponse, error)

	// EndClientJobWithResponse request
	EndClientJobWithResponse(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*EndClientJobResponse, error)

	// ListClientFinishedJobsWithResponse request
	ListClientFinishedJobsWithResponse(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*ListClientFinishedJobsResponse, error)

	// StartClientJobWithBodyWithResponse request with any body
	StartClientJobWithBodyWithResponse(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error)

	StartClientJobWithResponse(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error)

	// GetClientJobWithResponse request
	GetClientJobWithResponse(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*GetClientJobResponse, error)

	// CancelClientJobWithResponse request
	CancelClientJobWithResponse(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*CancelClientJobResponse, error)

	// GetClientJobLogWithResponse request
	GetClientJobLogWithResponse(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*GetClientJobLogResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// GetLatestTierZeroComboNodeWithResponse request
	GetLatestTierZeroComboNodeWithResponse(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*GetLatestTierZeroComboNodeResponse, error)

	// GetComboTreeGraphWithResponse request
	GetComboTreeGraphWithResponse(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*GetComboTreeGraphResponse, error)

	// GetMetaEntityWithResponse request
	GetMetaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*GetMetaEntityResponse, error)

	// GetNtAuthStoreEntityWithResponse request
	GetNtAuthStoreEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityResponse, error)

	// GetNtAuthStoreEntityControllersWithResponse request
	GetNtAuthStoreEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityControllersResponse, error)

	// GetOuEntityWithResponse request
	GetOuEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*GetOuEntityResponse, error)

	// GetOuEntityComputersWithResponse request
	GetOuEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*GetOuEntityComputersResponse, error)

	// GetOuEntityGposWithResponse request
	GetOuEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*GetOuEntityGposResponse, error)

	// GetOuEntityGroupsWithResponse request
	GetOuEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetOuEntityGroupsResponse, error)

	// GetOuEntityUsersWithResponse request
	GetOuEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*GetOuEntityUsersResponse, error)

	// PathfindingWithResponse request
	PathfindingWithResponse(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*PathfindingResponse, error)

	// ListPermissionsWithResponse request
	ListPermissionsWithResponse(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*ListPermissionsResponse, error)

	// GetPermissionWithResponse request
	GetPermissionWithResponse(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*GetPermissionResponse, error)

	// GetPlatformDataQualityAggregateWithResponse request
	GetPlatformDataQualityAggregateWithResponse(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*GetPlatformDataQualityAggregateResponse, error)

	// GetPostureStatsWithResponse request
	GetPostureStatsWithResponse(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*GetPostureStatsResponse, error)

	// ListRolesWithResponse request
	ListRolesWithResponse(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// GetRootCaEntityWithResponse request
	GetRootCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityResponse, error)

	// GetRootCaEntityControllersWithResponse request
	GetRootCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityControllersResponse, error)

	// ListSamlProvidersWithResponse request
	ListSamlProvidersWithResponse(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*ListSamlProvidersResponse, error)

	// CreateSamlProviderWithBodyWithResponse request with any body
	CreateSamlProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSamlProviderResponse, error)

	// DeleteSamlProviderWithResponse request
	DeleteSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*DeleteSamlProviderResponse, error)

	// GetSamlProviderWithResponse request
	GetSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*GetSamlProviderResponse, error)

	// GetSamlSignSignOnEndpointsWithResponse request
	GetSamlSignSignOnEndpointsWithResponse(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*GetSamlSignSignOnEndpointsResponse, error)

	// ListSavedQueriesWithResponse request
	ListSavedQueriesWithResponse(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*ListSavedQueriesResponse, error)

	// CreateSavedQueryWithBodyWithResponse request with any body
	CreateSavedQueryWithBodyWithResponse(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error)

	CreateSavedQueryWithResponse(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error)

	// DeleteSavedQueryWithResponse request
	DeleteSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*DeleteSavedQueryResponse, error)

	// UpdateSavedQueryWithBodyWithResponse request with any body
	UpdateSavedQueryWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error)

	UpdateSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error)

	// DeleteSavedQueryPermissionsWithBodyWithResponse request with any body
	DeleteSavedQueryPermissionsWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error)

	DeleteSavedQueryPermissionsWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// GetSelfWithResponse request
	GetSelfWithResponse(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*GetSelfResponse, error)

	// GetApiSpecWithResponse request
	GetApiSpecWithResponse(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*GetApiSpecResponse, error)

	// ListAuthTokensWithResponse request
	ListAuthTokensWithResponse(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*ListAuthTokensResponse, error)

	// CreateAuthTokenWithBodyWithResponse request with any body
	CreateAuthTokenWithBodyWithResponse(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error)

	CreateAuthTokenWithResponse(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error)

	// DeleteAuthTokenWithResponse request
	DeleteAuthTokenWithResponse(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*DeleteAuthTokenResponse, error)

	// GetUserEntityWithResponse request
	GetUserEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*GetUserEntityResponse, error)

	// GetUserEntityAdminRightsWithResponse request
	GetUserEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityAdminRightsResponse, error)

	// GetUserEntityConstrainedDelegationRightsWithResponse request
	GetUserEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityConstrainedDelegationRightsResponse, error)

	// GetUserEntityControllablesWithResponse request
	GetUserEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllablesResponse, error)

	// GetUserEntityControllersWithResponse request
	GetUserEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllersResponse, error)

	// GetUserEntityDcomRightsWithResponse request
	GetUserEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityDcomRightsResponse, error)

	// GetUserEntityMembershipWithResponse request
	GetUserEntityMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*GetUserEntityMembershipResponse, error)

	// GetUserEntityPsRemoteRightsWithResponse request
	GetUserEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityPsRemoteRightsResponse, error)

	// GetUserEntityRdpRightsWithResponse request
	GetUserEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityRdpRightsResponse, error)

	// GetUserEntitySessionsWithResponse request
	GetUserEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySessionsResponse, error)

	// GetUserEntitySqlAdminRightsWithResponse request
	GetUserEntitySqlAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySqlAdminRightsResponse, error)

	// GetApiVersionWithResponse request
	GetApiVersionWithResponse(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*GetApiVersionResponse, error)
}

type AcceptEulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AcceptEulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptEulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdDomainDataQualityStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                      `json:"count,omitempty"`
		Data  *[]ModelAdDataQualityStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAdDomainDataQualityStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdDomainDataQualityStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiaCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiaCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiaCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAiaCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAiaCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAiaCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartAnalysisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r StartAnalysisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartAnalysisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AssetGroups *[]ModelAssetGroup `json:"asset_groups,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *ApiErrorWrapper
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAssetGroup `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelAssetGroupCollection `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupComboNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupComboNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupComboNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetGroupCustomMemberCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CustomMemberCount *int `json:"custom_member_count,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAssetGroupCustomMemberCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetGroupCustomMemberCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int `json:"count,omitempty"`
		Data  *struct {
			Members *[]ModelAssetGroupMember `json:"members,omitempty"`
		} `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetGroupMemberCountByKindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Counts     *map[string]int `json:"counts,omitempty"`
			TotalCount *int            `json:"total_count,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAssetGroupMemberCountByKindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetGroupMemberCountByKindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupSelectorsDeprecatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
			RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupSelectorsDeprecatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupSelectorsDeprecatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetGroupSelectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *struct {
			AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
			RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAssetGroupSelectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetGroupSelectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetGroupSelectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *ApiErrorWrapper
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAssetGroupSelectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetGroupSelectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttackPathTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAttackPathTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttackPathTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartAnalysisBheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartAnalysisBheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartAnalysisBheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAttackPathRiskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseFinding
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAttackPathRiskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAttackPathRiskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Logs *[]ModelAuditLog `json:"logs,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelDomainSelector `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAvailableDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAzureTenantDataQualityStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                         `json:"count,omitempty"`
		Data  *[]ModelAzureDataQualityStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAzureTenantDataQualityStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAzureTenantDataQualityStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAzureEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAzureEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAzureEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Users *[]ModelUser `json:"users,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUser `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUser `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RemoveUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			QrCode     *string `json:"qr_code,omitempty"`
			TotpSecret *string `json:"totp_secret,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMfaActivationStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMfaActivationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMfaActivationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateUserMfaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			// Status The activation status of multi-factor authentication on a BloodHound user.
			Status *EnumMfaActivationStatus `json:"status,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ActivateUserMfaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateUserMfaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrSetUserSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateOrSetUserSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrSetUserSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertTemplateEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertTemplateEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertTemplateEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertTemplateEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertTemplateEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertTemplateEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBloodHoundDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBloodHoundDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBloodHoundDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                  `json:"count,omitempty"`
		Data  *[]ModelClientDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogClientErrorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LogClientErrorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogClientErrorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClient `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientCompletedTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientCompletedTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientCompletedTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduledJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduledJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduledJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduledTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduledTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduledTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceClientTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAuthToken `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ReplaceClientTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceClientTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelCollectorManifest `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCollectorManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadCollectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DownloadCollectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadCollectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorChecksumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCollectorChecksumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorChecksumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletenessStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]float64 `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCompletenessStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletenessStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityConstrainedDelegationRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityConstrainedDelegationRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityConstrainedDelegationRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityConstrainedUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityConstrainedUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityConstrainedUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityDcomUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityDcomUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityDcomUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityPsRemoteUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityPsRemoteUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityPsRemoteUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntityRdpUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntityRdpUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntityRdpUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComputerEntitySqlAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComputerEntitySqlAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComputerEntitySqlAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppConfigParamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelAppConfigParam `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAppConfigParamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppConfigParamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAppConfigParamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Key   *string                 `json:"key,omitempty"`
			Value *map[string]interface{} `json:"value,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SetAppConfigParamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAppConfigParamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetContainerEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetContainerEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatapipeStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			LastCompleteAnalysisAt *time.Time          `json:"last_complete_analysis_at,omitempty"`
			Status                 *EnumDatapipeStatus `json:"status,omitempty"`
			UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetDatapipeStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatapipeStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportAttackPathFindingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportAttackPathFindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportAttackPathFindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableAttackPathTypesForDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAvailableAttackPathTypesForDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableAttackPathTypesForDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDomainAttackPathsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListDomainAttackPathsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDomainAttackPathsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAttackPathSparklineValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelRiskCounts `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAttackPathSparklineValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAttackPathSparklineValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDomainEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Collected *bool `json:"collected,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateDomainEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDomainEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityDcSyncersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityDcSyncersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityDcSyncersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignGpoControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignGpoControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignGpoControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityForeignUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityForeignUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityForeignUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityInboundTrustsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityInboundTrustsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityInboundTrustsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityLinkedGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityLinkedGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityLinkedGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityOusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityOusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityOusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityOutboundTrustsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityOutboundTrustsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityOutboundTrustsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDomainEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnterpriseCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEnterpriseCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnterpriseCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnterpriseCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEnterpriseCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnterpriseCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                          `json:"count,omitempty"`
		Data  *[]ModelClientScheduleDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClientScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteClientEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduleDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClientEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFeatureFlagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelFeatureFlag `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFeatureFlagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFeatureFlagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleFeatureFlagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ToggleFeatureFlagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleFeatureFlagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFileUploadJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                  `json:"count,omitempty"`
		Data  *[]ModelFileUploadJob `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFileUploadJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFileUploadJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAcceptedFileUploadTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]string `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r ListAcceptedFileUploadTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAcceptedFileUploadTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFileUploadJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *ModelFileUploadJob `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateFileUploadJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFileUploadJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFileToJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UploadFileToJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFileToJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndFileUploadJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EndFileUploadJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndFileUploadJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityOusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityOusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityOusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityTierZeroResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityTierZeroResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityTierZeroResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGpoEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGpoEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGpoEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSearchResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunCypherQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RunCypherQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunCypherQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPathCompositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPathCompositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPathCompositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShortestPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetShortestPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShortestPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IngestDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r IngestDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IngestDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAvailableClientJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAvailableClientJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableClientJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientCurrentJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientCurrentJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientCurrentJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EndClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientFinishedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                              `json:"count,omitempty"`
		Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListClientFinishedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientFinishedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJob `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelClientJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CancelClientJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelClientJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientJobLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Log *string `json:"log,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClientJobLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientJobLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AuthExpired  *bool               `json:"auth_expired,omitempty"`
			SessionToken *string             `json:"session_token,omitempty"`
			UserId       *openapi_types.UUID `json:"user_id,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestTierZeroComboNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetLatestTierZeroComboNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestTierZeroComboNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComboTreeGraphResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetComboTreeGraphResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComboTreeGraphResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Props *map[string]map[string]interface{} `json:"props,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMetaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNtAuthStoreEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNtAuthStoreEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNtAuthStoreEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNtAuthStoreEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNtAuthStoreEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNtAuthStoreEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityComputersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityComputersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityComputersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityGposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityGposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityGposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOuEntityUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOuEntityUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOuEntityUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PathfindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelBhGraphGraph `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PathfindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PathfindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Permissions *[]ModelPermission `json:"permissions,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelPermission `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformDataQualityAggregateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseDataQualityPlatformAggregate
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPlatformDataQualityAggregateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformDataQualityAggregateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostureStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int                    `json:"count,omitempty"`
		Data  *[]ModelRiskPostureStat `json:"data,omitempty"`

		// End The RFC-3339 timestamp to describe the end of a time range
		End *time.Time `json:"end,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

		// Start The RFC-3339 timestamp to describe the beginning of a time range
		Start *time.Time `json:"start,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPostureStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostureStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Roles *[]ModelRole `json:"roles,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelRole `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootCaEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRootCaEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootCaEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootCaEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRootCaEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootCaEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSamlProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			SamlProviders *[]ModelSamlProvider `json:"saml_providers,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSamlProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSamlProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSamlProvider `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AffectedUser *[]ModelUser `json:"affected_user,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON409 *ApiErrorWrapper
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSamlProvider `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlSignSignOnEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Endpoints *[]ModelSamlSignOnEndpoint `json:"endpoints,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSamlSignSignOnEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlSignSignOnEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSavedQueriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of results.
		Count *int               `json:"count,omitempty"`
		Data  *[]ModelSavedQuery `json:"data,omitempty"`

		// Limit The limit of results requested by the client.
		Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

		// Skip The number of items to skip in a paginated response.
		Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSavedQueriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSavedQueriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data *ModelSavedQuery `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSavedQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelSavedQuery `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateSavedQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSavedQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSavedQueryPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSavedQueryPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSavedQueryPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ModelSearchResult `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiResponseAuthenticatedRequester
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r GetSelfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML200      *openapi_types.File
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetApiSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuthTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Tokens *[]ModelAuthToken `json:"tokens,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListAuthTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuthTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *ModelAuthToken `json:"data,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntityInfoQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityConstrainedDelegationRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityConstrainedDelegationRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityConstrainedDelegationRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityControllablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityControllablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityControllablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityDcomRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityDcomRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityDcomRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityPsRemoteRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityPsRemoteRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityPsRemoteRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntityRdpRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntityRdpRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntityRdpRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntitySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntitySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntitySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEntitySqlAdminRightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RelatedEntityQueryResults
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserEntitySqlAdminRightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEntitySqlAdminRightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			API *struct {
				CurrentVersion    *string `json:"current_version,omitempty"`
				DeprecatedVersion *string `json:"deprecated_version,omitempty"`
			} `json:"API,omitempty"`
			ServerVersion *string `json:"server_version,omitempty"`
		} `json:"data,omitempty"`
	}
	JSON401 *Unauthorized
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetApiVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AcceptEulaWithResponse request returning *AcceptEulaResponse
func (c *ClientWithResponses) AcceptEulaWithResponse(ctx context.Context, params *AcceptEulaParams, reqEditors ...RequestEditorFn) (*AcceptEulaResponse, error) {
	rsp, err := c.AcceptEula(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptEulaResponse(rsp)
}

// GetAdDomainDataQualityStatsWithResponse request returning *GetAdDomainDataQualityStatsResponse
func (c *ClientWithResponses) GetAdDomainDataQualityStatsWithResponse(ctx context.Context, domainId string, params *GetAdDomainDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAdDomainDataQualityStatsResponse, error) {
	rsp, err := c.GetAdDomainDataQualityStats(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdDomainDataQualityStatsResponse(rsp)
}

// GetAiaCaEntityWithResponse request returning *GetAiaCaEntityResponse
func (c *ClientWithResponses) GetAiaCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityResponse, error) {
	rsp, err := c.GetAiaCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiaCaEntityResponse(rsp)
}

// GetAiaCaEntityControllersWithResponse request returning *GetAiaCaEntityControllersResponse
func (c *ClientWithResponses) GetAiaCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetAiaCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetAiaCaEntityControllersResponse, error) {
	rsp, err := c.GetAiaCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAiaCaEntityControllersResponse(rsp)
}

// StartAnalysisWithResponse request returning *StartAnalysisResponse
func (c *ClientWithResponses) StartAnalysisWithResponse(ctx context.Context, params *StartAnalysisParams, reqEditors ...RequestEditorFn) (*StartAnalysisResponse, error) {
	rsp, err := c.StartAnalysis(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartAnalysisResponse(rsp)
}

// ListAssetGroupsWithResponse request returning *ListAssetGroupsResponse
func (c *ClientWithResponses) ListAssetGroupsWithResponse(ctx context.Context, params *ListAssetGroupsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupsResponse, error) {
	rsp, err := c.ListAssetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupsResponse(rsp)
}

// CreateAssetGroupWithBodyWithResponse request with arbitrary body returning *CreateAssetGroupResponse
func (c *ClientWithResponses) CreateAssetGroupWithBodyWithResponse(ctx context.Context, params *CreateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error) {
	rsp, err := c.CreateAssetGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateAssetGroupWithResponse(ctx context.Context, params *CreateAssetGroupParams, body CreateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssetGroupResponse, error) {
	rsp, err := c.CreateAssetGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetGroupResponse(rsp)
}

// DeleteAssetGroupWithResponse request returning *DeleteAssetGroupResponse
func (c *ClientWithResponses) DeleteAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *DeleteAssetGroupParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupResponse, error) {
	rsp, err := c.DeleteAssetGroup(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetGroupResponse(rsp)
}

// GetAssetGroupWithResponse request returning *GetAssetGroupResponse
func (c *ClientWithResponses) GetAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupParams, reqEditors ...RequestEditorFn) (*GetAssetGroupResponse, error) {
	rsp, err := c.GetAssetGroup(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupResponse(rsp)
}

// UpdateAssetGroupWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupResponse
func (c *ClientWithResponses) UpdateAssetGroupWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error) {
	rsp, err := c.UpdateAssetGroupWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupParams, body UpdateAssetGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupResponse, error) {
	rsp, err := c.UpdateAssetGroup(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupResponse(rsp)
}

// ListAssetGroupCollectionsWithResponse request returning *ListAssetGroupCollectionsResponse
func (c *ClientWithResponses) ListAssetGroupCollectionsWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupCollectionsParams, reqEditors ...RequestEditorFn) (*ListAssetGroupCollectionsResponse, error) {
	rsp, err := c.ListAssetGroupCollections(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupCollectionsResponse(rsp)
}

// GetAssetGroupComboNodeWithResponse request returning *GetAssetGroupComboNodeResponse
func (c *ClientWithResponses) GetAssetGroupComboNodeWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupComboNodeParams, reqEditors ...RequestEditorFn) (*GetAssetGroupComboNodeResponse, error) {
	rsp, err := c.GetAssetGroupComboNode(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupComboNodeResponse(rsp)
}

// GetAssetGroupCustomMemberCountWithResponse request returning *GetAssetGroupCustomMemberCountResponse
func (c *ClientWithResponses) GetAssetGroupCustomMemberCountWithResponse(ctx context.Context, assetGroupId int32, params *GetAssetGroupCustomMemberCountParams, reqEditors ...RequestEditorFn) (*GetAssetGroupCustomMemberCountResponse, error) {
	rsp, err := c.GetAssetGroupCustomMemberCount(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetGroupCustomMemberCountResponse(rsp)
}

// ListAssetGroupMembersWithResponse request returning *ListAssetGroupMembersResponse
func (c *ClientWithResponses) ListAssetGroupMembersWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMembersParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMembersResponse, error) {
	rsp, err := c.ListAssetGroupMembers(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupMembersResponse(rsp)
}

// ListAssetGroupMemberCountByKindWithResponse request returning *ListAssetGroupMemberCountByKindResponse
func (c *ClientWithResponses) ListAssetGroupMemberCountByKindWithResponse(ctx context.Context, assetGroupId int32, params *ListAssetGroupMemberCountByKindParams, reqEditors ...RequestEditorFn) (*ListAssetGroupMemberCountByKindResponse, error) {
	rsp, err := c.ListAssetGroupMemberCountByKind(ctx, assetGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetGroupMemberCountByKindResponse(rsp)
}

// UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupSelectorsDeprecatedResponse
func (c *ClientWithResponses) UpdateAssetGroupSelectorsDeprecatedWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsDeprecatedWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupSelectorsDeprecatedWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsDeprecatedParams, body UpdateAssetGroupSelectorsDeprecatedJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsDeprecated(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp)
}

// UpdateAssetGroupSelectorsWithBodyWithResponse request with arbitrary body returning *UpdateAssetGroupSelectorsResponse
func (c *ClientWithResponses) UpdateAssetGroupSelectorsWithBodyWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectorsWithBody(ctx, assetGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetGroupSelectorsWithResponse(ctx context.Context, assetGroupId int32, params *UpdateAssetGroupSelectorsParams, body UpdateAssetGroupSelectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetGroupSelectorsResponse, error) {
	rsp, err := c.UpdateAssetGroupSelectors(ctx, assetGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetGroupSelectorsResponse(rsp)
}

// DeleteAssetGroupSelectorWithResponse request returning *DeleteAssetGroupSelectorResponse
func (c *ClientWithResponses) DeleteAssetGroupSelectorWithResponse(ctx context.Context, assetGroupId int32, assetGroupSelectorId int32, params *DeleteAssetGroupSelectorParams, reqEditors ...RequestEditorFn) (*DeleteAssetGroupSelectorResponse, error) {
	rsp, err := c.DeleteAssetGroupSelector(ctx, assetGroupId, assetGroupSelectorId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetGroupSelectorResponse(rsp)
}

// ListAttackPathTypesWithResponse request returning *ListAttackPathTypesResponse
func (c *ClientWithResponses) ListAttackPathTypesWithResponse(ctx context.Context, params *ListAttackPathTypesParams, reqEditors ...RequestEditorFn) (*ListAttackPathTypesResponse, error) {
	rsp, err := c.ListAttackPathTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttackPathTypesResponse(rsp)
}

// StartAnalysisBheWithResponse request returning *StartAnalysisBheResponse
func (c *ClientWithResponses) StartAnalysisBheWithResponse(ctx context.Context, params *StartAnalysisBheParams, reqEditors ...RequestEditorFn) (*StartAnalysisBheResponse, error) {
	rsp, err := c.StartAnalysisBhe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartAnalysisBheResponse(rsp)
}

// UpdateAttackPathRiskWithBodyWithResponse request with arbitrary body returning *UpdateAttackPathRiskResponse
func (c *ClientWithResponses) UpdateAttackPathRiskWithBodyWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error) {
	rsp, err := c.UpdateAttackPathRiskWithBody(ctx, attackPathId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttackPathRiskResponse(rsp)
}

func (c *ClientWithResponses) UpdateAttackPathRiskWithResponse(ctx context.Context, attackPathId int64, params *UpdateAttackPathRiskParams, body UpdateAttackPathRiskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAttackPathRiskResponse, error) {
	rsp, err := c.UpdateAttackPathRisk(ctx, attackPathId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAttackPathRiskResponse(rsp)
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// GetAvailableDomainsWithResponse request returning *GetAvailableDomainsResponse
func (c *ClientWithResponses) GetAvailableDomainsWithResponse(ctx context.Context, params *GetAvailableDomainsParams, reqEditors ...RequestEditorFn) (*GetAvailableDomainsResponse, error) {
	rsp, err := c.GetAvailableDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableDomainsResponse(rsp)
}

// GetAzureTenantDataQualityStatsWithResponse request returning *GetAzureTenantDataQualityStatsResponse
func (c *ClientWithResponses) GetAzureTenantDataQualityStatsWithResponse(ctx context.Context, tenantId string, params *GetAzureTenantDataQualityStatsParams, reqEditors ...RequestEditorFn) (*GetAzureTenantDataQualityStatsResponse, error) {
	rsp, err := c.GetAzureTenantDataQualityStats(ctx, tenantId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAzureTenantDataQualityStatsResponse(rsp)
}

// GetAzureEntityWithResponse request returning *GetAzureEntityResponse
func (c *ClientWithResponses) GetAzureEntityWithResponse(ctx context.Context, entityType string, params *GetAzureEntityParams, reqEditors ...RequestEditorFn) (*GetAzureEntityResponse, error) {
	rsp, err := c.GetAzureEntity(ctx, entityType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAzureEntityResponse(rsp)
}

// GetEntityWithResponse request returning *GetEntityResponse
func (c *ClientWithResponses) GetEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityParams, reqEditors ...RequestEditorFn) (*GetEntityResponse, error) {
	rsp, err := c.GetEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityResponse(rsp)
}

// GetEntityControllablesWithResponse request returning *GetEntityControllablesResponse
func (c *ClientWithResponses) GetEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetEntityControllablesResponse, error) {
	rsp, err := c.GetEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityControllablesResponse(rsp)
}

// GetEntityControllersWithResponse request returning *GetEntityControllersResponse
func (c *ClientWithResponses) GetEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEntityControllersResponse, error) {
	rsp, err := c.GetEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntityControllersResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *UpdateUserParams, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// RemoveUserMfaWithBodyWithResponse request with arbitrary body returning *RemoveUserMfaResponse
func (c *ClientWithResponses) RemoveUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error) {
	rsp, err := c.RemoveUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserMfaResponse(rsp)
}

func (c *ClientWithResponses) RemoveUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *RemoveUserMfaParams, body RemoveUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserMfaResponse, error) {
	rsp, err := c.RemoveUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserMfaResponse(rsp)
}

// AddUserMfaWithBodyWithResponse request with arbitrary body returning *AddUserMfaResponse
func (c *ClientWithResponses) AddUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error) {
	rsp, err := c.AddUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserMfaResponse(rsp)
}

func (c *ClientWithResponses) AddUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *AddUserMfaParams, body AddUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserMfaResponse, error) {
	rsp, err := c.AddUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserMfaResponse(rsp)
}

// GetMfaActivationStatusWithResponse request returning *GetMfaActivationStatusResponse
func (c *ClientWithResponses) GetMfaActivationStatusWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetMfaActivationStatusParams, reqEditors ...RequestEditorFn) (*GetMfaActivationStatusResponse, error) {
	rsp, err := c.GetMfaActivationStatus(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMfaActivationStatusResponse(rsp)
}

// ActivateUserMfaWithBodyWithResponse request with arbitrary body returning *ActivateUserMfaResponse
func (c *ClientWithResponses) ActivateUserMfaWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error) {
	rsp, err := c.ActivateUserMfaWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateUserMfaResponse(rsp)
}

func (c *ClientWithResponses) ActivateUserMfaWithResponse(ctx context.Context, userId openapi_types.UUID, params *ActivateUserMfaParams, body ActivateUserMfaJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateUserMfaResponse, error) {
	rsp, err := c.ActivateUserMfa(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateUserMfaResponse(rsp)
}

// DeleteUserSecretWithResponse request returning *DeleteUserSecretResponse
func (c *ClientWithResponses) DeleteUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *DeleteUserSecretParams, reqEditors ...RequestEditorFn) (*DeleteUserSecretResponse, error) {
	rsp, err := c.DeleteUserSecret(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserSecretResponse(rsp)
}

// CreateOrSetUserSecretWithBodyWithResponse request with arbitrary body returning *CreateOrSetUserSecretResponse
func (c *ClientWithResponses) CreateOrSetUserSecretWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error) {
	rsp, err := c.CreateOrSetUserSecretWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrSetUserSecretResponse(rsp)
}

func (c *ClientWithResponses) CreateOrSetUserSecretWithResponse(ctx context.Context, userId openapi_types.UUID, params *CreateOrSetUserSecretParams, body CreateOrSetUserSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrSetUserSecretResponse, error) {
	rsp, err := c.CreateOrSetUserSecret(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrSetUserSecretResponse(rsp)
}

// GetCertTemplateEntityWithResponse request returning *GetCertTemplateEntityResponse
func (c *ClientWithResponses) GetCertTemplateEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityResponse, error) {
	rsp, err := c.GetCertTemplateEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertTemplateEntityResponse(rsp)
}

// GetCertTemplateEntityControllersWithResponse request returning *GetCertTemplateEntityControllersResponse
func (c *ClientWithResponses) GetCertTemplateEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetCertTemplateEntityControllersParams, reqEditors ...RequestEditorFn) (*GetCertTemplateEntityControllersResponse, error) {
	rsp, err := c.GetCertTemplateEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertTemplateEntityControllersResponse(rsp)
}

// DeleteBloodHoundDatabaseWithBodyWithResponse request with arbitrary body returning *DeleteBloodHoundDatabaseResponse
func (c *ClientWithResponses) DeleteBloodHoundDatabaseWithBodyWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error) {
	rsp, err := c.DeleteBloodHoundDatabaseWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBloodHoundDatabaseResponse(rsp)
}

func (c *ClientWithResponses) DeleteBloodHoundDatabaseWithResponse(ctx context.Context, params *DeleteBloodHoundDatabaseParams, body DeleteBloodHoundDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBloodHoundDatabaseResponse, error) {
	rsp, err := c.DeleteBloodHoundDatabase(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBloodHoundDatabaseResponse(rsp)
}

// ListClientsWithResponse request returning *ListClientsResponse
func (c *ClientWithResponses) ListClientsWithResponse(ctx context.Context, params *ListClientsParams, reqEditors ...RequestEditorFn) (*ListClientsResponse, error) {
	rsp, err := c.ListClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientsResponse(rsp)
}

// CreateClientWithBodyWithResponse request with arbitrary body returning *CreateClientResponse
func (c *ClientWithResponses) CreateClientWithBodyWithResponse(ctx context.Context, params *CreateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClientWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

func (c *ClientWithResponses) CreateClientWithResponse(ctx context.Context, params *CreateClientParams, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClient(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

// LogClientErrorWithBodyWithResponse request with arbitrary body returning *LogClientErrorResponse
func (c *ClientWithResponses) LogClientErrorWithBodyWithResponse(ctx context.Context, params *LogClientErrorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error) {
	rsp, err := c.LogClientErrorWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogClientErrorResponse(rsp)
}

func (c *ClientWithResponses) LogClientErrorWithResponse(ctx context.Context, params *LogClientErrorParams, body LogClientErrorJSONRequestBody, reqEditors ...RequestEditorFn) (*LogClientErrorResponse, error) {
	rsp, err := c.LogClientError(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogClientErrorResponse(rsp)
}

// UpdateClientInfoWithBodyWithResponse request with arbitrary body returning *UpdateClientInfoResponse
func (c *ClientWithResponses) UpdateClientInfoWithBodyWithResponse(ctx context.Context, params *UpdateClientInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error) {
	rsp, err := c.UpdateClientInfoWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientInfoResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientInfoWithResponse(ctx context.Context, params *UpdateClientInfoParams, body UpdateClientInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientInfoResponse, error) {
	rsp, err := c.UpdateClientInfo(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientInfoResponse(rsp)
}

// DeleteClientWithResponse request returning *DeleteClientResponse
func (c *ClientWithResponses) DeleteClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *DeleteClientParams, reqEditors ...RequestEditorFn) (*DeleteClientResponse, error) {
	rsp, err := c.DeleteClient(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientResponse(rsp)
}

// GetClientWithResponse request returning *GetClientResponse
func (c *ClientWithResponses) GetClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *GetClientParams, reqEditors ...RequestEditorFn) (*GetClientResponse, error) {
	rsp, err := c.GetClient(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientResponse(rsp)
}

// UpdateClientWithBodyWithResponse request with arbitrary body returning *UpdateClientResponse
func (c *ClientWithResponses) UpdateClientWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error) {
	rsp, err := c.UpdateClientWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientWithResponse(ctx context.Context, clientId openapi_types.UUID, params *UpdateClientParams, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error) {
	rsp, err := c.UpdateClient(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientResponse(rsp)
}

// ListClientCompletedJobsWithResponse request returning *ListClientCompletedJobsResponse
func (c *ClientWithResponses) ListClientCompletedJobsWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListClientCompletedJobsResponse, error) {
	rsp, err := c.ListClientCompletedJobs(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientCompletedJobsResponse(rsp)
}

// ListClientCompletedTasksWithResponse request returning *ListClientCompletedTasksResponse
func (c *ClientWithResponses) ListClientCompletedTasksWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ListClientCompletedTasksParams, reqEditors ...RequestEditorFn) (*ListClientCompletedTasksResponse, error) {
	rsp, err := c.ListClientCompletedTasks(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientCompletedTasksResponse(rsp)
}

// CreateClientScheduledJobWithBodyWithResponse request with arbitrary body returning *CreateClientScheduledJobResponse
func (c *ClientWithResponses) CreateClientScheduledJobWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error) {
	rsp, err := c.CreateClientScheduledJobWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledJobResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduledJobWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledJobParams, body CreateClientScheduledJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledJobResponse, error) {
	rsp, err := c.CreateClientScheduledJob(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledJobResponse(rsp)
}

// CreateClientScheduledTaskWithBodyWithResponse request with arbitrary body returning *CreateClientScheduledTaskResponse
func (c *ClientWithResponses) CreateClientScheduledTaskWithBodyWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error) {
	rsp, err := c.CreateClientScheduledTaskWithBody(ctx, clientId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledTaskResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduledTaskWithResponse(ctx context.Context, clientId openapi_types.UUID, params *CreateClientScheduledTaskParams, body CreateClientScheduledTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduledTaskResponse, error) {
	rsp, err := c.CreateClientScheduledTask(ctx, clientId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduledTaskResponse(rsp)
}

// ReplaceClientTokenWithResponse request returning *ReplaceClientTokenResponse
func (c *ClientWithResponses) ReplaceClientTokenWithResponse(ctx context.Context, clientId openapi_types.UUID, params *ReplaceClientTokenParams, reqEditors ...RequestEditorFn) (*ReplaceClientTokenResponse, error) {
	rsp, err := c.ReplaceClientToken(ctx, clientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceClientTokenResponse(rsp)
}

// GetCollectorManifestWithResponse request returning *GetCollectorManifestResponse
func (c *ClientWithResponses) GetCollectorManifestWithResponse(ctx context.Context, collectorType EnumClientType, params *GetCollectorManifestParams, reqEditors ...RequestEditorFn) (*GetCollectorManifestResponse, error) {
	rsp, err := c.GetCollectorManifest(ctx, collectorType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorManifestResponse(rsp)
}

// DownloadCollectorWithResponse request returning *DownloadCollectorResponse
func (c *ClientWithResponses) DownloadCollectorWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *DownloadCollectorParams, reqEditors ...RequestEditorFn) (*DownloadCollectorResponse, error) {
	rsp, err := c.DownloadCollector(ctx, collectorType, releaseTag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadCollectorResponse(rsp)
}

// GetCollectorChecksumWithResponse request returning *GetCollectorChecksumResponse
func (c *ClientWithResponses) GetCollectorChecksumWithResponse(ctx context.Context, collectorType EnumClientType, releaseTag string, params *GetCollectorChecksumParams, reqEditors ...RequestEditorFn) (*GetCollectorChecksumResponse, error) {
	rsp, err := c.GetCollectorChecksum(ctx, collectorType, releaseTag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorChecksumResponse(rsp)
}

// GetCompletenessStatsWithResponse request returning *GetCompletenessStatsResponse
func (c *ClientWithResponses) GetCompletenessStatsWithResponse(ctx context.Context, params *GetCompletenessStatsParams, reqEditors ...RequestEditorFn) (*GetCompletenessStatsResponse, error) {
	rsp, err := c.GetCompletenessStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletenessStatsResponse(rsp)
}

// GetComputerEntityWithResponse request returning *GetComputerEntityResponse
func (c *ClientWithResponses) GetComputerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityParams, reqEditors ...RequestEditorFn) (*GetComputerEntityResponse, error) {
	rsp, err := c.GetComputerEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityResponse(rsp)
}

// GetComputerEntityAdminRightsWithResponse request returning *GetComputerEntityAdminRightsResponse
func (c *ClientWithResponses) GetComputerEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminRightsResponse, error) {
	rsp, err := c.GetComputerEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityAdminRightsResponse(rsp)
}

// GetComputerEntityAdminsWithResponse request returning *GetComputerEntityAdminsResponse
func (c *ClientWithResponses) GetComputerEntityAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityAdminsResponse, error) {
	rsp, err := c.GetComputerEntityAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityAdminsResponse(rsp)
}

// GetComputerEntityConstrainedDelegationRightsWithResponse request returning *GetComputerEntityConstrainedDelegationRightsResponse
func (c *ClientWithResponses) GetComputerEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedDelegationRightsResponse, error) {
	rsp, err := c.GetComputerEntityConstrainedDelegationRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityConstrainedDelegationRightsResponse(rsp)
}

// GetComputerEntityConstrainedUsersWithResponse request returning *GetComputerEntityConstrainedUsersResponse
func (c *ClientWithResponses) GetComputerEntityConstrainedUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityConstrainedUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityConstrainedUsersResponse, error) {
	rsp, err := c.GetComputerEntityConstrainedUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityConstrainedUsersResponse(rsp)
}

// GetComputerEntityControllablesWithResponse request returning *GetComputerEntityControllablesResponse
func (c *ClientWithResponses) GetComputerEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllablesResponse, error) {
	rsp, err := c.GetComputerEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityControllablesResponse(rsp)
}

// GetComputerEntityControllersWithResponse request returning *GetComputerEntityControllersResponse
func (c *ClientWithResponses) GetComputerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityControllersResponse, error) {
	rsp, err := c.GetComputerEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityControllersResponse(rsp)
}

// GetComputerEntityDcomRightsWithResponse request returning *GetComputerEntityDcomRightsResponse
func (c *ClientWithResponses) GetComputerEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomRightsResponse, error) {
	rsp, err := c.GetComputerEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityDcomRightsResponse(rsp)
}

// GetComputerEntityDcomUsersWithResponse request returning *GetComputerEntityDcomUsersResponse
func (c *ClientWithResponses) GetComputerEntityDcomUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityDcomUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityDcomUsersResponse, error) {
	rsp, err := c.GetComputerEntityDcomUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityDcomUsersResponse(rsp)
}

// GetComputerEntityGroupMembershipWithResponse request returning *GetComputerEntityGroupMembershipResponse
func (c *ClientWithResponses) GetComputerEntityGroupMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityGroupMembershipParams, reqEditors ...RequestEditorFn) (*GetComputerEntityGroupMembershipResponse, error) {
	rsp, err := c.GetComputerEntityGroupMembership(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityGroupMembershipResponse(rsp)
}

// GetComputerEntityPsRemoteRightsWithResponse request returning *GetComputerEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetComputerEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetComputerEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityPsRemoteRightsResponse(rsp)
}

// GetComputerEntityPsRemoteUsersWithResponse request returning *GetComputerEntityPsRemoteUsersResponse
func (c *ClientWithResponses) GetComputerEntityPsRemoteUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityPsRemoteUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityPsRemoteUsersResponse, error) {
	rsp, err := c.GetComputerEntityPsRemoteUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityPsRemoteUsersResponse(rsp)
}

// GetComputerEntityRdpRightsWithResponse request returning *GetComputerEntityRdpRightsResponse
func (c *ClientWithResponses) GetComputerEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpRightsResponse, error) {
	rsp, err := c.GetComputerEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityRdpRightsResponse(rsp)
}

// GetComputerEntityRdpUsersWithResponse request returning *GetComputerEntityRdpUsersResponse
func (c *ClientWithResponses) GetComputerEntityRdpUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntityRdpUsersParams, reqEditors ...RequestEditorFn) (*GetComputerEntityRdpUsersResponse, error) {
	rsp, err := c.GetComputerEntityRdpUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntityRdpUsersResponse(rsp)
}

// GetComputerEntitySessionsWithResponse request returning *GetComputerEntitySessionsResponse
func (c *ClientWithResponses) GetComputerEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySessionsResponse, error) {
	rsp, err := c.GetComputerEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntitySessionsResponse(rsp)
}

// GetComputerEntitySqlAdminsWithResponse request returning *GetComputerEntitySqlAdminsResponse
func (c *ClientWithResponses) GetComputerEntitySqlAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetComputerEntitySqlAdminsParams, reqEditors ...RequestEditorFn) (*GetComputerEntitySqlAdminsResponse, error) {
	rsp, err := c.GetComputerEntitySqlAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComputerEntitySqlAdminsResponse(rsp)
}

// ListAppConfigParamsWithResponse request returning *ListAppConfigParamsResponse
func (c *ClientWithResponses) ListAppConfigParamsWithResponse(ctx context.Context, params *ListAppConfigParamsParams, reqEditors ...RequestEditorFn) (*ListAppConfigParamsResponse, error) {
	rsp, err := c.ListAppConfigParams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppConfigParamsResponse(rsp)
}

// SetAppConfigParamWithBodyWithResponse request with arbitrary body returning *SetAppConfigParamResponse
func (c *ClientWithResponses) SetAppConfigParamWithBodyWithResponse(ctx context.Context, params *SetAppConfigParamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error) {
	rsp, err := c.SetAppConfigParamWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppConfigParamResponse(rsp)
}

func (c *ClientWithResponses) SetAppConfigParamWithResponse(ctx context.Context, params *SetAppConfigParamParams, body SetAppConfigParamJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppConfigParamResponse, error) {
	rsp, err := c.SetAppConfigParam(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppConfigParamResponse(rsp)
}

// GetContainerEntityWithResponse request returning *GetContainerEntityResponse
func (c *ClientWithResponses) GetContainerEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityParams, reqEditors ...RequestEditorFn) (*GetContainerEntityResponse, error) {
	rsp, err := c.GetContainerEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerEntityResponse(rsp)
}

// GetContainerEntityControllersWithResponse request returning *GetContainerEntityControllersResponse
func (c *ClientWithResponses) GetContainerEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetContainerEntityControllersParams, reqEditors ...RequestEditorFn) (*GetContainerEntityControllersResponse, error) {
	rsp, err := c.GetContainerEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerEntityControllersResponse(rsp)
}

// GetDatapipeStatusWithResponse request returning *GetDatapipeStatusResponse
func (c *ClientWithResponses) GetDatapipeStatusWithResponse(ctx context.Context, params *GetDatapipeStatusParams, reqEditors ...RequestEditorFn) (*GetDatapipeStatusResponse, error) {
	rsp, err := c.GetDatapipeStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatapipeStatusResponse(rsp)
}

// ExportAttackPathFindingsWithResponse request returning *ExportAttackPathFindingsResponse
func (c *ClientWithResponses) ExportAttackPathFindingsWithResponse(ctx context.Context, domainId string, params *ExportAttackPathFindingsParams, reqEditors ...RequestEditorFn) (*ExportAttackPathFindingsResponse, error) {
	rsp, err := c.ExportAttackPathFindings(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAttackPathFindingsResponse(rsp)
}

// ListAvailableAttackPathTypesForDomainWithResponse request returning *ListAvailableAttackPathTypesForDomainResponse
func (c *ClientWithResponses) ListAvailableAttackPathTypesForDomainWithResponse(ctx context.Context, domainId string, params *ListAvailableAttackPathTypesForDomainParams, reqEditors ...RequestEditorFn) (*ListAvailableAttackPathTypesForDomainResponse, error) {
	rsp, err := c.ListAvailableAttackPathTypesForDomain(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableAttackPathTypesForDomainResponse(rsp)
}

// ListDomainAttackPathsDetailsWithResponse request returning *ListDomainAttackPathsDetailsResponse
func (c *ClientWithResponses) ListDomainAttackPathsDetailsWithResponse(ctx context.Context, domainId string, params *ListDomainAttackPathsDetailsParams, reqEditors ...RequestEditorFn) (*ListDomainAttackPathsDetailsResponse, error) {
	rsp, err := c.ListDomainAttackPathsDetails(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDomainAttackPathsDetailsResponse(rsp)
}

// ListAttackPathSparklineValuesWithResponse request returning *ListAttackPathSparklineValuesResponse
func (c *ClientWithResponses) ListAttackPathSparklineValuesWithResponse(ctx context.Context, domainId string, params *ListAttackPathSparklineValuesParams, reqEditors ...RequestEditorFn) (*ListAttackPathSparklineValuesResponse, error) {
	rsp, err := c.ListAttackPathSparklineValues(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAttackPathSparklineValuesResponse(rsp)
}

// GetDomainEntityWithResponse request returning *GetDomainEntityResponse
func (c *ClientWithResponses) GetDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityParams, reqEditors ...RequestEditorFn) (*GetDomainEntityResponse, error) {
	rsp, err := c.GetDomainEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityResponse(rsp)
}

// UpdateDomainEntityWithBodyWithResponse request with arbitrary body returning *UpdateDomainEntityResponse
func (c *ClientWithResponses) UpdateDomainEntityWithBodyWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error) {
	rsp, err := c.UpdateDomainEntityWithBody(ctx, objectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainEntityResponse(rsp)
}

func (c *ClientWithResponses) UpdateDomainEntityWithResponse(ctx context.Context, objectId PathObjectId, params *UpdateDomainEntityParams, body UpdateDomainEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainEntityResponse, error) {
	rsp, err := c.UpdateDomainEntity(ctx, objectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainEntityResponse(rsp)
}

// GetDomainEntityComputersWithResponse request returning *GetDomainEntityComputersResponse
func (c *ClientWithResponses) GetDomainEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityComputersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityComputersResponse, error) {
	rsp, err := c.GetDomainEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityComputersResponse(rsp)
}

// GetDomainEntityControllersWithResponse request returning *GetDomainEntityControllersResponse
func (c *ClientWithResponses) GetDomainEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityControllersResponse, error) {
	rsp, err := c.GetDomainEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityControllersResponse(rsp)
}

// GetDomainEntityDcSyncersWithResponse request returning *GetDomainEntityDcSyncersResponse
func (c *ClientWithResponses) GetDomainEntityDcSyncersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityDcSyncersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityDcSyncersResponse, error) {
	rsp, err := c.GetDomainEntityDcSyncers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityDcSyncersResponse(rsp)
}

// GetDomainEntityForeignAdminsWithResponse request returning *GetDomainEntityForeignAdminsResponse
func (c *ClientWithResponses) GetDomainEntityForeignAdminsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignAdminsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignAdminsResponse, error) {
	rsp, err := c.GetDomainEntityForeignAdmins(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignAdminsResponse(rsp)
}

// GetDomainEntityForeignGpoControllersWithResponse request returning *GetDomainEntityForeignGpoControllersResponse
func (c *ClientWithResponses) GetDomainEntityForeignGpoControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGpoControllersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGpoControllersResponse, error) {
	rsp, err := c.GetDomainEntityForeignGpoControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignGpoControllersResponse(rsp)
}

// GetDomainEntityForeignGroupsWithResponse request returning *GetDomainEntityForeignGroupsResponse
func (c *ClientWithResponses) GetDomainEntityForeignGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignGroupsResponse, error) {
	rsp, err := c.GetDomainEntityForeignGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignGroupsResponse(rsp)
}

// GetDomainEntityForeignUsersWithResponse request returning *GetDomainEntityForeignUsersResponse
func (c *ClientWithResponses) GetDomainEntityForeignUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityForeignUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityForeignUsersResponse, error) {
	rsp, err := c.GetDomainEntityForeignUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityForeignUsersResponse(rsp)
}

// GetDomainEntityGposWithResponse request returning *GetDomainEntityGposResponse
func (c *ClientWithResponses) GetDomainEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGposResponse, error) {
	rsp, err := c.GetDomainEntityGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityGposResponse(rsp)
}

// GetDomainEntityGroupsWithResponse request returning *GetDomainEntityGroupsResponse
func (c *ClientWithResponses) GetDomainEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityGroupsResponse, error) {
	rsp, err := c.GetDomainEntityGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityGroupsResponse(rsp)
}

// GetDomainEntityInboundTrustsWithResponse request returning *GetDomainEntityInboundTrustsResponse
func (c *ClientWithResponses) GetDomainEntityInboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityInboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityInboundTrustsResponse, error) {
	rsp, err := c.GetDomainEntityInboundTrusts(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityInboundTrustsResponse(rsp)
}

// GetDomainEntityLinkedGposWithResponse request returning *GetDomainEntityLinkedGposResponse
func (c *ClientWithResponses) GetDomainEntityLinkedGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityLinkedGposParams, reqEditors ...RequestEditorFn) (*GetDomainEntityLinkedGposResponse, error) {
	rsp, err := c.GetDomainEntityLinkedGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityLinkedGposResponse(rsp)
}

// GetDomainEntityOusWithResponse request returning *GetDomainEntityOusResponse
func (c *ClientWithResponses) GetDomainEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOusParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOusResponse, error) {
	rsp, err := c.GetDomainEntityOus(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityOusResponse(rsp)
}

// GetDomainEntityOutboundTrustsWithResponse request returning *GetDomainEntityOutboundTrustsResponse
func (c *ClientWithResponses) GetDomainEntityOutboundTrustsWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityOutboundTrustsParams, reqEditors ...RequestEditorFn) (*GetDomainEntityOutboundTrustsResponse, error) {
	rsp, err := c.GetDomainEntityOutboundTrusts(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityOutboundTrustsResponse(rsp)
}

// GetDomainEntityUsersWithResponse request returning *GetDomainEntityUsersResponse
func (c *ClientWithResponses) GetDomainEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetDomainEntityUsersParams, reqEditors ...RequestEditorFn) (*GetDomainEntityUsersResponse, error) {
	rsp, err := c.GetDomainEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainEntityUsersResponse(rsp)
}

// GetEnterpriseCaEntityWithResponse request returning *GetEnterpriseCaEntityResponse
func (c *ClientWithResponses) GetEnterpriseCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityResponse, error) {
	rsp, err := c.GetEnterpriseCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnterpriseCaEntityResponse(rsp)
}

// GetEnterpriseCaEntityControllersWithResponse request returning *GetEnterpriseCaEntityControllersResponse
func (c *ClientWithResponses) GetEnterpriseCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetEnterpriseCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetEnterpriseCaEntityControllersResponse, error) {
	rsp, err := c.GetEnterpriseCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnterpriseCaEntityControllersResponse(rsp)
}

// ListClientSchedulesWithResponse request returning *ListClientSchedulesResponse
func (c *ClientWithResponses) ListClientSchedulesWithResponse(ctx context.Context, params *ListClientSchedulesParams, reqEditors ...RequestEditorFn) (*ListClientSchedulesResponse, error) {
	rsp, err := c.ListClientSchedules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientSchedulesResponse(rsp)
}

// CreateClientScheduleWithBodyWithResponse request with arbitrary body returning *CreateClientScheduleResponse
func (c *ClientWithResponses) CreateClientScheduleWithBodyWithResponse(ctx context.Context, params *CreateClientScheduleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error) {
	rsp, err := c.CreateClientScheduleWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduleResponse(rsp)
}

func (c *ClientWithResponses) CreateClientScheduleWithResponse(ctx context.Context, params *CreateClientScheduleParams, body CreateClientScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientScheduleResponse, error) {
	rsp, err := c.CreateClientSchedule(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientScheduleResponse(rsp)
}

// DeleteClientEventWithResponse request returning *DeleteClientEventResponse
func (c *ClientWithResponses) DeleteClientEventWithResponse(ctx context.Context, eventId int32, params *DeleteClientEventParams, reqEditors ...RequestEditorFn) (*DeleteClientEventResponse, error) {
	rsp, err := c.DeleteClientEvent(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientEventResponse(rsp)
}

// GetClientScheduleWithResponse request returning *GetClientScheduleResponse
func (c *ClientWithResponses) GetClientScheduleWithResponse(ctx context.Context, eventId int32, params *GetClientScheduleParams, reqEditors ...RequestEditorFn) (*GetClientScheduleResponse, error) {
	rsp, err := c.GetClientSchedule(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientScheduleResponse(rsp)
}

// UpdateClientEventWithBodyWithResponse request with arbitrary body returning *UpdateClientEventResponse
func (c *ClientWithResponses) UpdateClientEventWithBodyWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error) {
	rsp, err := c.UpdateClientEventWithBody(ctx, eventId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientEventResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientEventWithResponse(ctx context.Context, eventId int32, params *UpdateClientEventParams, body UpdateClientEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientEventResponse, error) {
	rsp, err := c.UpdateClientEvent(ctx, eventId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientEventResponse(rsp)
}

// ListFeatureFlagsWithResponse request returning *ListFeatureFlagsResponse
func (c *ClientWithResponses) ListFeatureFlagsWithResponse(ctx context.Context, params *ListFeatureFlagsParams, reqEditors ...RequestEditorFn) (*ListFeatureFlagsResponse, error) {
	rsp, err := c.ListFeatureFlags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFeatureFlagsResponse(rsp)
}

// ToggleFeatureFlagWithResponse request returning *ToggleFeatureFlagResponse
func (c *ClientWithResponses) ToggleFeatureFlagWithResponse(ctx context.Context, featureId int32, params *ToggleFeatureFlagParams, reqEditors ...RequestEditorFn) (*ToggleFeatureFlagResponse, error) {
	rsp, err := c.ToggleFeatureFlag(ctx, featureId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleFeatureFlagResponse(rsp)
}

// ListFileUploadJobsWithResponse request returning *ListFileUploadJobsResponse
func (c *ClientWithResponses) ListFileUploadJobsWithResponse(ctx context.Context, params *ListFileUploadJobsParams, reqEditors ...RequestEditorFn) (*ListFileUploadJobsResponse, error) {
	rsp, err := c.ListFileUploadJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFileUploadJobsResponse(rsp)
}

// ListAcceptedFileUploadTypesWithResponse request returning *ListAcceptedFileUploadTypesResponse
func (c *ClientWithResponses) ListAcceptedFileUploadTypesWithResponse(ctx context.Context, params *ListAcceptedFileUploadTypesParams, reqEditors ...RequestEditorFn) (*ListAcceptedFileUploadTypesResponse, error) {
	rsp, err := c.ListAcceptedFileUploadTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAcceptedFileUploadTypesResponse(rsp)
}

// CreateFileUploadJobWithResponse request returning *CreateFileUploadJobResponse
func (c *ClientWithResponses) CreateFileUploadJobWithResponse(ctx context.Context, params *CreateFileUploadJobParams, reqEditors ...RequestEditorFn) (*CreateFileUploadJobResponse, error) {
	rsp, err := c.CreateFileUploadJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFileUploadJobResponse(rsp)
}

// UploadFileToJobWithBodyWithResponse request with arbitrary body returning *UploadFileToJobResponse
func (c *ClientWithResponses) UploadFileToJobWithBodyWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error) {
	rsp, err := c.UploadFileToJobWithBody(ctx, fileUploadJobId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileToJobResponse(rsp)
}

func (c *ClientWithResponses) UploadFileToJobWithResponse(ctx context.Context, fileUploadJobId int64, params *UploadFileToJobParams, body UploadFileToJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadFileToJobResponse, error) {
	rsp, err := c.UploadFileToJob(ctx, fileUploadJobId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFileToJobResponse(rsp)
}

// EndFileUploadJobWithResponse request returning *EndFileUploadJobResponse
func (c *ClientWithResponses) EndFileUploadJobWithResponse(ctx context.Context, fileUploadJobId int64, params *EndFileUploadJobParams, reqEditors ...RequestEditorFn) (*EndFileUploadJobResponse, error) {
	rsp, err := c.EndFileUploadJob(ctx, fileUploadJobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndFileUploadJobResponse(rsp)
}

// GetGpoEntityWithResponse request returning *GetGpoEntityResponse
func (c *ClientWithResponses) GetGpoEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityParams, reqEditors ...RequestEditorFn) (*GetGpoEntityResponse, error) {
	rsp, err := c.GetGpoEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityResponse(rsp)
}

// GetGpoEntityComputersWithResponse request returning *GetGpoEntityComputersResponse
func (c *ClientWithResponses) GetGpoEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityComputersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityComputersResponse, error) {
	rsp, err := c.GetGpoEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityComputersResponse(rsp)
}

// GetGpoEntityControllersWithResponse request returning *GetGpoEntityControllersResponse
func (c *ClientWithResponses) GetGpoEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityControllersResponse, error) {
	rsp, err := c.GetGpoEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityControllersResponse(rsp)
}

// GetGpoEntityOusWithResponse request returning *GetGpoEntityOusResponse
func (c *ClientWithResponses) GetGpoEntityOusWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityOusParams, reqEditors ...RequestEditorFn) (*GetGpoEntityOusResponse, error) {
	rsp, err := c.GetGpoEntityOus(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityOusResponse(rsp)
}

// GetGpoEntityTierZeroWithResponse request returning *GetGpoEntityTierZeroResponse
func (c *ClientWithResponses) GetGpoEntityTierZeroWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityTierZeroParams, reqEditors ...RequestEditorFn) (*GetGpoEntityTierZeroResponse, error) {
	rsp, err := c.GetGpoEntityTierZero(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityTierZeroResponse(rsp)
}

// GetGpoEntityUsersWithResponse request returning *GetGpoEntityUsersResponse
func (c *ClientWithResponses) GetGpoEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGpoEntityUsersParams, reqEditors ...RequestEditorFn) (*GetGpoEntityUsersResponse, error) {
	rsp, err := c.GetGpoEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGpoEntityUsersResponse(rsp)
}

// GetSearchResultWithResponse request returning *GetSearchResultResponse
func (c *ClientWithResponses) GetSearchResultWithResponse(ctx context.Context, params *GetSearchResultParams, reqEditors ...RequestEditorFn) (*GetSearchResultResponse, error) {
	rsp, err := c.GetSearchResult(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultResponse(rsp)
}

// RunCypherQueryWithBodyWithResponse request with arbitrary body returning *RunCypherQueryResponse
func (c *ClientWithResponses) RunCypherQueryWithBodyWithResponse(ctx context.Context, params *RunCypherQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error) {
	rsp, err := c.RunCypherQueryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunCypherQueryResponse(rsp)
}

func (c *ClientWithResponses) RunCypherQueryWithResponse(ctx context.Context, params *RunCypherQueryParams, body RunCypherQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunCypherQueryResponse, error) {
	rsp, err := c.RunCypherQuery(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunCypherQueryResponse(rsp)
}

// GetPathCompositionWithResponse request returning *GetPathCompositionResponse
func (c *ClientWithResponses) GetPathCompositionWithResponse(ctx context.Context, params *GetPathCompositionParams, reqEditors ...RequestEditorFn) (*GetPathCompositionResponse, error) {
	rsp, err := c.GetPathComposition(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPathCompositionResponse(rsp)
}

// GetShortestPathWithResponse request returning *GetShortestPathResponse
func (c *ClientWithResponses) GetShortestPathWithResponse(ctx context.Context, params *GetShortestPathParams, reqEditors ...RequestEditorFn) (*GetShortestPathResponse, error) {
	rsp, err := c.GetShortestPath(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShortestPathResponse(rsp)
}

// GetGroupEntityWithResponse request returning *GetGroupEntityResponse
func (c *ClientWithResponses) GetGroupEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityParams, reqEditors ...RequestEditorFn) (*GetGroupEntityResponse, error) {
	rsp, err := c.GetGroupEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityResponse(rsp)
}

// GetGroupEntityAdminRightsWithResponse request returning *GetGroupEntityAdminRightsResponse
func (c *ClientWithResponses) GetGroupEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityAdminRightsResponse, error) {
	rsp, err := c.GetGroupEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityAdminRightsResponse(rsp)
}

// GetGroupEntityControllablesWithResponse request returning *GetGroupEntityControllablesResponse
func (c *ClientWithResponses) GetGroupEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllablesResponse, error) {
	rsp, err := c.GetGroupEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityControllablesResponse(rsp)
}

// GetGroupEntityControllersWithResponse request returning *GetGroupEntityControllersResponse
func (c *ClientWithResponses) GetGroupEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityControllersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityControllersResponse, error) {
	rsp, err := c.GetGroupEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityControllersResponse(rsp)
}

// GetGroupEntityDcomRightsWithResponse request returning *GetGroupEntityDcomRightsResponse
func (c *ClientWithResponses) GetGroupEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityDcomRightsResponse, error) {
	rsp, err := c.GetGroupEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityDcomRightsResponse(rsp)
}

// GetGroupEntityMembersWithResponse request returning *GetGroupEntityMembersResponse
func (c *ClientWithResponses) GetGroupEntityMembersWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembersParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembersResponse, error) {
	rsp, err := c.GetGroupEntityMembers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityMembersResponse(rsp)
}

// GetGroupEntityMembershipsWithResponse request returning *GetGroupEntityMembershipsResponse
func (c *ClientWithResponses) GetGroupEntityMembershipsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityMembershipsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityMembershipsResponse, error) {
	rsp, err := c.GetGroupEntityMemberships(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityMembershipsResponse(rsp)
}

// GetGroupEntityPsRemoteRightsWithResponse request returning *GetGroupEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetGroupEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetGroupEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityPsRemoteRightsResponse(rsp)
}

// GetGroupEntityRdpRightsWithResponse request returning *GetGroupEntityRdpRightsResponse
func (c *ClientWithResponses) GetGroupEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetGroupEntityRdpRightsResponse, error) {
	rsp, err := c.GetGroupEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntityRdpRightsResponse(rsp)
}

// GetGroupEntitySessionsWithResponse request returning *GetGroupEntitySessionsResponse
func (c *ClientWithResponses) GetGroupEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetGroupEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetGroupEntitySessionsResponse, error) {
	rsp, err := c.GetGroupEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupEntitySessionsResponse(rsp)
}

// IngestDataWithResponse request returning *IngestDataResponse
func (c *ClientWithResponses) IngestDataWithResponse(ctx context.Context, params *IngestDataParams, reqEditors ...RequestEditorFn) (*IngestDataResponse, error) {
	rsp, err := c.IngestData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestDataResponse(rsp)
}

// GetClientJobsWithResponse request returning *GetClientJobsResponse
func (c *ClientWithResponses) GetClientJobsWithResponse(ctx context.Context, params *GetClientJobsParams, reqEditors ...RequestEditorFn) (*GetClientJobsResponse, error) {
	rsp, err := c.GetClientJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobsResponse(rsp)
}

// ListAvailableClientJobsWithResponse request returning *ListAvailableClientJobsResponse
func (c *ClientWithResponses) ListAvailableClientJobsWithResponse(ctx context.Context, params *ListAvailableClientJobsParams, reqEditors ...RequestEditorFn) (*ListAvailableClientJobsResponse, error) {
	rsp, err := c.ListAvailableClientJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableClientJobsResponse(rsp)
}

// GetClientCurrentJobWithResponse request returning *GetClientCurrentJobResponse
func (c *ClientWithResponses) GetClientCurrentJobWithResponse(ctx context.Context, params *GetClientCurrentJobParams, reqEditors ...RequestEditorFn) (*GetClientCurrentJobResponse, error) {
	rsp, err := c.GetClientCurrentJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientCurrentJobResponse(rsp)
}

// EndClientJobWithResponse request returning *EndClientJobResponse
func (c *ClientWithResponses) EndClientJobWithResponse(ctx context.Context, params *EndClientJobParams, reqEditors ...RequestEditorFn) (*EndClientJobResponse, error) {
	rsp, err := c.EndClientJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndClientJobResponse(rsp)
}

// ListClientFinishedJobsWithResponse request returning *ListClientFinishedJobsResponse
func (c *ClientWithResponses) ListClientFinishedJobsWithResponse(ctx context.Context, params *ListClientFinishedJobsParams, reqEditors ...RequestEditorFn) (*ListClientFinishedJobsResponse, error) {
	rsp, err := c.ListClientFinishedJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientFinishedJobsResponse(rsp)
}

// StartClientJobWithBodyWithResponse request with arbitrary body returning *StartClientJobResponse
func (c *ClientWithResponses) StartClientJobWithBodyWithResponse(ctx context.Context, params *StartClientJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error) {
	rsp, err := c.StartClientJobWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartClientJobResponse(rsp)
}

func (c *ClientWithResponses) StartClientJobWithResponse(ctx context.Context, params *StartClientJobParams, body StartClientJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StartClientJobResponse, error) {
	rsp, err := c.StartClientJob(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartClientJobResponse(rsp)
}

// GetClientJobWithResponse request returning *GetClientJobResponse
func (c *ClientWithResponses) GetClientJobWithResponse(ctx context.Context, jobId int64, params *GetClientJobParams, reqEditors ...RequestEditorFn) (*GetClientJobResponse, error) {
	rsp, err := c.GetClientJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobResponse(rsp)
}

// CancelClientJobWithResponse request returning *CancelClientJobResponse
func (c *ClientWithResponses) CancelClientJobWithResponse(ctx context.Context, jobId int64, params *CancelClientJobParams, reqEditors ...RequestEditorFn) (*CancelClientJobResponse, error) {
	rsp, err := c.CancelClientJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelClientJobResponse(rsp)
}

// GetClientJobLogWithResponse request returning *GetClientJobLogResponse
func (c *ClientWithResponses) GetClientJobLogWithResponse(ctx context.Context, jobId int64, params *GetClientJobLogParams, reqEditors ...RequestEditorFn) (*GetClientJobLogResponse, error) {
	rsp, err := c.GetClientJobLog(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientJobLogResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, params *LoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, params *LoginParams, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// GetLatestTierZeroComboNodeWithResponse request returning *GetLatestTierZeroComboNodeResponse
func (c *ClientWithResponses) GetLatestTierZeroComboNodeWithResponse(ctx context.Context, domainId string, params *GetLatestTierZeroComboNodeParams, reqEditors ...RequestEditorFn) (*GetLatestTierZeroComboNodeResponse, error) {
	rsp, err := c.GetLatestTierZeroComboNode(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestTierZeroComboNodeResponse(rsp)
}

// GetComboTreeGraphWithResponse request returning *GetComboTreeGraphResponse
func (c *ClientWithResponses) GetComboTreeGraphWithResponse(ctx context.Context, domainId string, params *GetComboTreeGraphParams, reqEditors ...RequestEditorFn) (*GetComboTreeGraphResponse, error) {
	rsp, err := c.GetComboTreeGraph(ctx, domainId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComboTreeGraphResponse(rsp)
}

// GetMetaEntityWithResponse request returning *GetMetaEntityResponse
func (c *ClientWithResponses) GetMetaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetMetaEntityParams, reqEditors ...RequestEditorFn) (*GetMetaEntityResponse, error) {
	rsp, err := c.GetMetaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetaEntityResponse(rsp)
}

// GetNtAuthStoreEntityWithResponse request returning *GetNtAuthStoreEntityResponse
func (c *ClientWithResponses) GetNtAuthStoreEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityResponse, error) {
	rsp, err := c.GetNtAuthStoreEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNtAuthStoreEntityResponse(rsp)
}

// GetNtAuthStoreEntityControllersWithResponse request returning *GetNtAuthStoreEntityControllersResponse
func (c *ClientWithResponses) GetNtAuthStoreEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetNtAuthStoreEntityControllersParams, reqEditors ...RequestEditorFn) (*GetNtAuthStoreEntityControllersResponse, error) {
	rsp, err := c.GetNtAuthStoreEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNtAuthStoreEntityControllersResponse(rsp)
}

// GetOuEntityWithResponse request returning *GetOuEntityResponse
func (c *ClientWithResponses) GetOuEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityParams, reqEditors ...RequestEditorFn) (*GetOuEntityResponse, error) {
	rsp, err := c.GetOuEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityResponse(rsp)
}

// GetOuEntityComputersWithResponse request returning *GetOuEntityComputersResponse
func (c *ClientWithResponses) GetOuEntityComputersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityComputersParams, reqEditors ...RequestEditorFn) (*GetOuEntityComputersResponse, error) {
	rsp, err := c.GetOuEntityComputers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityComputersResponse(rsp)
}

// GetOuEntityGposWithResponse request returning *GetOuEntityGposResponse
func (c *ClientWithResponses) GetOuEntityGposWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGposParams, reqEditors ...RequestEditorFn) (*GetOuEntityGposResponse, error) {
	rsp, err := c.GetOuEntityGpos(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityGposResponse(rsp)
}

// GetOuEntityGroupsWithResponse request returning *GetOuEntityGroupsResponse
func (c *ClientWithResponses) GetOuEntityGroupsWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityGroupsParams, reqEditors ...RequestEditorFn) (*GetOuEntityGroupsResponse, error) {
	rsp, err := c.GetOuEntityGroups(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityGroupsResponse(rsp)
}

// GetOuEntityUsersWithResponse request returning *GetOuEntityUsersResponse
func (c *ClientWithResponses) GetOuEntityUsersWithResponse(ctx context.Context, objectId PathObjectId, params *GetOuEntityUsersParams, reqEditors ...RequestEditorFn) (*GetOuEntityUsersResponse, error) {
	rsp, err := c.GetOuEntityUsers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOuEntityUsersResponse(rsp)
}

// PathfindingWithResponse request returning *PathfindingResponse
func (c *ClientWithResponses) PathfindingWithResponse(ctx context.Context, params *PathfindingParams, reqEditors ...RequestEditorFn) (*PathfindingResponse, error) {
	rsp, err := c.Pathfinding(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePathfindingResponse(rsp)
}

// ListPermissionsWithResponse request returning *ListPermissionsResponse
func (c *ClientWithResponses) ListPermissionsWithResponse(ctx context.Context, params *ListPermissionsParams, reqEditors ...RequestEditorFn) (*ListPermissionsResponse, error) {
	rsp, err := c.ListPermissions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsResponse(rsp)
}

// GetPermissionWithResponse request returning *GetPermissionResponse
func (c *ClientWithResponses) GetPermissionWithResponse(ctx context.Context, permissionId int32, params *GetPermissionParams, reqEditors ...RequestEditorFn) (*GetPermissionResponse, error) {
	rsp, err := c.GetPermission(ctx, permissionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionResponse(rsp)
}

// GetPlatformDataQualityAggregateWithResponse request returning *GetPlatformDataQualityAggregateResponse
func (c *ClientWithResponses) GetPlatformDataQualityAggregateWithResponse(ctx context.Context, platformId string, params *GetPlatformDataQualityAggregateParams, reqEditors ...RequestEditorFn) (*GetPlatformDataQualityAggregateResponse, error) {
	rsp, err := c.GetPlatformDataQualityAggregate(ctx, platformId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformDataQualityAggregateResponse(rsp)
}

// GetPostureStatsWithResponse request returning *GetPostureStatsResponse
func (c *ClientWithResponses) GetPostureStatsWithResponse(ctx context.Context, params *GetPostureStatsParams, reqEditors ...RequestEditorFn) (*GetPostureStatsResponse, error) {
	rsp, err := c.GetPostureStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostureStatsResponse(rsp)
}

// ListRolesWithResponse request returning *ListRolesResponse
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error) {
	rsp, err := c.ListRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, roleId int32, params *GetRoleParams, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, roleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// GetRootCaEntityWithResponse request returning *GetRootCaEntityResponse
func (c *ClientWithResponses) GetRootCaEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityResponse, error) {
	rsp, err := c.GetRootCaEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootCaEntityResponse(rsp)
}

// GetRootCaEntityControllersWithResponse request returning *GetRootCaEntityControllersResponse
func (c *ClientWithResponses) GetRootCaEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetRootCaEntityControllersParams, reqEditors ...RequestEditorFn) (*GetRootCaEntityControllersResponse, error) {
	rsp, err := c.GetRootCaEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootCaEntityControllersResponse(rsp)
}

// ListSamlProvidersWithResponse request returning *ListSamlProvidersResponse
func (c *ClientWithResponses) ListSamlProvidersWithResponse(ctx context.Context, params *ListSamlProvidersParams, reqEditors ...RequestEditorFn) (*ListSamlProvidersResponse, error) {
	rsp, err := c.ListSamlProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSamlProvidersResponse(rsp)
}

// CreateSamlProviderWithBodyWithResponse request with arbitrary body returning *CreateSamlProviderResponse
func (c *ClientWithResponses) CreateSamlProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSamlProviderResponse, error) {
	rsp, err := c.CreateSamlProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSamlProviderResponse(rsp)
}

// DeleteSamlProviderWithResponse request returning *DeleteSamlProviderResponse
func (c *ClientWithResponses) DeleteSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *DeleteSamlProviderParams, reqEditors ...RequestEditorFn) (*DeleteSamlProviderResponse, error) {
	rsp, err := c.DeleteSamlProvider(ctx, samlProviderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSamlProviderResponse(rsp)
}

// GetSamlProviderWithResponse request returning *GetSamlProviderResponse
func (c *ClientWithResponses) GetSamlProviderWithResponse(ctx context.Context, samlProviderId int32, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*GetSamlProviderResponse, error) {
	rsp, err := c.GetSamlProvider(ctx, samlProviderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlProviderResponse(rsp)
}

// GetSamlSignSignOnEndpointsWithResponse request returning *GetSamlSignSignOnEndpointsResponse
func (c *ClientWithResponses) GetSamlSignSignOnEndpointsWithResponse(ctx context.Context, params *GetSamlSignSignOnEndpointsParams, reqEditors ...RequestEditorFn) (*GetSamlSignSignOnEndpointsResponse, error) {
	rsp, err := c.GetSamlSignSignOnEndpoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlSignSignOnEndpointsResponse(rsp)
}

// ListSavedQueriesWithResponse request returning *ListSavedQueriesResponse
func (c *ClientWithResponses) ListSavedQueriesWithResponse(ctx context.Context, params *ListSavedQueriesParams, reqEditors ...RequestEditorFn) (*ListSavedQueriesResponse, error) {
	rsp, err := c.ListSavedQueries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSavedQueriesResponse(rsp)
}

// CreateSavedQueryWithBodyWithResponse request with arbitrary body returning *CreateSavedQueryResponse
func (c *ClientWithResponses) CreateSavedQueryWithBodyWithResponse(ctx context.Context, params *CreateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error) {
	rsp, err := c.CreateSavedQueryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSavedQueryResponse(rsp)
}

func (c *ClientWithResponses) CreateSavedQueryWithResponse(ctx context.Context, params *CreateSavedQueryParams, body CreateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSavedQueryResponse, error) {
	rsp, err := c.CreateSavedQuery(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSavedQueryResponse(rsp)
}

// DeleteSavedQueryWithResponse request returning *DeleteSavedQueryResponse
func (c *ClientWithResponses) DeleteSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryParams, reqEditors ...RequestEditorFn) (*DeleteSavedQueryResponse, error) {
	rsp, err := c.DeleteSavedQuery(ctx, savedQueryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryResponse(rsp)
}

// UpdateSavedQueryWithBodyWithResponse request with arbitrary body returning *UpdateSavedQueryResponse
func (c *ClientWithResponses) UpdateSavedQueryWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error) {
	rsp, err := c.UpdateSavedQueryWithBody(ctx, savedQueryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSavedQueryResponse(rsp)
}

func (c *ClientWithResponses) UpdateSavedQueryWithResponse(ctx context.Context, savedQueryId int32, params *UpdateSavedQueryParams, body UpdateSavedQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSavedQueryResponse, error) {
	rsp, err := c.UpdateSavedQuery(ctx, savedQueryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSavedQueryResponse(rsp)
}

// DeleteSavedQueryPermissionsWithBodyWithResponse request with arbitrary body returning *DeleteSavedQueryPermissionsResponse
func (c *ClientWithResponses) DeleteSavedQueryPermissionsWithBodyWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error) {
	rsp, err := c.DeleteSavedQueryPermissionsWithBody(ctx, savedQueryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryPermissionsResponse(rsp)
}

func (c *ClientWithResponses) DeleteSavedQueryPermissionsWithResponse(ctx context.Context, savedQueryId int32, params *DeleteSavedQueryPermissionsParams, body DeleteSavedQueryPermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSavedQueryPermissionsResponse, error) {
	rsp, err := c.DeleteSavedQueryPermissions(ctx, savedQueryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryPermissionsResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// GetSelfWithResponse request returning *GetSelfResponse
func (c *ClientWithResponses) GetSelfWithResponse(ctx context.Context, params *GetSelfParams, reqEditors ...RequestEditorFn) (*GetSelfResponse, error) {
	rsp, err := c.GetSelf(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelfResponse(rsp)
}

// GetApiSpecWithResponse request returning *GetApiSpecResponse
func (c *ClientWithResponses) GetApiSpecWithResponse(ctx context.Context, params *GetApiSpecParams, reqEditors ...RequestEditorFn) (*GetApiSpecResponse, error) {
	rsp, err := c.GetApiSpec(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiSpecResponse(rsp)
}

// ListAuthTokensWithResponse request returning *ListAuthTokensResponse
func (c *ClientWithResponses) ListAuthTokensWithResponse(ctx context.Context, params *ListAuthTokensParams, reqEditors ...RequestEditorFn) (*ListAuthTokensResponse, error) {
	rsp, err := c.ListAuthTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuthTokensResponse(rsp)
}

// CreateAuthTokenWithBodyWithResponse request with arbitrary body returning *CreateAuthTokenResponse
func (c *ClientWithResponses) CreateAuthTokenWithBodyWithResponse(ctx context.Context, params *CreateAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error) {
	rsp, err := c.CreateAuthTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateAuthTokenWithResponse(ctx context.Context, params *CreateAuthTokenParams, body CreateAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenResponse, error) {
	rsp, err := c.CreateAuthToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenResponse(rsp)
}

// DeleteAuthTokenWithResponse request returning *DeleteAuthTokenResponse
func (c *ClientWithResponses) DeleteAuthTokenWithResponse(ctx context.Context, tokenId openapi_types.UUID, params *DeleteAuthTokenParams, reqEditors ...RequestEditorFn) (*DeleteAuthTokenResponse, error) {
	rsp, err := c.DeleteAuthToken(ctx, tokenId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthTokenResponse(rsp)
}

// GetUserEntityWithResponse request returning *GetUserEntityResponse
func (c *ClientWithResponses) GetUserEntityWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityParams, reqEditors ...RequestEditorFn) (*GetUserEntityResponse, error) {
	rsp, err := c.GetUserEntity(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityResponse(rsp)
}

// GetUserEntityAdminRightsWithResponse request returning *GetUserEntityAdminRightsResponse
func (c *ClientWithResponses) GetUserEntityAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityAdminRightsResponse, error) {
	rsp, err := c.GetUserEntityAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityAdminRightsResponse(rsp)
}

// GetUserEntityConstrainedDelegationRightsWithResponse request returning *GetUserEntityConstrainedDelegationRightsResponse
func (c *ClientWithResponses) GetUserEntityConstrainedDelegationRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityConstrainedDelegationRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityConstrainedDelegationRightsResponse, error) {
	rsp, err := c.GetUserEntityConstrainedDelegationRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityConstrainedDelegationRightsResponse(rsp)
}

// GetUserEntityControllablesWithResponse request returning *GetUserEntityControllablesResponse
func (c *ClientWithResponses) GetUserEntityControllablesWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllablesParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllablesResponse, error) {
	rsp, err := c.GetUserEntityControllables(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityControllablesResponse(rsp)
}

// GetUserEntityControllersWithResponse request returning *GetUserEntityControllersResponse
func (c *ClientWithResponses) GetUserEntityControllersWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityControllersParams, reqEditors ...RequestEditorFn) (*GetUserEntityControllersResponse, error) {
	rsp, err := c.GetUserEntityControllers(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityControllersResponse(rsp)
}

// GetUserEntityDcomRightsWithResponse request returning *GetUserEntityDcomRightsResponse
func (c *ClientWithResponses) GetUserEntityDcomRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityDcomRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityDcomRightsResponse, error) {
	rsp, err := c.GetUserEntityDcomRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityDcomRightsResponse(rsp)
}

// GetUserEntityMembershipWithResponse request returning *GetUserEntityMembershipResponse
func (c *ClientWithResponses) GetUserEntityMembershipWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityMembershipParams, reqEditors ...RequestEditorFn) (*GetUserEntityMembershipResponse, error) {
	rsp, err := c.GetUserEntityMembership(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityMembershipResponse(rsp)
}

// GetUserEntityPsRemoteRightsWithResponse request returning *GetUserEntityPsRemoteRightsResponse
func (c *ClientWithResponses) GetUserEntityPsRemoteRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityPsRemoteRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityPsRemoteRightsResponse, error) {
	rsp, err := c.GetUserEntityPsRemoteRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityPsRemoteRightsResponse(rsp)
}

// GetUserEntityRdpRightsWithResponse request returning *GetUserEntityRdpRightsResponse
func (c *ClientWithResponses) GetUserEntityRdpRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntityRdpRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntityRdpRightsResponse, error) {
	rsp, err := c.GetUserEntityRdpRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntityRdpRightsResponse(rsp)
}

// GetUserEntitySessionsWithResponse request returning *GetUserEntitySessionsResponse
func (c *ClientWithResponses) GetUserEntitySessionsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySessionsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySessionsResponse, error) {
	rsp, err := c.GetUserEntitySessions(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntitySessionsResponse(rsp)
}

// GetUserEntitySqlAdminRightsWithResponse request returning *GetUserEntitySqlAdminRightsResponse
func (c *ClientWithResponses) GetUserEntitySqlAdminRightsWithResponse(ctx context.Context, objectId PathObjectId, params *GetUserEntitySqlAdminRightsParams, reqEditors ...RequestEditorFn) (*GetUserEntitySqlAdminRightsResponse, error) {
	rsp, err := c.GetUserEntitySqlAdminRights(ctx, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserEntitySqlAdminRightsResponse(rsp)
}

// GetApiVersionWithResponse request returning *GetApiVersionResponse
func (c *ClientWithResponses) GetApiVersionWithResponse(ctx context.Context, params *GetApiVersionParams, reqEditors ...RequestEditorFn) (*GetApiVersionResponse, error) {
	rsp, err := c.GetApiVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiVersionResponse(rsp)
}

// ParseAcceptEulaResponse parses an HTTP response from a AcceptEulaWithResponse call
func ParseAcceptEulaResponse(rsp *http.Response) (*AcceptEulaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptEulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAdDomainDataQualityStatsResponse parses an HTTP response from a GetAdDomainDataQualityStatsWithResponse call
func ParseGetAdDomainDataQualityStatsResponse(rsp *http.Response) (*GetAdDomainDataQualityStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdDomainDataQualityStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                      `json:"count,omitempty"`
			Data  *[]ModelAdDataQualityStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiaCaEntityResponse parses an HTTP response from a GetAiaCaEntityWithResponse call
func ParseGetAiaCaEntityResponse(rsp *http.Response) (*GetAiaCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiaCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAiaCaEntityControllersResponse parses an HTTP response from a GetAiaCaEntityControllersWithResponse call
func ParseGetAiaCaEntityControllersResponse(rsp *http.Response) (*GetAiaCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAiaCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartAnalysisResponse parses an HTTP response from a StartAnalysisWithResponse call
func ParseStartAnalysisResponse(rsp *http.Response) (*StartAnalysisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartAnalysisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListAssetGroupsResponse parses an HTTP response from a ListAssetGroupsWithResponse call
func ParseListAssetGroupsResponse(rsp *http.Response) (*ListAssetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AssetGroups *[]ModelAssetGroup `json:"asset_groups,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAssetGroupResponse parses an HTTP response from a CreateAssetGroupWithResponse call
func ParseCreateAssetGroupResponse(rsp *http.Response) (*CreateAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAssetGroupResponse parses an HTTP response from a DeleteAssetGroupWithResponse call
func ParseDeleteAssetGroupResponse(rsp *http.Response) (*DeleteAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupResponse parses an HTTP response from a GetAssetGroupWithResponse call
func ParseGetAssetGroupResponse(rsp *http.Response) (*GetAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupResponse parses an HTTP response from a UpdateAssetGroupWithResponse call
func ParseUpdateAssetGroupResponse(rsp *http.Response) (*UpdateAssetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAssetGroup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupCollectionsResponse parses an HTTP response from a ListAssetGroupCollectionsWithResponse call
func ParseListAssetGroupCollectionsResponse(rsp *http.Response) (*ListAssetGroupCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelAssetGroupCollection `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupComboNodeResponse parses an HTTP response from a GetAssetGroupComboNodeWithResponse call
func ParseGetAssetGroupComboNodeResponse(rsp *http.Response) (*GetAssetGroupComboNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupComboNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetGroupCustomMemberCountResponse parses an HTTP response from a GetAssetGroupCustomMemberCountWithResponse call
func ParseGetAssetGroupCustomMemberCountResponse(rsp *http.Response) (*GetAssetGroupCustomMemberCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetGroupCustomMemberCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CustomMemberCount *int `json:"custom_member_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupMembersResponse parses an HTTP response from a ListAssetGroupMembersWithResponse call
func ParseListAssetGroupMembersResponse(rsp *http.Response) (*ListAssetGroupMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int `json:"count,omitempty"`
			Data  *struct {
				Members *[]ModelAssetGroupMember `json:"members,omitempty"`
			} `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAssetGroupMemberCountByKindResponse parses an HTTP response from a ListAssetGroupMemberCountByKindWithResponse call
func ParseListAssetGroupMemberCountByKindResponse(rsp *http.Response) (*ListAssetGroupMemberCountByKindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetGroupMemberCountByKindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Counts     *map[string]int `json:"counts,omitempty"`
				TotalCount *int            `json:"total_count,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupSelectorsDeprecatedResponse parses an HTTP response from a UpdateAssetGroupSelectorsDeprecatedWithResponse call
func ParseUpdateAssetGroupSelectorsDeprecatedResponse(rsp *http.Response) (*UpdateAssetGroupSelectorsDeprecatedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupSelectorsDeprecatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
				RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetGroupSelectorsResponse parses an HTTP response from a UpdateAssetGroupSelectorsWithResponse call
func ParseUpdateAssetGroupSelectorsResponse(rsp *http.Response) (*UpdateAssetGroupSelectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetGroupSelectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *struct {
				AddedSelectors   *[]ModelAssetGroupSelector `json:"added_selectors,omitempty"`
				RemovedSelectors *[]ModelAssetGroupSelector `json:"removed_selectors,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAssetGroupSelectorResponse parses an HTTP response from a DeleteAssetGroupSelectorWithResponse call
func ParseDeleteAssetGroupSelectorResponse(rsp *http.Response) (*DeleteAssetGroupSelectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetGroupSelectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttackPathTypesResponse parses an HTTP response from a ListAttackPathTypesWithResponse call
func ParseListAttackPathTypesResponse(rsp *http.Response) (*ListAttackPathTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttackPathTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartAnalysisBheResponse parses an HTTP response from a StartAnalysisBheWithResponse call
func ParseStartAnalysisBheResponse(rsp *http.Response) (*StartAnalysisBheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartAnalysisBheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAttackPathRiskResponse parses an HTTP response from a UpdateAttackPathRiskWithResponse call
func ParseUpdateAttackPathRiskResponse(rsp *http.Response) (*UpdateAttackPathRiskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAttackPathRiskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseFinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Logs *[]ModelAuditLog `json:"logs,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAvailableDomainsResponse parses an HTTP response from a GetAvailableDomainsWithResponse call
func ParseGetAvailableDomainsResponse(rsp *http.Response) (*GetAvailableDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelDomainSelector `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAzureTenantDataQualityStatsResponse parses an HTTP response from a GetAzureTenantDataQualityStatsWithResponse call
func ParseGetAzureTenantDataQualityStatsResponse(rsp *http.Response) (*GetAzureTenantDataQualityStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAzureTenantDataQualityStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                         `json:"count,omitempty"`
			Data  *[]ModelAzureDataQualityStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAzureEntityResponse parses an HTTP response from a GetAzureEntityWithResponse call
func ParseGetAzureEntityResponse(rsp *http.Response) (*GetAzureEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAzureEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityResponse parses an HTTP response from a GetEntityWithResponse call
func ParseGetEntityResponse(rsp *http.Response) (*GetEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityControllablesResponse parses an HTTP response from a GetEntityControllablesWithResponse call
func ParseGetEntityControllablesResponse(rsp *http.Response) (*GetEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEntityControllersResponse parses an HTTP response from a GetEntityControllersWithResponse call
func ParseGetEntityControllersResponse(rsp *http.Response) (*GetEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Users *[]ModelUser `json:"users,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUser `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUser `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRemoveUserMfaResponse parses an HTTP response from a RemoveUserMfaWithResponse call
func ParseRemoveUserMfaResponse(rsp *http.Response) (*RemoveUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddUserMfaResponse parses an HTTP response from a AddUserMfaWithResponse call
func ParseAddUserMfaResponse(rsp *http.Response) (*AddUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				QrCode     *string `json:"qr_code,omitempty"`
				TotpSecret *string `json:"totp_secret,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMfaActivationStatusResponse parses an HTTP response from a GetMfaActivationStatusWithResponse call
func ParseGetMfaActivationStatusResponse(rsp *http.Response) (*GetMfaActivationStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMfaActivationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseActivateUserMfaResponse parses an HTTP response from a ActivateUserMfaWithResponse call
func ParseActivateUserMfaResponse(rsp *http.Response) (*ActivateUserMfaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateUserMfaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				// Status The activation status of multi-factor authentication on a BloodHound user.
				Status *EnumMfaActivationStatus `json:"status,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserSecretResponse parses an HTTP response from a DeleteUserSecretWithResponse call
func ParseDeleteUserSecretResponse(rsp *http.Response) (*DeleteUserSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrSetUserSecretResponse parses an HTTP response from a CreateOrSetUserSecretWithResponse call
func ParseCreateOrSetUserSecretResponse(rsp *http.Response) (*CreateOrSetUserSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrSetUserSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertTemplateEntityResponse parses an HTTP response from a GetCertTemplateEntityWithResponse call
func ParseGetCertTemplateEntityResponse(rsp *http.Response) (*GetCertTemplateEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertTemplateEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertTemplateEntityControllersResponse parses an HTTP response from a GetCertTemplateEntityControllersWithResponse call
func ParseGetCertTemplateEntityControllersResponse(rsp *http.Response) (*GetCertTemplateEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertTemplateEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBloodHoundDatabaseResponse parses an HTTP response from a DeleteBloodHoundDatabaseWithResponse call
func ParseDeleteBloodHoundDatabaseResponse(rsp *http.Response) (*DeleteBloodHoundDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBloodHoundDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientsResponse parses an HTTP response from a ListClientsWithResponse call
func ParseListClientsResponse(rsp *http.Response) (*ListClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                  `json:"count,omitempty"`
			Data  *[]ModelClientDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientResponse parses an HTTP response from a CreateClientWithResponse call
func ParseCreateClientResponse(rsp *http.Response) (*CreateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogClientErrorResponse parses an HTTP response from a LogClientErrorWithResponse call
func ParseLogClientErrorResponse(rsp *http.Response) (*LogClientErrorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogClientErrorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientInfoResponse parses an HTTP response from a UpdateClientInfoWithResponse call
func ParseUpdateClientInfoResponse(rsp *http.Response) (*UpdateClientInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientResponse parses an HTTP response from a DeleteClientWithResponse call
func ParseDeleteClientResponse(rsp *http.Response) (*DeleteClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientResponse parses an HTTP response from a GetClientWithResponse call
func ParseGetClientResponse(rsp *http.Response) (*GetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientResponse parses an HTTP response from a UpdateClientWithResponse call
func ParseUpdateClientResponse(rsp *http.Response) (*UpdateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClient `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientCompletedJobsResponse parses an HTTP response from a ListClientCompletedJobsWithResponse call
func ParseListClientCompletedJobsResponse(rsp *http.Response) (*ListClientCompletedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientCompletedTasksResponse parses an HTTP response from a ListClientCompletedTasksWithResponse call
func ParseListClientCompletedTasksResponse(rsp *http.Response) (*ListClientCompletedTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientCompletedTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduledJobResponse parses an HTTP response from a CreateClientScheduledJobWithResponse call
func ParseCreateClientScheduledJobResponse(rsp *http.Response) (*CreateClientScheduledJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduledJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduledTaskResponse parses an HTTP response from a CreateClientScheduledTaskWithResponse call
func ParseCreateClientScheduledTaskResponse(rsp *http.Response) (*CreateClientScheduledTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduledTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReplaceClientTokenResponse parses an HTTP response from a ReplaceClientTokenWithResponse call
func ParseReplaceClientTokenResponse(rsp *http.Response) (*ReplaceClientTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceClientTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAuthToken `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorManifestResponse parses an HTTP response from a GetCollectorManifestWithResponse call
func ParseGetCollectorManifestResponse(rsp *http.Response) (*GetCollectorManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelCollectorManifest `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadCollectorResponse parses an HTTP response from a DownloadCollectorWithResponse call
func ParseDownloadCollectorResponse(rsp *http.Response) (*DownloadCollectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadCollectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorChecksumResponse parses an HTTP response from a GetCollectorChecksumWithResponse call
func ParseGetCollectorChecksumResponse(rsp *http.Response) (*GetCollectorChecksumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorChecksumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCompletenessStatsResponse parses an HTTP response from a GetCompletenessStatsWithResponse call
func ParseGetCompletenessStatsResponse(rsp *http.Response) (*GetCompletenessStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletenessStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]float64 `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityResponse parses an HTTP response from a GetComputerEntityWithResponse call
func ParseGetComputerEntityResponse(rsp *http.Response) (*GetComputerEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityAdminRightsResponse parses an HTTP response from a GetComputerEntityAdminRightsWithResponse call
func ParseGetComputerEntityAdminRightsResponse(rsp *http.Response) (*GetComputerEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityAdminsResponse parses an HTTP response from a GetComputerEntityAdminsWithResponse call
func ParseGetComputerEntityAdminsResponse(rsp *http.Response) (*GetComputerEntityAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityConstrainedDelegationRightsResponse parses an HTTP response from a GetComputerEntityConstrainedDelegationRightsWithResponse call
func ParseGetComputerEntityConstrainedDelegationRightsResponse(rsp *http.Response) (*GetComputerEntityConstrainedDelegationRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityConstrainedDelegationRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityConstrainedUsersResponse parses an HTTP response from a GetComputerEntityConstrainedUsersWithResponse call
func ParseGetComputerEntityConstrainedUsersResponse(rsp *http.Response) (*GetComputerEntityConstrainedUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityConstrainedUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityControllablesResponse parses an HTTP response from a GetComputerEntityControllablesWithResponse call
func ParseGetComputerEntityControllablesResponse(rsp *http.Response) (*GetComputerEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityControllersResponse parses an HTTP response from a GetComputerEntityControllersWithResponse call
func ParseGetComputerEntityControllersResponse(rsp *http.Response) (*GetComputerEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityDcomRightsResponse parses an HTTP response from a GetComputerEntityDcomRightsWithResponse call
func ParseGetComputerEntityDcomRightsResponse(rsp *http.Response) (*GetComputerEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityDcomUsersResponse parses an HTTP response from a GetComputerEntityDcomUsersWithResponse call
func ParseGetComputerEntityDcomUsersResponse(rsp *http.Response) (*GetComputerEntityDcomUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityDcomUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityGroupMembershipResponse parses an HTTP response from a GetComputerEntityGroupMembershipWithResponse call
func ParseGetComputerEntityGroupMembershipResponse(rsp *http.Response) (*GetComputerEntityGroupMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityPsRemoteRightsResponse parses an HTTP response from a GetComputerEntityPsRemoteRightsWithResponse call
func ParseGetComputerEntityPsRemoteRightsResponse(rsp *http.Response) (*GetComputerEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityPsRemoteUsersResponse parses an HTTP response from a GetComputerEntityPsRemoteUsersWithResponse call
func ParseGetComputerEntityPsRemoteUsersResponse(rsp *http.Response) (*GetComputerEntityPsRemoteUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityPsRemoteUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityRdpRightsResponse parses an HTTP response from a GetComputerEntityRdpRightsWithResponse call
func ParseGetComputerEntityRdpRightsResponse(rsp *http.Response) (*GetComputerEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntityRdpUsersResponse parses an HTTP response from a GetComputerEntityRdpUsersWithResponse call
func ParseGetComputerEntityRdpUsersResponse(rsp *http.Response) (*GetComputerEntityRdpUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntityRdpUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntitySessionsResponse parses an HTTP response from a GetComputerEntitySessionsWithResponse call
func ParseGetComputerEntitySessionsResponse(rsp *http.Response) (*GetComputerEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComputerEntitySqlAdminsResponse parses an HTTP response from a GetComputerEntitySqlAdminsWithResponse call
func ParseGetComputerEntitySqlAdminsResponse(rsp *http.Response) (*GetComputerEntitySqlAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComputerEntitySqlAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAppConfigParamsResponse parses an HTTP response from a ListAppConfigParamsWithResponse call
func ParseListAppConfigParamsResponse(rsp *http.Response) (*ListAppConfigParamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppConfigParamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelAppConfigParam `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetAppConfigParamResponse parses an HTTP response from a SetAppConfigParamWithResponse call
func ParseSetAppConfigParamResponse(rsp *http.Response) (*SetAppConfigParamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAppConfigParamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Key   *string                 `json:"key,omitempty"`
				Value *map[string]interface{} `json:"value,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContainerEntityResponse parses an HTTP response from a GetContainerEntityWithResponse call
func ParseGetContainerEntityResponse(rsp *http.Response) (*GetContainerEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContainerEntityControllersResponse parses an HTTP response from a GetContainerEntityControllersWithResponse call
func ParseGetContainerEntityControllersResponse(rsp *http.Response) (*GetContainerEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatapipeStatusResponse parses an HTTP response from a GetDatapipeStatusWithResponse call
func ParseGetDatapipeStatusResponse(rsp *http.Response) (*GetDatapipeStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatapipeStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				LastCompleteAnalysisAt *time.Time          `json:"last_complete_analysis_at,omitempty"`
				Status                 *EnumDatapipeStatus `json:"status,omitempty"`
				UpdatedAt              *time.Time          `json:"updated_at,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseExportAttackPathFindingsResponse parses an HTTP response from a ExportAttackPathFindingsWithResponse call
func ParseExportAttackPathFindingsResponse(rsp *http.Response) (*ExportAttackPathFindingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportAttackPathFindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableAttackPathTypesForDomainResponse parses an HTTP response from a ListAvailableAttackPathTypesForDomainWithResponse call
func ParseListAvailableAttackPathTypesForDomainResponse(rsp *http.Response) (*ListAvailableAttackPathTypesForDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableAttackPathTypesForDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDomainAttackPathsDetailsResponse parses an HTTP response from a ListDomainAttackPathsDetailsWithResponse call
func ParseListDomainAttackPathsDetailsResponse(rsp *http.Response) (*ListDomainAttackPathsDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDomainAttackPathsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAttackPathSparklineValuesResponse parses an HTTP response from a ListAttackPathSparklineValuesWithResponse call
func ParseListAttackPathSparklineValuesResponse(rsp *http.Response) (*ListAttackPathSparklineValuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAttackPathSparklineValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelRiskCounts `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityResponse parses an HTTP response from a GetDomainEntityWithResponse call
func ParseGetDomainEntityResponse(rsp *http.Response) (*GetDomainEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDomainEntityResponse parses an HTTP response from a UpdateDomainEntityWithResponse call
func ParseUpdateDomainEntityResponse(rsp *http.Response) (*UpdateDomainEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDomainEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Collected *bool `json:"collected,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityComputersResponse parses an HTTP response from a GetDomainEntityComputersWithResponse call
func ParseGetDomainEntityComputersResponse(rsp *http.Response) (*GetDomainEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityControllersResponse parses an HTTP response from a GetDomainEntityControllersWithResponse call
func ParseGetDomainEntityControllersResponse(rsp *http.Response) (*GetDomainEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityDcSyncersResponse parses an HTTP response from a GetDomainEntityDcSyncersWithResponse call
func ParseGetDomainEntityDcSyncersResponse(rsp *http.Response) (*GetDomainEntityDcSyncersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityDcSyncersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignAdminsResponse parses an HTTP response from a GetDomainEntityForeignAdminsWithResponse call
func ParseGetDomainEntityForeignAdminsResponse(rsp *http.Response) (*GetDomainEntityForeignAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignGpoControllersResponse parses an HTTP response from a GetDomainEntityForeignGpoControllersWithResponse call
func ParseGetDomainEntityForeignGpoControllersResponse(rsp *http.Response) (*GetDomainEntityForeignGpoControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignGpoControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignGroupsResponse parses an HTTP response from a GetDomainEntityForeignGroupsWithResponse call
func ParseGetDomainEntityForeignGroupsResponse(rsp *http.Response) (*GetDomainEntityForeignGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityForeignUsersResponse parses an HTTP response from a GetDomainEntityForeignUsersWithResponse call
func ParseGetDomainEntityForeignUsersResponse(rsp *http.Response) (*GetDomainEntityForeignUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityForeignUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityGposResponse parses an HTTP response from a GetDomainEntityGposWithResponse call
func ParseGetDomainEntityGposResponse(rsp *http.Response) (*GetDomainEntityGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityGroupsResponse parses an HTTP response from a GetDomainEntityGroupsWithResponse call
func ParseGetDomainEntityGroupsResponse(rsp *http.Response) (*GetDomainEntityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityInboundTrustsResponse parses an HTTP response from a GetDomainEntityInboundTrustsWithResponse call
func ParseGetDomainEntityInboundTrustsResponse(rsp *http.Response) (*GetDomainEntityInboundTrustsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityInboundTrustsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityLinkedGposResponse parses an HTTP response from a GetDomainEntityLinkedGposWithResponse call
func ParseGetDomainEntityLinkedGposResponse(rsp *http.Response) (*GetDomainEntityLinkedGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityLinkedGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityOusResponse parses an HTTP response from a GetDomainEntityOusWithResponse call
func ParseGetDomainEntityOusResponse(rsp *http.Response) (*GetDomainEntityOusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityOusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityOutboundTrustsResponse parses an HTTP response from a GetDomainEntityOutboundTrustsWithResponse call
func ParseGetDomainEntityOutboundTrustsResponse(rsp *http.Response) (*GetDomainEntityOutboundTrustsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityOutboundTrustsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDomainEntityUsersResponse parses an HTTP response from a GetDomainEntityUsersWithResponse call
func ParseGetDomainEntityUsersResponse(rsp *http.Response) (*GetDomainEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEnterpriseCaEntityResponse parses an HTTP response from a GetEnterpriseCaEntityWithResponse call
func ParseGetEnterpriseCaEntityResponse(rsp *http.Response) (*GetEnterpriseCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnterpriseCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEnterpriseCaEntityControllersResponse parses an HTTP response from a GetEnterpriseCaEntityControllersWithResponse call
func ParseGetEnterpriseCaEntityControllersResponse(rsp *http.Response) (*GetEnterpriseCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnterpriseCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientSchedulesResponse parses an HTTP response from a ListClientSchedulesWithResponse call
func ParseListClientSchedulesResponse(rsp *http.Response) (*ListClientSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                          `json:"count,omitempty"`
			Data  *[]ModelClientScheduleDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientScheduleResponse parses an HTTP response from a CreateClientScheduleWithResponse call
func ParseCreateClientScheduleResponse(rsp *http.Response) (*CreateClientScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientEventResponse parses an HTTP response from a DeleteClientEventWithResponse call
func ParseDeleteClientEventResponse(rsp *http.Response) (*DeleteClientEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientScheduleResponse parses an HTTP response from a GetClientScheduleWithResponse call
func ParseGetClientScheduleResponse(rsp *http.Response) (*GetClientScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClientEventResponse parses an HTTP response from a UpdateClientEventWithResponse call
func ParseUpdateClientEventResponse(rsp *http.Response) (*UpdateClientEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduleDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFeatureFlagsResponse parses an HTTP response from a ListFeatureFlagsWithResponse call
func ParseListFeatureFlagsResponse(rsp *http.Response) (*ListFeatureFlagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFeatureFlagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelFeatureFlag `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseToggleFeatureFlagResponse parses an HTTP response from a ToggleFeatureFlagWithResponse call
func ParseToggleFeatureFlagResponse(rsp *http.Response) (*ToggleFeatureFlagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleFeatureFlagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFileUploadJobsResponse parses an HTTP response from a ListFileUploadJobsWithResponse call
func ParseListFileUploadJobsResponse(rsp *http.Response) (*ListFileUploadJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFileUploadJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                  `json:"count,omitempty"`
			Data  *[]ModelFileUploadJob `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAcceptedFileUploadTypesResponse parses an HTTP response from a ListAcceptedFileUploadTypesWithResponse call
func ParseListAcceptedFileUploadTypesResponse(rsp *http.Response) (*ListAcceptedFileUploadTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAcceptedFileUploadTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateFileUploadJobResponse parses an HTTP response from a CreateFileUploadJobWithResponse call
func ParseCreateFileUploadJobResponse(rsp *http.Response) (*CreateFileUploadJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFileUploadJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *ModelFileUploadJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadFileToJobResponse parses an HTTP response from a UploadFileToJobWithResponse call
func ParseUploadFileToJobResponse(rsp *http.Response) (*UploadFileToJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFileToJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEndFileUploadJobResponse parses an HTTP response from a EndFileUploadJobWithResponse call
func ParseEndFileUploadJobResponse(rsp *http.Response) (*EndFileUploadJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndFileUploadJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityResponse parses an HTTP response from a GetGpoEntityWithResponse call
func ParseGetGpoEntityResponse(rsp *http.Response) (*GetGpoEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityComputersResponse parses an HTTP response from a GetGpoEntityComputersWithResponse call
func ParseGetGpoEntityComputersResponse(rsp *http.Response) (*GetGpoEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityControllersResponse parses an HTTP response from a GetGpoEntityControllersWithResponse call
func ParseGetGpoEntityControllersResponse(rsp *http.Response) (*GetGpoEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityOusResponse parses an HTTP response from a GetGpoEntityOusWithResponse call
func ParseGetGpoEntityOusResponse(rsp *http.Response) (*GetGpoEntityOusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityOusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityTierZeroResponse parses an HTTP response from a GetGpoEntityTierZeroWithResponse call
func ParseGetGpoEntityTierZeroResponse(rsp *http.Response) (*GetGpoEntityTierZeroResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityTierZeroResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGpoEntityUsersResponse parses an HTTP response from a GetGpoEntityUsersWithResponse call
func ParseGetGpoEntityUsersResponse(rsp *http.Response) (*GetGpoEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGpoEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultResponse parses an HTTP response from a GetSearchResultWithResponse call
func ParseGetSearchResultResponse(rsp *http.Response) (*GetSearchResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRunCypherQueryResponse parses an HTTP response from a RunCypherQueryWithResponse call
func ParseRunCypherQueryResponse(rsp *http.Response) (*RunCypherQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunCypherQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPathCompositionResponse parses an HTTP response from a GetPathCompositionWithResponse call
func ParseGetPathCompositionResponse(rsp *http.Response) (*GetPathCompositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPathCompositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShortestPathResponse parses an HTTP response from a GetShortestPathWithResponse call
func ParseGetShortestPathResponse(rsp *http.Response) (*GetShortestPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShortestPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelUnifiedGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityResponse parses an HTTP response from a GetGroupEntityWithResponse call
func ParseGetGroupEntityResponse(rsp *http.Response) (*GetGroupEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityAdminRightsResponse parses an HTTP response from a GetGroupEntityAdminRightsWithResponse call
func ParseGetGroupEntityAdminRightsResponse(rsp *http.Response) (*GetGroupEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityControllablesResponse parses an HTTP response from a GetGroupEntityControllablesWithResponse call
func ParseGetGroupEntityControllablesResponse(rsp *http.Response) (*GetGroupEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityControllersResponse parses an HTTP response from a GetGroupEntityControllersWithResponse call
func ParseGetGroupEntityControllersResponse(rsp *http.Response) (*GetGroupEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityDcomRightsResponse parses an HTTP response from a GetGroupEntityDcomRightsWithResponse call
func ParseGetGroupEntityDcomRightsResponse(rsp *http.Response) (*GetGroupEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityMembersResponse parses an HTTP response from a GetGroupEntityMembersWithResponse call
func ParseGetGroupEntityMembersResponse(rsp *http.Response) (*GetGroupEntityMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityMembershipsResponse parses an HTTP response from a GetGroupEntityMembershipsWithResponse call
func ParseGetGroupEntityMembershipsResponse(rsp *http.Response) (*GetGroupEntityMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityPsRemoteRightsResponse parses an HTTP response from a GetGroupEntityPsRemoteRightsWithResponse call
func ParseGetGroupEntityPsRemoteRightsResponse(rsp *http.Response) (*GetGroupEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntityRdpRightsResponse parses an HTTP response from a GetGroupEntityRdpRightsWithResponse call
func ParseGetGroupEntityRdpRightsResponse(rsp *http.Response) (*GetGroupEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupEntitySessionsResponse parses an HTTP response from a GetGroupEntitySessionsWithResponse call
func ParseGetGroupEntitySessionsResponse(rsp *http.Response) (*GetGroupEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIngestDataResponse parses an HTTP response from a IngestDataWithResponse call
func ParseIngestDataResponse(rsp *http.Response) (*IngestDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IngestDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobsResponse parses an HTTP response from a GetClientJobsWithResponse call
func ParseGetClientJobsResponse(rsp *http.Response) (*GetClientJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAvailableClientJobsResponse parses an HTTP response from a ListAvailableClientJobsWithResponse call
func ParseListAvailableClientJobsResponse(rsp *http.Response) (*ListAvailableClientJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableClientJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientCurrentJobResponse parses an HTTP response from a GetClientCurrentJobWithResponse call
func ParseGetClientCurrentJobResponse(rsp *http.Response) (*GetClientCurrentJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientCurrentJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEndClientJobResponse parses an HTTP response from a EndClientJobWithResponse call
func ParseEndClientJobResponse(rsp *http.Response) (*EndClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListClientFinishedJobsResponse parses an HTTP response from a ListClientFinishedJobsWithResponse call
func ParseListClientFinishedJobsResponse(rsp *http.Response) (*ListClientFinishedJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientFinishedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                              `json:"count,omitempty"`
			Data  *[]ModelClientScheduledJobDisplay `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartClientJobResponse parses an HTTP response from a StartClientJobWithResponse call
func ParseStartClientJobResponse(rsp *http.Response) (*StartClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJob `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobResponse parses an HTTP response from a GetClientJobWithResponse call
func ParseGetClientJobResponse(rsp *http.Response) (*GetClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelClientJobResponse parses an HTTP response from a CancelClientJobWithResponse call
func ParseCancelClientJobResponse(rsp *http.Response) (*CancelClientJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelClientJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelClientScheduledJobDisplay `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClientJobLogResponse parses an HTTP response from a GetClientJobLogWithResponse call
func ParseGetClientJobLogResponse(rsp *http.Response) (*GetClientJobLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientJobLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Log *string `json:"log,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AuthExpired  *bool               `json:"auth_expired,omitempty"`
				SessionToken *string             `json:"session_token,omitempty"`
				UserId       *openapi_types.UUID `json:"user_id,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetLatestTierZeroComboNodeResponse parses an HTTP response from a GetLatestTierZeroComboNodeWithResponse call
func ParseGetLatestTierZeroComboNodeResponse(rsp *http.Response) (*GetLatestTierZeroComboNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestTierZeroComboNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *map[string]ModelBhGraphNode `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetComboTreeGraphResponse parses an HTTP response from a GetComboTreeGraphWithResponse call
func ParseGetComboTreeGraphResponse(rsp *http.Response) (*GetComboTreeGraphResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComboTreeGraphResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMetaEntityResponse parses an HTTP response from a GetMetaEntityWithResponse call
func ParseGetMetaEntityResponse(rsp *http.Response) (*GetMetaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Props *map[string]map[string]interface{} `json:"props,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNtAuthStoreEntityResponse parses an HTTP response from a GetNtAuthStoreEntityWithResponse call
func ParseGetNtAuthStoreEntityResponse(rsp *http.Response) (*GetNtAuthStoreEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNtAuthStoreEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNtAuthStoreEntityControllersResponse parses an HTTP response from a GetNtAuthStoreEntityControllersWithResponse call
func ParseGetNtAuthStoreEntityControllersResponse(rsp *http.Response) (*GetNtAuthStoreEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNtAuthStoreEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityResponse parses an HTTP response from a GetOuEntityWithResponse call
func ParseGetOuEntityResponse(rsp *http.Response) (*GetOuEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityComputersResponse parses an HTTP response from a GetOuEntityComputersWithResponse call
func ParseGetOuEntityComputersResponse(rsp *http.Response) (*GetOuEntityComputersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityComputersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityGposResponse parses an HTTP response from a GetOuEntityGposWithResponse call
func ParseGetOuEntityGposResponse(rsp *http.Response) (*GetOuEntityGposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityGposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityGroupsResponse parses an HTTP response from a GetOuEntityGroupsWithResponse call
func ParseGetOuEntityGroupsResponse(rsp *http.Response) (*GetOuEntityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOuEntityUsersResponse parses an HTTP response from a GetOuEntityUsersWithResponse call
func ParseGetOuEntityUsersResponse(rsp *http.Response) (*GetOuEntityUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOuEntityUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePathfindingResponse parses an HTTP response from a PathfindingWithResponse call
func ParsePathfindingResponse(rsp *http.Response) (*PathfindingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PathfindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelBhGraphGraph `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsResponse parses an HTTP response from a ListPermissionsWithResponse call
func ParseListPermissionsResponse(rsp *http.Response) (*ListPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Permissions *[]ModelPermission `json:"permissions,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionResponse parses an HTTP response from a GetPermissionWithResponse call
func ParseGetPermissionResponse(rsp *http.Response) (*GetPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelPermission `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlatformDataQualityAggregateResponse parses an HTTP response from a GetPlatformDataQualityAggregateWithResponse call
func ParseGetPlatformDataQualityAggregateResponse(rsp *http.Response) (*GetPlatformDataQualityAggregateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformDataQualityAggregateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseDataQualityPlatformAggregate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPostureStatsResponse parses an HTTP response from a GetPostureStatsWithResponse call
func ParseGetPostureStatsResponse(rsp *http.Response) (*GetPostureStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostureStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int                    `json:"count,omitempty"`
			Data  *[]ModelRiskPostureStat `json:"data,omitempty"`

			// End The RFC-3339 timestamp to describe the end of a time range
			End *time.Time `json:"end,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`

			// Start The RFC-3339 timestamp to describe the beginning of a time range
			Start *time.Time `json:"start,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRolesResponse parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResponse(rsp *http.Response) (*ListRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Roles *[]ModelRole `json:"roles,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelRole `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRootCaEntityResponse parses an HTTP response from a GetRootCaEntityWithResponse call
func ParseGetRootCaEntityResponse(rsp *http.Response) (*GetRootCaEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootCaEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRootCaEntityControllersResponse parses an HTTP response from a GetRootCaEntityControllersWithResponse call
func ParseGetRootCaEntityControllersResponse(rsp *http.Response) (*GetRootCaEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootCaEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSamlProvidersResponse parses an HTTP response from a ListSamlProvidersWithResponse call
func ParseListSamlProvidersResponse(rsp *http.Response) (*ListSamlProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSamlProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				SamlProviders *[]ModelSamlProvider `json:"saml_providers,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSamlProviderResponse parses an HTTP response from a CreateSamlProviderWithResponse call
func ParseCreateSamlProviderResponse(rsp *http.Response) (*CreateSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSamlProvider `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSamlProviderResponse parses an HTTP response from a DeleteSamlProviderWithResponse call
func ParseDeleteSamlProviderResponse(rsp *http.Response) (*DeleteSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AffectedUser *[]ModelUser `json:"affected_user,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiErrorWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSamlProviderResponse parses an HTTP response from a GetSamlProviderWithResponse call
func ParseGetSamlProviderResponse(rsp *http.Response) (*GetSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSamlProvider `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSamlSignSignOnEndpointsResponse parses an HTTP response from a GetSamlSignSignOnEndpointsWithResponse call
func ParseGetSamlSignSignOnEndpointsResponse(rsp *http.Response) (*GetSamlSignSignOnEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlSignSignOnEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Endpoints *[]ModelSamlSignOnEndpoint `json:"endpoints,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSavedQueriesResponse parses an HTTP response from a ListSavedQueriesWithResponse call
func ParseListSavedQueriesResponse(rsp *http.Response) (*ListSavedQueriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSavedQueriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of results.
			Count *int               `json:"count,omitempty"`
			Data  *[]ModelSavedQuery `json:"data,omitempty"`

			// Limit The limit of results requested by the client.
			Limit *ApiParamsQueryLimit `json:"limit,omitempty"`

			// Skip The number of items to skip in a paginated response.
			Skip *ApiParamsQuerySkip `json:"skip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSavedQueryResponse parses an HTTP response from a CreateSavedQueryWithResponse call
func ParseCreateSavedQueryResponse(rsp *http.Response) (*CreateSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data *ModelSavedQuery `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSavedQueryResponse parses an HTTP response from a DeleteSavedQueryWithResponse call
func ParseDeleteSavedQueryResponse(rsp *http.Response) (*DeleteSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSavedQueryResponse parses an HTTP response from a UpdateSavedQueryWithResponse call
func ParseUpdateSavedQueryResponse(rsp *http.Response) (*UpdateSavedQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSavedQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelSavedQuery `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSavedQueryPermissionsResponse parses an HTTP response from a DeleteSavedQueryPermissionsWithResponse call
func ParseDeleteSavedQueryPermissionsResponse(rsp *http.Response) (*DeleteSavedQueryPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSavedQueryPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ModelSearchResult `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSelfResponse parses an HTTP response from a GetSelfWithResponse call
func ParseGetSelfResponse(rsp *http.Response) (*GetSelfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiResponseAuthenticatedRequester
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetApiSpecResponse parses an HTTP response from a GetApiSpecWithResponse call
func ParseGetApiSpecResponse(rsp *http.Response) (*GetApiSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseListAuthTokensResponse parses an HTTP response from a ListAuthTokensWithResponse call
func ParseListAuthTokensResponse(rsp *http.Response) (*ListAuthTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuthTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Tokens *[]ModelAuthToken `json:"tokens,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAuthTokenResponse parses an HTTP response from a CreateAuthTokenWithResponse call
func ParseCreateAuthTokenResponse(rsp *http.Response) (*CreateAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *ModelAuthToken `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthTokenResponse parses an HTTP response from a DeleteAuthTokenWithResponse call
func ParseDeleteAuthTokenResponse(rsp *http.Response) (*DeleteAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityResponse parses an HTTP response from a GetUserEntityWithResponse call
func ParseGetUserEntityResponse(rsp *http.Response) (*GetUserEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntityInfoQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityAdminRightsResponse parses an HTTP response from a GetUserEntityAdminRightsWithResponse call
func ParseGetUserEntityAdminRightsResponse(rsp *http.Response) (*GetUserEntityAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityConstrainedDelegationRightsResponse parses an HTTP response from a GetUserEntityConstrainedDelegationRightsWithResponse call
func ParseGetUserEntityConstrainedDelegationRightsResponse(rsp *http.Response) (*GetUserEntityConstrainedDelegationRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityConstrainedDelegationRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityControllablesResponse parses an HTTP response from a GetUserEntityControllablesWithResponse call
func ParseGetUserEntityControllablesResponse(rsp *http.Response) (*GetUserEntityControllablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityControllablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityControllersResponse parses an HTTP response from a GetUserEntityControllersWithResponse call
func ParseGetUserEntityControllersResponse(rsp *http.Response) (*GetUserEntityControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityDcomRightsResponse parses an HTTP response from a GetUserEntityDcomRightsWithResponse call
func ParseGetUserEntityDcomRightsResponse(rsp *http.Response) (*GetUserEntityDcomRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityDcomRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityMembershipResponse parses an HTTP response from a GetUserEntityMembershipWithResponse call
func ParseGetUserEntityMembershipResponse(rsp *http.Response) (*GetUserEntityMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityPsRemoteRightsResponse parses an HTTP response from a GetUserEntityPsRemoteRightsWithResponse call
func ParseGetUserEntityPsRemoteRightsResponse(rsp *http.Response) (*GetUserEntityPsRemoteRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityPsRemoteRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntityRdpRightsResponse parses an HTTP response from a GetUserEntityRdpRightsWithResponse call
func ParseGetUserEntityRdpRightsResponse(rsp *http.Response) (*GetUserEntityRdpRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntityRdpRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntitySessionsResponse parses an HTTP response from a GetUserEntitySessionsWithResponse call
func ParseGetUserEntitySessionsResponse(rsp *http.Response) (*GetUserEntitySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntitySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserEntitySqlAdminRightsResponse parses an HTTP response from a GetUserEntitySqlAdminRightsWithResponse call
func ParseGetUserEntitySqlAdminRightsResponse(rsp *http.Response) (*GetUserEntitySqlAdminRightsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserEntitySqlAdminRightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RelatedEntityQueryResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApiVersionResponse parses an HTTP response from a GetApiVersionWithResponse call
func ParseGetApiVersionResponse(rsp *http.Response) (*GetApiVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				API *struct {
					CurrentVersion    *string `json:"current_version,omitempty"`
					DeprecatedVersion *string `json:"deprecated_version,omitempty"`
				} `json:"API,omitempty"`
				ServerVersion *string `json:"server_version,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Accept EULA
	// (GET /api/v2/accept-eula)
	AcceptEula(ctx echo.Context, params AcceptEulaParams) error
	// Get AD domain data quality stats
	// (GET /api/v2/ad-domains/{domain_id}/data-quality-stats)
	GetAdDomainDataQualityStats(ctx echo.Context, domainId string, params GetAdDomainDataQualityStatsParams) error
	// Get AIA CA entity info
	// (GET /api/v2/aiacas/{object_id})
	GetAiaCaEntity(ctx echo.Context, objectId PathObjectId, params GetAiaCaEntityParams) error
	// Get AIA CA entity controllers
	// (GET /api/v2/aiacas/{object_id}/controllers)
	GetAiaCaEntityControllers(ctx echo.Context, objectId PathObjectId, params GetAiaCaEntityControllersParams) error
	// Start analysis
	// (PUT /api/v2/analysis)
	StartAnalysis(ctx echo.Context, params StartAnalysisParams) error
	// List all asset isolation groups
	// (GET /api/v2/asset-groups)
	ListAssetGroups(ctx echo.Context, params ListAssetGroupsParams) error
	// Create an asset group
	// (POST /api/v2/asset-groups)
	CreateAssetGroup(ctx echo.Context, params CreateAssetGroupParams) error
	// Delete an asset group
	// (DELETE /api/v2/asset-groups/{asset_group_id})
	DeleteAssetGroup(ctx echo.Context, assetGroupId int32, params DeleteAssetGroupParams) error
	// Get asset group by ID
	// (GET /api/v2/asset-groups/{asset_group_id})
	GetAssetGroup(ctx echo.Context, assetGroupId int32, params GetAssetGroupParams) error
	// Update an asset group
	// (PUT /api/v2/asset-groups/{asset_group_id})
	UpdateAssetGroup(ctx echo.Context, assetGroupId int32, params UpdateAssetGroupParams) error
	// List asset group collections
	// (GET /api/v2/asset-groups/{asset_group_id}/collections)
	ListAssetGroupCollections(ctx echo.Context, assetGroupId int32, params ListAssetGroupCollectionsParams) error
	// Get the combo tree for an asset group
	// (GET /api/v2/asset-groups/{asset_group_id}/combo-node)
	GetAssetGroupComboNode(ctx echo.Context, assetGroupId int32, params GetAssetGroupComboNodeParams) error
	// Get asset group custom member count
	// (GET /api/v2/asset-groups/{asset_group_id}/custom-selectors)
	GetAssetGroupCustomMemberCount(ctx echo.Context, assetGroupId int32, params GetAssetGroupCustomMemberCountParams) error
	// List all asset isolation group members
	// (GET /api/v2/asset-groups/{asset_group_id}/members)
	ListAssetGroupMembers(ctx echo.Context, assetGroupId int32, params ListAssetGroupMembersParams) error
	// List asset group member count by kind
	// (GET /api/v2/asset-groups/{asset_group_id}/members/counts)
	ListAssetGroupMemberCountByKind(ctx echo.Context, assetGroupId int32, params ListAssetGroupMemberCountByKindParams) error
	// Update asset group selectors
	// (POST /api/v2/asset-groups/{asset_group_id}/selectors)
	UpdateAssetGroupSelectorsDeprecated(ctx echo.Context, assetGroupId int32, params UpdateAssetGroupSelectorsDeprecatedParams) error
	// Update asset group selectors
	// (PUT /api/v2/asset-groups/{asset_group_id}/selectors)
	UpdateAssetGroupSelectors(ctx echo.Context, assetGroupId int32, params UpdateAssetGroupSelectorsParams) error
	// Delete an asset group selector
	// (DELETE /api/v2/asset-groups/{asset_group_id}/selectors/{asset_group_selector_id})
	DeleteAssetGroupSelector(ctx echo.Context, assetGroupId int32, assetGroupSelectorId int32, params DeleteAssetGroupSelectorParams) error
	// List all attack path types
	// (GET /api/v2/attack-path-types)
	ListAttackPathTypes(ctx echo.Context, params ListAttackPathTypesParams) error
	// Start analysis
	// (PUT /api/v2/attack-paths)
	StartAnalysisBhe(ctx echo.Context, params StartAnalysisBheParams) error
	// Update attack path risk
	// (PUT /api/v2/attack-paths/{attack_path_id}/acceptance)
	UpdateAttackPathRisk(ctx echo.Context, attackPathId int64, params UpdateAttackPathRiskParams) error
	// List audit logs
	// (GET /api/v2/audit)
	ListAuditLogs(ctx echo.Context, params ListAuditLogsParams) error
	// Get available domains
	// (GET /api/v2/available-domains)
	GetAvailableDomains(ctx echo.Context, params GetAvailableDomainsParams) error
	// Get Azure tenant data quality stats
	// (GET /api/v2/azure-tenants/{tenant_id}/data-quality-stats)
	GetAzureTenantDataQualityStats(ctx echo.Context, tenantId string, params GetAzureTenantDataQualityStatsParams) error
	// Get Azure entity
	// (GET /api/v2/azure/{entity_type})
	GetAzureEntity(ctx echo.Context, entityType string, params GetAzureEntityParams) error
	// Get entity info
	// (GET /api/v2/base/{object_id})
	GetEntity(ctx echo.Context, objectId PathObjectId, params GetEntityParams) error
	// Get entity controllables
	// (GET /api/v2/base/{object_id}/controllables)
	GetEntityControllables(ctx echo.Context, objectId PathObjectId, params GetEntityControllablesParams) error
	// Get entity controllers
	// (GET /api/v2/base/{object_id}/controllers)
	GetEntityControllers(ctx echo.Context, objectId PathObjectId, params GetEntityControllersParams) error
	// List Users
	// (GET /api/v2/bloodhound-users)
	ListUsers(ctx echo.Context, params ListUsersParams) error
	// Create a New User
	// (POST /api/v2/bloodhound-users)
	CreateUser(ctx echo.Context, params CreateUserParams) error
	// Delete a User
	// (DELETE /api/v2/bloodhound-users/{user_id})
	DeleteUser(ctx echo.Context, userId openapi_types.UUID, params DeleteUserParams) error
	// Get a user
	// (GET /api/v2/bloodhound-users/{user_id})
	GetUser(ctx echo.Context, userId openapi_types.UUID, params GetUserParams) error
	// Update a User
	// (PATCH /api/v2/bloodhound-users/{user_id})
	UpdateUser(ctx echo.Context, userId openapi_types.UUID, params UpdateUserParams) error
	// Unenroll user from multi-factor authentication
	// (DELETE /api/v2/bloodhound-users/{user_id}/mfa)
	RemoveUserMfa(ctx echo.Context, userId openapi_types.UUID, params RemoveUserMfaParams) error
	// Enrolls user in multi-factor authentication
	// (POST /api/v2/bloodhound-users/{user_id}/mfa)
	AddUserMfa(ctx echo.Context, userId openapi_types.UUID, params AddUserMfaParams) error
	// Returns MFA activation status for a user
	// (GET /api/v2/bloodhound-users/{user_id}/mfa-activation)
	GetMfaActivationStatus(ctx echo.Context, userId openapi_types.UUID, params GetMfaActivationStatusParams) error
	// Activates MFA for an enrolled user
	// (POST /api/v2/bloodhound-users/{user_id}/mfa-activation)
	ActivateUserMfa(ctx echo.Context, userId openapi_types.UUID, params ActivateUserMfaParams) error
	// Expire User Secret
	// (DELETE /api/v2/bloodhound-users/{user_id}/secret)
	DeleteUserSecret(ctx echo.Context, userId openapi_types.UUID, params DeleteUserSecretParams) error
	// Create or Set User Secret
	// (PUT /api/v2/bloodhound-users/{user_id}/secret)
	CreateOrSetUserSecret(ctx echo.Context, userId openapi_types.UUID, params CreateOrSetUserSecretParams) error
	// Get Cert Template entity info
	// (GET /api/v2/certtemplates/{object_id})
	GetCertTemplateEntity(ctx echo.Context, objectId PathObjectId, params GetCertTemplateEntityParams) error
	// Get Cert Template entity controllers
	// (GET /api/v2/certtemplates/{object_id}/controllers)
	GetCertTemplateEntityControllers(ctx echo.Context, objectId PathObjectId, params GetCertTemplateEntityControllersParams) error
	// Delete your BloodHound data
	// (POST /api/v2/clear-database)
	DeleteBloodHoundDatabase(ctx echo.Context, params DeleteBloodHoundDatabaseParams) error
	// List Clients
	// (GET /api/v2/clients)
	ListClients(ctx echo.Context, params ListClientsParams) error
	// Create Client
	// (POST /api/v2/clients)
	CreateClient(ctx echo.Context, params CreateClientParams) error
	// Client Error
	// (POST /api/v2/clients/error)
	LogClientError(ctx echo.Context, params LogClientErrorParams) error
	// Update Client Values
	// (PUT /api/v2/clients/update)
	UpdateClientInfo(ctx echo.Context, params UpdateClientInfoParams) error
	// Delete Client
	// (DELETE /api/v2/clients/{client_id})
	DeleteClient(ctx echo.Context, clientId openapi_types.UUID, params DeleteClientParams) error
	// Get Client
	// (GET /api/v2/clients/{client_id})
	GetClient(ctx echo.Context, clientId openapi_types.UUID, params GetClientParams) error
	// Update Client
	// (PUT /api/v2/clients/{client_id})
	UpdateClient(ctx echo.Context, clientId openapi_types.UUID, params UpdateClientParams) error
	// List all completed jobs for a client
	// (GET /api/v2/clients/{client_id}/completed-jobs)
	ListClientCompletedJobs(ctx echo.Context, clientId openapi_types.UUID, params ListClientCompletedJobsParams) error
	// List all completed tasks for a client
	// (GET /api/v2/clients/{client_id}/completed-tasks)
	ListClientCompletedTasks(ctx echo.Context, clientId openapi_types.UUID, params ListClientCompletedTasksParams) error
	// Creates a scheduled job
	// (POST /api/v2/clients/{client_id}/jobs)
	CreateClientScheduledJob(ctx echo.Context, clientId openapi_types.UUID, params CreateClientScheduledJobParams) error
	// Creates a scheduled task
	// (POST /api/v2/clients/{client_id}/tasks)
	CreateClientScheduledTask(ctx echo.Context, clientId openapi_types.UUID, params CreateClientScheduledTaskParams) error
	// Regenerate the authentication token for a client
	// (PUT /api/v2/clients/{client_id}/token)
	ReplaceClientToken(ctx echo.Context, clientId openapi_types.UUID, params ReplaceClientTokenParams) error
	// Get collector manifest
	// (GET /api/v2/collectors/{collector_type})
	GetCollectorManifest(ctx echo.Context, collectorType EnumClientType, params GetCollectorManifestParams) error
	// Get collector download by version
	// (GET /api/v2/collectors/{collector_type}/{release_tag})
	DownloadCollector(ctx echo.Context, collectorType EnumClientType, releaseTag string, params DownloadCollectorParams) error
	// Get collector checksum by version
	// (GET /api/v2/collectors/{collector_type}/{release_tag}/checksum)
	GetCollectorChecksum(ctx echo.Context, collectorType EnumClientType, releaseTag string, params GetCollectorChecksumParams) error
	// Get database completeness stats
	// (GET /api/v2/completeness)
	GetCompletenessStats(ctx echo.Context, params GetCompletenessStatsParams) error
	// Get computer entity info
	// (GET /api/v2/computers/{object_id})
	GetComputerEntity(ctx echo.Context, objectId PathObjectId, params GetComputerEntityParams) error
	// Get computer entity admin rights
	// (GET /api/v2/computers/{object_id}/admin-rights)
	GetComputerEntityAdminRights(ctx echo.Context, objectId PathObjectId, params GetComputerEntityAdminRightsParams) error
	// Get computer entity admins
	// (GET /api/v2/computers/{object_id}/admin-users)
	GetComputerEntityAdmins(ctx echo.Context, objectId PathObjectId, params GetComputerEntityAdminsParams) error
	// Get computer entity constrained delegation rights
	// (GET /api/v2/computers/{object_id}/constrained-delegation-rights)
	GetComputerEntityConstrainedDelegationRights(ctx echo.Context, objectId PathObjectId, params GetComputerEntityConstrainedDelegationRightsParams) error
	// Get computer entity constrained users
	// (GET /api/v2/computers/{object_id}/constrained-users)
	GetComputerEntityConstrainedUsers(ctx echo.Context, objectId PathObjectId, params GetComputerEntityConstrainedUsersParams) error
	// Get computer entity controllables
	// (GET /api/v2/computers/{object_id}/controllables)
	GetComputerEntityControllables(ctx echo.Context, objectId PathObjectId, params GetComputerEntityControllablesParams) error
	// Get computer entity controllers
	// (GET /api/v2/computers/{object_id}/controllers)
	GetComputerEntityControllers(ctx echo.Context, objectId PathObjectId, params GetComputerEntityControllersParams) error
	// Get computer entity DCOM rights
	// (GET /api/v2/computers/{object_id}/dcom-rights)
	GetComputerEntityDcomRights(ctx echo.Context, objectId PathObjectId, params GetComputerEntityDcomRightsParams) error
	// Get computer entity DCOM users
	// (GET /api/v2/computers/{object_id}/dcom-users)
	GetComputerEntityDcomUsers(ctx echo.Context, objectId PathObjectId, params GetComputerEntityDcomUsersParams) error
	// Get computer entity group membership
	// (GET /api/v2/computers/{object_id}/group-membership)
	GetComputerEntityGroupMembership(ctx echo.Context, objectId PathObjectId, params GetComputerEntityGroupMembershipParams) error
	// Get computer entity remote PowerShell rights
	// (GET /api/v2/computers/{object_id}/ps-remote-rights)
	GetComputerEntityPsRemoteRights(ctx echo.Context, objectId PathObjectId, params GetComputerEntityPsRemoteRightsParams) error
	// Get computer entity remote PowerShell users
	// (GET /api/v2/computers/{object_id}/ps-remote-users)
	GetComputerEntityPsRemoteUsers(ctx echo.Context, objectId PathObjectId, params GetComputerEntityPsRemoteUsersParams) error
	// Get computer entity RDP rights
	// (GET /api/v2/computers/{object_id}/rdp-rights)
	GetComputerEntityRdpRights(ctx echo.Context, objectId PathObjectId, params GetComputerEntityRdpRightsParams) error
	// Get computer entity RDP users
	// (GET /api/v2/computers/{object_id}/rdp-users)
	GetComputerEntityRdpUsers(ctx echo.Context, objectId PathObjectId, params GetComputerEntityRdpUsersParams) error
	// Get computer entity sessions
	// (GET /api/v2/computers/{object_id}/sessions)
	GetComputerEntitySessions(ctx echo.Context, objectId PathObjectId, params GetComputerEntitySessionsParams) error
	// Get computer entity SQL admins
	// (GET /api/v2/computers/{object_id}/sql-admins)
	GetComputerEntitySqlAdmins(ctx echo.Context, objectId PathObjectId, params GetComputerEntitySqlAdminsParams) error
	// List application config parameters
	// (GET /api/v2/config)
	ListAppConfigParams(ctx echo.Context, params ListAppConfigParamsParams) error
	// Write application configuration parameters
	// (PUT /api/v2/config)
	SetAppConfigParam(ctx echo.Context, params SetAppConfigParamParams) error
	// Get container entity info
	// (GET /api/v2/containers/{object_id})
	GetContainerEntity(ctx echo.Context, objectId PathObjectId, params GetContainerEntityParams) error
	// Get container entity controllers
	// (GET /api/v2/containers/{object_id}/controllers)
	GetContainerEntityControllers(ctx echo.Context, objectId PathObjectId, params GetContainerEntityControllersParams) error
	// Get datapipe status
	// (GET /api/v2/datapipe/status)
	GetDatapipeStatus(ctx echo.Context, params GetDatapipeStatusParams) error
	// Export attack path findings
	// (GET /api/v2/domains/{domain_id}/attack-path-findings)
	ExportAttackPathFindings(ctx echo.Context, domainId string, params ExportAttackPathFindingsParams) error
	// List available attack paths
	// (GET /api/v2/domains/{domain_id}/available-types)
	ListAvailableAttackPathTypesForDomain(ctx echo.Context, domainId string, params ListAvailableAttackPathTypesForDomainParams) error
	// List domain attack paths details
	// (GET /api/v2/domains/{domain_id}/details)
	ListDomainAttackPathsDetails(ctx echo.Context, domainId string, params ListDomainAttackPathsDetailsParams) error
	// List attack path sparkline values
	// (GET /api/v2/domains/{domain_id}/sparkline)
	ListAttackPathSparklineValues(ctx echo.Context, domainId string, params ListAttackPathSparklineValuesParams) error
	// Get domain entity info
	// (GET /api/v2/domains/{object_id})
	GetDomainEntity(ctx echo.Context, objectId PathObjectId, params GetDomainEntityParams) error
	// Update the Domain entity
	// (PATCH /api/v2/domains/{object_id})
	UpdateDomainEntity(ctx echo.Context, objectId PathObjectId, params UpdateDomainEntityParams) error
	// Get domain entity computers
	// (GET /api/v2/domains/{object_id}/computers)
	GetDomainEntityComputers(ctx echo.Context, objectId PathObjectId, params GetDomainEntityComputersParams) error
	// Get domain entity controllers
	// (GET /api/v2/domains/{object_id}/controllers)
	GetDomainEntityControllers(ctx echo.Context, objectId PathObjectId, params GetDomainEntityControllersParams) error
	// Get domain entity DC Syncers
	// (GET /api/v2/domains/{object_id}/dc-syncers)
	GetDomainEntityDcSyncers(ctx echo.Context, objectId PathObjectId, params GetDomainEntityDcSyncersParams) error
	// Get domain entity foreign admins
	// (GET /api/v2/domains/{object_id}/foreign-admins)
	GetDomainEntityForeignAdmins(ctx echo.Context, objectId PathObjectId, params GetDomainEntityForeignAdminsParams) error
	// Get domain entity foreign GPO controllers
	// (GET /api/v2/domains/{object_id}/foreign-gpo-controllers)
	GetDomainEntityForeignGpoControllers(ctx echo.Context, objectId PathObjectId, params GetDomainEntityForeignGpoControllersParams) error
	// Get domain entity foregin groups
	// (GET /api/v2/domains/{object_id}/foreign-groups)
	GetDomainEntityForeignGroups(ctx echo.Context, objectId PathObjectId, params GetDomainEntityForeignGroupsParams) error
	// Get domain entity foreign users
	// (GET /api/v2/domains/{object_id}/foreign-users)
	GetDomainEntityForeignUsers(ctx echo.Context, objectId PathObjectId, params GetDomainEntityForeignUsersParams) error
	// Get domain entity GPOs
	// (GET /api/v2/domains/{object_id}/gpos)
	GetDomainEntityGpos(ctx echo.Context, objectId PathObjectId, params GetDomainEntityGposParams) error
	// Get domain entity groups
	// (GET /api/v2/domains/{object_id}/groups)
	GetDomainEntityGroups(ctx echo.Context, objectId PathObjectId, params GetDomainEntityGroupsParams) error
	// Get domain entity inbound trusts
	// (GET /api/v2/domains/{object_id}/inbound-trusts)
	GetDomainEntityInboundTrusts(ctx echo.Context, objectId PathObjectId, params GetDomainEntityInboundTrustsParams) error
	// Get domain entity linked GPOs
	// (GET /api/v2/domains/{object_id}/linked-gpos)
	GetDomainEntityLinkedGpos(ctx echo.Context, objectId PathObjectId, params GetDomainEntityLinkedGposParams) error
	// Get domain entity OUs
	// (GET /api/v2/domains/{object_id}/ous)
	GetDomainEntityOus(ctx echo.Context, objectId PathObjectId, params GetDomainEntityOusParams) error
	// Get domain entity outbound trusts
	// (GET /api/v2/domains/{object_id}/outbound-trusts)
	GetDomainEntityOutboundTrusts(ctx echo.Context, objectId PathObjectId, params GetDomainEntityOutboundTrustsParams) error
	// Get domain entity users
	// (GET /api/v2/domains/{object_id}/users)
	GetDomainEntityUsers(ctx echo.Context, objectId PathObjectId, params GetDomainEntityUsersParams) error
	// Get Enterprise CA entity info
	// (GET /api/v2/enterprisecas/{object_id})
	GetEnterpriseCaEntity(ctx echo.Context, objectId PathObjectId, params GetEnterpriseCaEntityParams) error
	// Get Enterprise CA entity controllers
	// (GET /api/v2/enterprisecas/{object_id}/controllers)
	GetEnterpriseCaEntityControllers(ctx echo.Context, objectId PathObjectId, params GetEnterpriseCaEntityControllersParams) error
	// List events
	// (GET /api/v2/events)
	ListClientSchedules(ctx echo.Context, params ListClientSchedulesParams) error
	// Create Event
	// (POST /api/v2/events)
	CreateClientSchedule(ctx echo.Context, params CreateClientScheduleParams) error
	// Delete Event
	// (DELETE /api/v2/events/{event_id})
	DeleteClientEvent(ctx echo.Context, eventId int32, params DeleteClientEventParams) error
	// Get Event
	// (GET /api/v2/events/{event_id})
	GetClientSchedule(ctx echo.Context, eventId int32, params GetClientScheduleParams) error
	// Update Event
	// (PUT /api/v2/events/{event_id})
	UpdateClientEvent(ctx echo.Context, eventId int32, params UpdateClientEventParams) error
	// List feature flags
	// (GET /api/v2/features)
	ListFeatureFlags(ctx echo.Context, params ListFeatureFlagsParams) error
	// Toggle a feature flag's enabled status to either enable or disable it.
	// (PUT /api/v2/features/{feature_id}/toggle)
	ToggleFeatureFlag(ctx echo.Context, featureId int32, params ToggleFeatureFlagParams) error
	// List File Upload Jobs
	// (GET /api/v2/file-upload)
	ListFileUploadJobs(ctx echo.Context, params ListFileUploadJobsParams) error
	// List accepted file upload types
	// (GET /api/v2/file-upload/accepted-types)
	ListAcceptedFileUploadTypes(ctx echo.Context, params ListAcceptedFileUploadTypesParams) error
	// Create File Upload Job
	// (POST /api/v2/file-upload/start)
	CreateFileUploadJob(ctx echo.Context, params CreateFileUploadJobParams) error
	// Upload File To Job
	// (POST /api/v2/file-upload/{file_upload_job_id})
	UploadFileToJob(ctx echo.Context, fileUploadJobId int64, params UploadFileToJobParams) error
	// End File Upload Job
	// (POST /api/v2/file-upload/{file_upload_job_id}/end)
	EndFileUploadJob(ctx echo.Context, fileUploadJobId int64, params EndFileUploadJobParams) error
	// Get GPO entity info
	// (GET /api/v2/gpos/{object_id})
	GetGpoEntity(ctx echo.Context, objectId PathObjectId, params GetGpoEntityParams) error
	// Get GPO entity computer
	// (GET /api/v2/gpos/{object_id}/computers)
	GetGpoEntityComputers(ctx echo.Context, objectId PathObjectId, params GetGpoEntityComputersParams) error
	// Get GPO entity controllers
	// (GET /api/v2/gpos/{object_id}/controllers)
	GetGpoEntityControllers(ctx echo.Context, objectId PathObjectId, params GetGpoEntityControllersParams) error
	// Get GPO entity OUs
	// (GET /api/v2/gpos/{object_id}/ous)
	GetGpoEntityOus(ctx echo.Context, objectId PathObjectId, params GetGpoEntityOusParams) error
	// Get GPO entity tier-zero
	// (GET /api/v2/gpos/{object_id}/tier-zero)
	GetGpoEntityTierZero(ctx echo.Context, objectId PathObjectId, params GetGpoEntityTierZeroParams) error
	// Get GPO entity users
	// (GET /api/v2/gpos/{object_id}/users)
	GetGpoEntityUsers(ctx echo.Context, objectId PathObjectId, params GetGpoEntityUsersParams) error
	// Get search result
	// (GET /api/v2/graph-search)
	GetSearchResult(ctx echo.Context, params GetSearchResultParams) error
	// Run a cypher query
	// (POST /api/v2/graphs/cypher)
	RunCypherQuery(ctx echo.Context, params RunCypherQueryParams) error
	// Get path composition
	// (GET /api/v2/graphs/edge-composition)
	GetPathComposition(ctx echo.Context, params GetPathCompositionParams) error
	// Get the shortest path graph
	// (GET /api/v2/graphs/shortest-path)
	GetShortestPath(ctx echo.Context, params GetShortestPathParams) error
	// Get Group entity info
	// (GET /api/v2/groups/{object_id})
	GetGroupEntity(ctx echo.Context, objectId PathObjectId, params GetGroupEntityParams) error
	// Get Group entity admin rights
	// (GET /api/v2/groups/{object_id}/admin-rights)
	GetGroupEntityAdminRights(ctx echo.Context, objectId PathObjectId, params GetGroupEntityAdminRightsParams) error
	// Get Group entity controllables
	// (GET /api/v2/groups/{object_id}/controllables)
	GetGroupEntityControllables(ctx echo.Context, objectId PathObjectId, params GetGroupEntityControllablesParams) error
	// Get Group entity controllers
	// (GET /api/v2/groups/{object_id}/controllers)
	GetGroupEntityControllers(ctx echo.Context, objectId PathObjectId, params GetGroupEntityControllersParams) error
	// Get Group entity DCOMRights
	// (GET /api/v2/groups/{object_id}/dcom-rights)
	GetGroupEntityDcomRights(ctx echo.Context, objectId PathObjectId, params GetGroupEntityDcomRightsParams) error
	// Get Group entity members
	// (GET /api/v2/groups/{object_id}/members)
	GetGroupEntityMembers(ctx echo.Context, objectId PathObjectId, params GetGroupEntityMembersParams) error
	// Get Group entity memberships
	// (GET /api/v2/groups/{object_id}/memberships)
	GetGroupEntityMemberships(ctx echo.Context, objectId PathObjectId, params GetGroupEntityMembershipsParams) error
	// Get Group entity PowerShell remote rights
	// (GET /api/v2/groups/{object_id}/ps-remote-rights)
	GetGroupEntityPsRemoteRights(ctx echo.Context, objectId PathObjectId, params GetGroupEntityPsRemoteRightsParams) error
	// Get Group entity RDP rights
	// (GET /api/v2/groups/{object_id}/rdp-rights)
	GetGroupEntityRdpRights(ctx echo.Context, objectId PathObjectId, params GetGroupEntityRdpRightsParams) error
	// Get Group entity sessions
	// (GET /api/v2/groups/{object_id}/sessions)
	GetGroupEntitySessions(ctx echo.Context, objectId PathObjectId, params GetGroupEntitySessionsParams) error
	// Endpoint for data ingestion
	// (POST /api/v2/ingest)
	IngestData(ctx echo.Context, params IngestDataParams) error
	// Get jobs
	// (GET /api/v2/jobs)
	GetClientJobs(ctx echo.Context, params GetClientJobsParams) error
	// List available client jobs
	// (GET /api/v2/jobs/available)
	ListAvailableClientJobs(ctx echo.Context, params ListAvailableClientJobsParams) error
	// Get client current job
	// (GET /api/v2/jobs/current)
	GetClientCurrentJob(ctx echo.Context, params GetClientCurrentJobParams) error
	// Notifies the API of a job ending
	// (POST /api/v2/jobs/end)
	EndClientJob(ctx echo.Context, params EndClientJobParams) error
	// List finished jobs
	// (GET /api/v2/jobs/finished)
	ListClientFinishedJobs(ctx echo.Context, params ListClientFinishedJobsParams) error
	// Notifies the API of a job start
	// (POST /api/v2/jobs/start)
	StartClientJob(ctx echo.Context, params StartClientJobParams) error
	// Get client job
	// (GET /api/v2/jobs/{job_id})
	GetClientJob(ctx echo.Context, jobId int64, params GetClientJobParams) error
	// Cancels a scheduled job
	// (PUT /api/v2/jobs/{job_id}/cancel)
	CancelClientJob(ctx echo.Context, jobId int64, params CancelClientJobParams) error
	// Get Job Log File
	// (GET /api/v2/jobs/{job_id}/log)
	GetClientJobLog(ctx echo.Context, jobId int64, params GetClientJobLogParams) error
	// Login to BloodHound
	// (POST /api/v2/login)
	Login(ctx echo.Context, params LoginParams) error
	// Logout of BloodHound
	// (POST /api/v2/logout)
	Logout(ctx echo.Context, params LogoutParams) error
	// Get latest tier zero combo node
	// (GET /api/v2/meta-nodes/{domain_id})
	GetLatestTierZeroComboNode(ctx echo.Context, domainId string, params GetLatestTierZeroComboNodeParams) error
	// Get the graph for meta tree
	// (GET /api/v2/meta-trees/{domain_id})
	GetComboTreeGraph(ctx echo.Context, domainId string, params GetComboTreeGraphParams) error
	// Get Meta entity info
	// (GET /api/v2/meta/{object_id})
	GetMetaEntity(ctx echo.Context, objectId PathObjectId, params GetMetaEntityParams) error
	// Get NT Auth Store entity info
	// (GET /api/v2/ntauthstores/{object_id})
	GetNtAuthStoreEntity(ctx echo.Context, objectId PathObjectId, params GetNtAuthStoreEntityParams) error
	// Get NT Auth Store entity controllers
	// (GET /api/v2/ntauthstores/{object_id}/controllers)
	GetNtAuthStoreEntityControllers(ctx echo.Context, objectId PathObjectId, params GetNtAuthStoreEntityControllersParams) error
	// Get OU entity info
	// (GET /api/v2/ous/{object_id})
	GetOuEntity(ctx echo.Context, objectId PathObjectId, params GetOuEntityParams) error
	// Get OU entity computers
	// (GET /api/v2/ous/{object_id}/computers)
	GetOuEntityComputers(ctx echo.Context, objectId PathObjectId, params GetOuEntityComputersParams) error
	// Get OU entity GPOs
	// (GET /api/v2/ous/{object_id}/gpos)
	GetOuEntityGpos(ctx echo.Context, objectId PathObjectId, params GetOuEntityGposParams) error
	// Get OU entity groups
	// (GET /api/v2/ous/{object_id}/groups)
	GetOuEntityGroups(ctx echo.Context, objectId PathObjectId, params GetOuEntityGroupsParams) error
	// Get OU entity users
	// (GET /api/v2/ous/{object_id}/users)
	GetOuEntityUsers(ctx echo.Context, objectId PathObjectId, params GetOuEntityUsersParams) error
	// Get pathfinding result
	// (GET /api/v2/pathfinding)
	Pathfinding(ctx echo.Context, params PathfindingParams) error
	// List Permissions
	// (GET /api/v2/permissions)
	ListPermissions(ctx echo.Context, params ListPermissionsParams) error
	// Get Permission
	// (GET /api/v2/permissions/{permission_id})
	GetPermission(ctx echo.Context, permissionId int32, params GetPermissionParams) error
	// Get platform data quality aggregate
	// (GET /api/v2/platform/{platform_id}/data-quality-stats)
	GetPlatformDataQualityAggregate(ctx echo.Context, platformId string, params GetPlatformDataQualityAggregateParams) error
	// Get Posture Statistics
	// (GET /api/v2/posture-stats)
	GetPostureStats(ctx echo.Context, params GetPostureStatsParams) error
	// List Roles
	// (GET /api/v2/roles)
	ListRoles(ctx echo.Context, params ListRolesParams) error
	// Get Role
	// (GET /api/v2/roles/{role_id})
	GetRole(ctx echo.Context, roleId int32, params GetRoleParams) error
	// Get Root CA entity info
	// (GET /api/v2/rootcas/{object_id})
	GetRootCaEntity(ctx echo.Context, objectId PathObjectId, params GetRootCaEntityParams) error
	// Get Root CA entity controllers
	// (GET /api/v2/rootcas/{object_id}/controllers)
	GetRootCaEntityControllers(ctx echo.Context, objectId PathObjectId, params GetRootCaEntityControllersParams) error
	// List SAML Providers
	// (GET /api/v2/saml)
	ListSamlProviders(ctx echo.Context, params ListSamlProvidersParams) error
	// Create a New SAML Provider from Metadata
	// (POST /api/v2/saml/providers)
	CreateSamlProvider(ctx echo.Context) error
	// Delete a SAML Provider
	// (DELETE /api/v2/saml/providers/{saml_provider_id})
	DeleteSamlProvider(ctx echo.Context, samlProviderId int32, params DeleteSamlProviderParams) error
	// Get SAML Provider
	// (GET /api/v2/saml/providers/{saml_provider_id})
	GetSamlProvider(ctx echo.Context, samlProviderId int32, params GetSamlProviderParams) error
	// Get all SAML sign on endpoints
	// (GET /api/v2/saml/sso)
	GetSamlSignSignOnEndpoints(ctx echo.Context, params GetSamlSignSignOnEndpointsParams) error
	// List saved queries
	// (GET /api/v2/saved-queries)
	ListSavedQueries(ctx echo.Context, params ListSavedQueriesParams) error
	// Create a saved query
	// (POST /api/v2/saved-queries)
	CreateSavedQuery(ctx echo.Context, params CreateSavedQueryParams) error
	// Delete a saved query
	// (DELETE /api/v2/saved-queries/{saved_query_id})
	DeleteSavedQuery(ctx echo.Context, savedQueryId int32, params DeleteSavedQueryParams) error
	// Update a saved query
	// (PUT /api/v2/saved-queries/{saved_query_id})
	UpdateSavedQuery(ctx echo.Context, savedQueryId int32, params UpdateSavedQueryParams) error
	// Revokes permission of a saved query from users
	// (DELETE /api/v2/saved-queries/{saved_query_id}/permissions)
	DeleteSavedQueryPermissions(ctx echo.Context, savedQueryId int32, params DeleteSavedQueryPermissionsParams) error
	// Search for objects
	// (GET /api/v2/search)
	Search(ctx echo.Context, params SearchParams) error
	// Get self
	// (GET /api/v2/self)
	GetSelf(ctx echo.Context, params GetSelfParams) error
	// Get API Spec
	// (GET /api/v2/spec/openapi.yaml)
	GetApiSpec(ctx echo.Context, params GetApiSpecParams) error
	// List Auth Tokens
	// (GET /api/v2/tokens)
	ListAuthTokens(ctx echo.Context, params ListAuthTokensParams) error
	// Create Token for User
	// (POST /api/v2/tokens)
	CreateAuthToken(ctx echo.Context, params CreateAuthTokenParams) error
	// Delete a User Token
	// (DELETE /api/v2/tokens/{token_id})
	DeleteAuthToken(ctx echo.Context, tokenId openapi_types.UUID, params DeleteAuthTokenParams) error
	// Get User entity info
	// (GET /api/v2/users/{object_id})
	GetUserEntity(ctx echo.Context, objectId PathObjectId, params GetUserEntityParams) error
	// Get User entity admin rights
	// (GET /api/v2/users/{object_id}/admin-rights)
	GetUserEntityAdminRights(ctx echo.Context, objectId PathObjectId, params GetUserEntityAdminRightsParams) error
	// Get User entity constrained delegation rights
	// (GET /api/v2/users/{object_id}/constrained-delegation-rights)
	GetUserEntityConstrainedDelegationRights(ctx echo.Context, objectId PathObjectId, params GetUserEntityConstrainedDelegationRightsParams) error
	// Get User entity controllables
	// (GET /api/v2/users/{object_id}/controllables)
	GetUserEntityControllables(ctx echo.Context, objectId PathObjectId, params GetUserEntityControllablesParams) error
	// Get User entity controllers
	// (GET /api/v2/users/{object_id}/controllers)
	GetUserEntityControllers(ctx echo.Context, objectId PathObjectId, params GetUserEntityControllersParams) error
	// Get User entity DCOM rights
	// (GET /api/v2/users/{object_id}/dcom-rights)
	GetUserEntityDcomRights(ctx echo.Context, objectId PathObjectId, params GetUserEntityDcomRightsParams) error
	// Get User entity membership
	// (GET /api/v2/users/{object_id}/memberships)
	GetUserEntityMembership(ctx echo.Context, objectId PathObjectId, params GetUserEntityMembershipParams) error
	// Get User entity PowerShell remote rights
	// (GET /api/v2/users/{object_id}/ps-remote-rights)
	GetUserEntityPsRemoteRights(ctx echo.Context, objectId PathObjectId, params GetUserEntityPsRemoteRightsParams) error
	// Get User entity RDP rights
	// (GET /api/v2/users/{object_id}/rdp-rights)
	GetUserEntityRdpRights(ctx echo.Context, objectId PathObjectId, params GetUserEntityRdpRightsParams) error
	// Get User entity sessions
	// (GET /api/v2/users/{object_id}/sessions)
	GetUserEntitySessions(ctx echo.Context, objectId PathObjectId, params GetUserEntitySessionsParams) error
	// Get User entity SQL admin rights
	// (GET /api/v2/users/{object_id}/sql-admin-rights)
	GetUserEntitySqlAdminRights(ctx echo.Context, objectId PathObjectId, params GetUserEntitySqlAdminRightsParams) error
	// Get API version
	// (GET /api/version)
	GetApiVersion(ctx echo.Context, params GetApiVersionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AcceptEula converts echo context to params.
func (w *ServerInterfaceWrapper) AcceptEula(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AcceptEulaParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AcceptEula(ctx, params)
	return err
}

// GetAdDomainDataQualityStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdDomainDataQualityStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "domain_id" -------------
	var domainId string

	err = runtime.BindStyledParameterWithOptions("simple", "domain_id", ctx.Param("domain_id"), &domainId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAdDomainDataQualityStatsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdDomainDataQualityStats(ctx, domainId, params)
	return err
}

// GetAiaCaEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetAiaCaEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAiaCaEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAiaCaEntity(ctx, objectId, params)
	return err
}

// GetAiaCaEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetAiaCaEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAiaCaEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAiaCaEntityControllers(ctx, objectId, params)
	return err
}

// StartAnalysis converts echo context to params.
func (w *ServerInterfaceWrapper) StartAnalysis(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params StartAnalysisParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StartAnalysis(ctx, params)
	return err
}

// ListAssetGroups converts echo context to params.
func (w *ServerInterfaceWrapper) ListAssetGroups(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAssetGroupsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "system_group" -------------

	err = runtime.BindQueryParameter("form", true, false, "system_group", ctx.QueryParams(), &params.SystemGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter system_group: %s", err))
	}

	// ------------- Optional query parameter "member_count" -------------

	err = runtime.BindQueryParameter("form", true, false, "member_count", ctx.QueryParams(), &params.MemberCount)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter member_count: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAssetGroups(ctx, params)
	return err
}

// CreateAssetGroup converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAssetGroup(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateAssetGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAssetGroup(ctx, params)
	return err
}

// DeleteAssetGroup converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAssetGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetGroup(ctx, assetGroupId, params)
	return err
}

// GetAssetGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetGroup(ctx, assetGroupId, params)
	return err
}

// UpdateAssetGroup converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAssetGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAssetGroupParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAssetGroup(ctx, assetGroupId, params)
	return err
}

// ListAssetGroupCollections converts echo context to params.
func (w *ServerInterfaceWrapper) ListAssetGroupCollections(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAssetGroupCollectionsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAssetGroupCollections(ctx, assetGroupId, params)
	return err
}

// GetAssetGroupComboNode converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetGroupComboNode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetGroupComboNodeParams
	// ------------- Optional query parameter "domainsid" -------------

	err = runtime.BindQueryParameter("form", true, false, "domainsid", ctx.QueryParams(), &params.Domainsid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domainsid: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetGroupComboNode(ctx, assetGroupId, params)
	return err
}

// GetAssetGroupCustomMemberCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetGroupCustomMemberCount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetGroupCustomMemberCountParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetGroupCustomMemberCount(ctx, assetGroupId, params)
	return err
}

// ListAssetGroupMembers converts echo context to params.
func (w *ServerInterfaceWrapper) ListAssetGroupMembers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAssetGroupMembersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "object_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "object_id", ctx.QueryParams(), &params.ObjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	// ------------- Optional query parameter "primary_kind" -------------

	err = runtime.BindQueryParameter("form", true, false, "primary_kind", ctx.QueryParams(), &params.PrimaryKind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter primary_kind: %s", err))
	}

	// ------------- Optional query parameter "environment_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment_id", ctx.QueryParams(), &params.EnvironmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment_id: %s", err))
	}

	// ------------- Optional query parameter "environment_kind" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment_kind", ctx.QueryParams(), &params.EnvironmentKind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment_kind: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "custom_member" -------------

	err = runtime.BindQueryParameter("form", true, false, "custom_member", ctx.QueryParams(), &params.CustomMember)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter custom_member: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAssetGroupMembers(ctx, assetGroupId, params)
	return err
}

// ListAssetGroupMemberCountByKind converts echo context to params.
func (w *ServerInterfaceWrapper) ListAssetGroupMemberCountByKind(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAssetGroupMemberCountByKindParams
	// ------------- Optional query parameter "object_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "object_id", ctx.QueryParams(), &params.ObjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	// ------------- Optional query parameter "environment_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment_id", ctx.QueryParams(), &params.EnvironmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment_id: %s", err))
	}

	// ------------- Optional query parameter "primary_kind" -------------

	err = runtime.BindQueryParameter("form", true, false, "primary_kind", ctx.QueryParams(), &params.PrimaryKind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter primary_kind: %s", err))
	}

	// ------------- Optional query parameter "environment_kind" -------------

	err = runtime.BindQueryParameter("form", true, false, "environment_kind", ctx.QueryParams(), &params.EnvironmentKind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter environment_kind: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "custom_member" -------------

	err = runtime.BindQueryParameter("form", true, false, "custom_member", ctx.QueryParams(), &params.CustomMember)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter custom_member: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAssetGroupMemberCountByKind(ctx, assetGroupId, params)
	return err
}

// UpdateAssetGroupSelectorsDeprecated converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAssetGroupSelectorsDeprecated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAssetGroupSelectorsDeprecatedParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAssetGroupSelectorsDeprecated(ctx, assetGroupId, params)
	return err
}

// UpdateAssetGroupSelectors converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAssetGroupSelectors(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAssetGroupSelectorsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAssetGroupSelectors(ctx, assetGroupId, params)
	return err
}

// DeleteAssetGroupSelector converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetGroupSelector(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset_group_id" -------------
	var assetGroupId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_id", ctx.Param("asset_group_id"), &assetGroupId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_id: %s", err))
	}

	// ------------- Path parameter "asset_group_selector_id" -------------
	var assetGroupSelectorId int32

	err = runtime.BindStyledParameterWithOptions("simple", "asset_group_selector_id", ctx.Param("asset_group_selector_id"), &assetGroupSelectorId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset_group_selector_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAssetGroupSelectorParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetGroupSelector(ctx, assetGroupId, assetGroupSelectorId, params)
	return err
}

// ListAttackPathTypes converts echo context to params.
func (w *ServerInterfaceWrapper) ListAttackPathTypes(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAttackPathTypesParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "finding", ctx.QueryParams(), &params.Finding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAttackPathTypes(ctx, params)
	return err
}

// StartAnalysisBhe converts echo context to params.
func (w *ServerInterfaceWrapper) StartAnalysisBhe(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params StartAnalysisBheParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StartAnalysisBhe(ctx, params)
	return err
}

// UpdateAttackPathRisk converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAttackPathRisk(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "attack_path_id" -------------
	var attackPathId int64

	err = runtime.BindStyledParameterWithOptions("simple", "attack_path_id", ctx.Param("attack_path_id"), &attackPathId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attack_path_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAttackPathRiskParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAttackPathRisk(ctx, attackPathId, params)
	return err
}

// ListAuditLogs converts echo context to params.
func (w *ServerInterfaceWrapper) ListAuditLogs(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuditLogsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "actor_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "actor_id", ctx.QueryParams(), &params.ActorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter actor_id: %s", err))
	}

	// ------------- Optional query parameter "actor_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "actor_name", ctx.QueryParams(), &params.ActorName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter actor_name: %s", err))
	}

	// ------------- Optional query parameter "actor_email" -------------

	err = runtime.BindQueryParameter("form", true, false, "actor_email", ctx.QueryParams(), &params.ActorEmail)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter actor_email: %s", err))
	}

	// ------------- Optional query parameter "action" -------------

	err = runtime.BindQueryParameter("form", true, false, "action", ctx.QueryParams(), &params.Action)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action: %s", err))
	}

	// ------------- Optional query parameter "request_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "request_id", ctx.QueryParams(), &params.RequestId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter request_id: %s", err))
	}

	// ------------- Optional query parameter "source" -------------

	err = runtime.BindQueryParameter("form", true, false, "source", ctx.QueryParams(), &params.Source)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAuditLogs(ctx, params)
	return err
}

// GetAvailableDomains converts echo context to params.
func (w *ServerInterfaceWrapper) GetAvailableDomains(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAvailableDomainsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "objectid" -------------

	err = runtime.BindQueryParameter("form", true, false, "objectid", ctx.QueryParams(), &params.Objectid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectid: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "collected" -------------

	err = runtime.BindQueryParameter("form", true, false, "collected", ctx.QueryParams(), &params.Collected)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collected: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAvailableDomains(ctx, params)
	return err
}

// GetAzureTenantDataQualityStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetAzureTenantDataQualityStats(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tenant_id" -------------
	var tenantId string

	err = runtime.BindStyledParameterWithOptions("simple", "tenant_id", ctx.Param("tenant_id"), &tenantId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tenant_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAzureTenantDataQualityStatsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAzureTenantDataQualityStats(ctx, tenantId, params)
	return err
}

// GetAzureEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetAzureEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "entity_type" -------------
	var entityType string

	err = runtime.BindStyledParameterWithOptions("simple", "entity_type", ctx.Param("entity_type"), &entityType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entity_type: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAzureEntityParams
	// ------------- Required query parameter "object_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "object_id", ctx.QueryParams(), &params.ObjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	// ------------- Optional query parameter "related_entity_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "related_entity_type", ctx.QueryParams(), &params.RelatedEntityType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter related_entity_type: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAzureEntity(ctx, entityType, params)
	return err
}

// GetEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEntity(ctx, objectId, params)
	return err
}

// GetEntityControllables converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntityControllables(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntityControllablesParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEntityControllables(ctx, objectId, params)
	return err
}

// GetEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEntityControllers(ctx, objectId, params)
	return err
}

// ListUsers converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsers(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "first_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "first_name", ctx.QueryParams(), &params.FirstName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first_name: %s", err))
	}

	// ------------- Optional query parameter "last_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_name", ctx.QueryParams(), &params.LastName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_name: %s", err))
	}

	// ------------- Optional query parameter "email_address" -------------

	err = runtime.BindQueryParameter("form", true, false, "email_address", ctx.QueryParams(), &params.EmailAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email_address: %s", err))
	}

	// ------------- Optional query parameter "principal_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "principal_name", ctx.QueryParams(), &params.PrincipalName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter principal_name: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "last_login" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_login", ctx.QueryParams(), &params.LastLogin)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_login: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUsers(ctx, params)
	return err
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateUserParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateUser(ctx, params)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteUserParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUser(ctx, userId, params)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUser(ctx, userId, params)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateUserParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateUser(ctx, userId, params)
	return err
}

// RemoveUserMfa converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveUserMfa(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RemoveUserMfaParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RemoveUserMfa(ctx, userId, params)
	return err
}

// AddUserMfa converts echo context to params.
func (w *ServerInterfaceWrapper) AddUserMfa(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddUserMfaParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AddUserMfa(ctx, userId, params)
	return err
}

// GetMfaActivationStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetMfaActivationStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMfaActivationStatusParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMfaActivationStatus(ctx, userId, params)
	return err
}

// ActivateUserMfa converts echo context to params.
func (w *ServerInterfaceWrapper) ActivateUserMfa(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ActivateUserMfaParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ActivateUserMfa(ctx, userId, params)
	return err
}

// DeleteUserSecret converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUserSecret(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteUserSecretParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteUserSecret(ctx, userId, params)
	return err
}

// CreateOrSetUserSecret converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOrSetUserSecret(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", ctx.Param("user_id"), &userId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrSetUserSecretParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOrSetUserSecret(ctx, userId, params)
	return err
}

// GetCertTemplateEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetCertTemplateEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCertTemplateEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCertTemplateEntity(ctx, objectId, params)
	return err
}

// GetCertTemplateEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetCertTemplateEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCertTemplateEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCertTemplateEntityControllers(ctx, objectId, params)
	return err
}

// DeleteBloodHoundDatabase converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBloodHoundDatabase(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteBloodHoundDatabaseParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteBloodHoundDatabase(ctx, params)
	return err
}

// ListClients converts echo context to params.
func (w *ServerInterfaceWrapper) ListClients(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListClientsParams
	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "hydrate_domains" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_domains", ctx.QueryParams(), &params.HydrateDomains)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_domains: %s", err))
	}

	// ------------- Optional query parameter "hydrate_ous" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_ous", ctx.QueryParams(), &params.HydrateOus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_ous: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "ip_address" -------------

	err = runtime.BindQueryParameter("form", true, false, "ip_address", ctx.QueryParams(), &params.IpAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ip_address: %s", err))
	}

	// ------------- Optional query parameter "hostname" -------------

	err = runtime.BindQueryParameter("form", true, false, "hostname", ctx.QueryParams(), &params.Hostname)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hostname: %s", err))
	}

	// ------------- Optional query parameter "configured_user" -------------

	err = runtime.BindQueryParameter("form", true, false, "configured_user", ctx.QueryParams(), &params.ConfiguredUser)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter configured_user: %s", err))
	}

	// ------------- Optional query parameter "version" -------------

	err = runtime.BindQueryParameter("form", true, false, "version", ctx.QueryParams(), &params.Version)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// ------------- Optional query parameter "user_sid" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_sid", ctx.QueryParams(), &params.UserSid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_sid: %s", err))
	}

	// ------------- Optional query parameter "last_checkin" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_checkin", ctx.QueryParams(), &params.LastCheckin)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_checkin: %s", err))
	}

	// ------------- Optional query parameter "current_job_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "current_job_id", ctx.QueryParams(), &params.CurrentJobId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter current_job_id: %s", err))
	}

	// ------------- Optional query parameter "completed_job_count" -------------

	err = runtime.BindQueryParameter("form", true, false, "completed_job_count", ctx.QueryParams(), &params.CompletedJobCount)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter completed_job_count: %s", err))
	}

	// ------------- Optional query parameter "domain_controller" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_controller", ctx.QueryParams(), &params.DomainController)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_controller: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListClients(ctx, params)
	return err
}

// CreateClient converts echo context to params.
func (w *ServerInterfaceWrapper) CreateClient(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateClientParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateClient(ctx, params)
	return err
}

// LogClientError converts echo context to params.
func (w *ServerInterfaceWrapper) LogClientError(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LogClientErrorParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LogClientError(ctx, params)
	return err
}

// UpdateClientInfo converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateClientInfo(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateClientInfoParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateClientInfo(ctx, params)
	return err
}

// DeleteClient converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteClient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_id" -------------
	var clientId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "client_id", ctx.Param("client_id"), &clientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteClientParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteClient(ctx, clientId, params)
	return err
}

// GetClient converts echo context to params.
func (w *ServerInterfaceWrapper) GetClient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_id" -------------
	var clientId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "client_id", ctx.Param("client_id"), &clientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetClient(ctx, clientId, params)
	return err
}

// UpdateClient converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateClient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_id" -------------
	var clientId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "client_id", ctx.Param("client_id"), &clientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateClientParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateClient(ctx, clientId, params)
	return err
}

// ListClientCompletedJobs converts echo context to params.
func (w *ServerInterfaceWrapper) ListClientCompletedJobs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_id" -------------
	var clientId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "client_id", ctx.Param("client_id"), &clientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListClientCompletedJobsParams
	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "hydrate_domains" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_domains", ctx.QueryParams(), &params.HydrateDomains)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_domains: %s", err))
	}

	// ------------- Optional query parameter "hydrate_ous" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_ous", ctx.QueryParams(), &params.HydrateOus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_ous: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "log_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "log_path", ctx.QueryParams(), &params.LogPath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter log_path: %s", err))
	}

	// ------------- Optional query parameter "session_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "session_collection", ctx.QueryParams(), &params.SessionCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_collection: %s", err))
	}

	// ------------- Optional query parameter "local_group_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "local_group_collection", ctx.QueryParams(), &params.LocalGroupCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local_group_collection: %s", err))
	}

	// ------------- Optional query parameter "cert_services_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "cert_services_collection", ctx.QueryParams(), &params.CertServicesCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cert_services_collection: %s", err))
	}

	// ------------- Optional query parameter "ca_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ca_registry_collection", ctx.QueryParams(), &params.CaRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ca_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "dc_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "dc_registry_collection", ctx.QueryParams(), &params.DcRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dc_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "ad_structure_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ad_structure_collection", ctx.QueryParams(), &params.AdStructureCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ad_structure_collection: %s", err))
	}

	// ------------- Optional query parameter "domain_controller" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_controller", ctx.QueryParams(), &params.DomainController)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_controller: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "event_title" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_title", ctx.QueryParams(), &params.EventTitle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_title: %s", err))
	}

	// ------------- Optional query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// ------------- Optional query parameter "event_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_id", ctx.QueryParams(), &params.EventId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// ------------- Optional query parameter "execution_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "execution_time", ctx.QueryParams(), &params.ExecutionTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter execution_time: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "last_ingest" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_ingest", ctx.QueryParams(), &params.LastIngest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_ingest: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListClientCompletedJobs(ctx, clientId, params)
	return err
}

// ListClientCompletedTasks converts echo context to params.
func (w *ServerInterfaceWrapper) ListClientCompletedTasks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_id" -------------
	var clientId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "client_id", ctx.Param("client_id"), &clientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListClientCompletedTasksParams
	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "hydrate_domains" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_domains", ctx.QueryParams(), &params.HydrateDomains)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_domains: %s", err))
	}

	// ------------- Optional query parameter "hydrate_ous" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_ous", ctx.QueryParams(), &params.HydrateOus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_ous: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "log_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "log_path", ctx.QueryParams(), &params.LogPath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter log_path: %s", err))
	}

	// ------------- Optional query parameter "session_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "session_collection", ctx.QueryParams(), &params.SessionCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_collection: %s", err))
	}

	// ------------- Optional query parameter "local_group_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "local_group_collection", ctx.QueryParams(), &params.LocalGroupCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local_group_collection: %s", err))
	}

	// ------------- Optional query parameter "cert_services_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "cert_services_collection", ctx.QueryParams(), &params.CertServicesCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cert_services_collection: %s", err))
	}

	// ------------- Optional query parameter "ca_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ca_registry_collection", ctx.QueryParams(), &params.CaRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ca_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "dc_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "dc_registry_collection", ctx.QueryParams(), &params.DcRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dc_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "ad_structure_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ad_structure_collection", ctx.QueryParams(), &params.AdStructureCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ad_structure_collection: %s", err))
	}

	// ------------- Optional query parameter "domain_controller" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_controller", ctx.QueryParams(), &params.DomainController)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_controller: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "event_title" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_title", ctx.QueryParams(), &params.EventTitle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_title: %s", err))
	}

	// ------------- Optional query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// ------------- Optional query parameter "event_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_id", ctx.QueryParams(), &params.EventId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// ------------- Optional query parameter "execution_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "execution_time", ctx.QueryParams(), &params.ExecutionTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter execution_time: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "last_ingest" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_ingest", ctx.QueryParams(), &params.LastIngest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_ingest: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListClientCompletedTasks(ctx, clientId, params)
	return err
}

// CreateClientScheduledJob converts echo context to params.
func (w *ServerInterfaceWrapper) CreateClientScheduledJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_id" -------------
	var clientId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "client_id", ctx.Param("client_id"), &clientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateClientScheduledJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateClientScheduledJob(ctx, clientId, params)
	return err
}

// CreateClientScheduledTask converts echo context to params.
func (w *ServerInterfaceWrapper) CreateClientScheduledTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_id" -------------
	var clientId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "client_id", ctx.Param("client_id"), &clientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateClientScheduledTaskParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateClientScheduledTask(ctx, clientId, params)
	return err
}

// ReplaceClientToken converts echo context to params.
func (w *ServerInterfaceWrapper) ReplaceClientToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_id" -------------
	var clientId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "client_id", ctx.Param("client_id"), &clientId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ReplaceClientTokenParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReplaceClientToken(ctx, clientId, params)
	return err
}

// GetCollectorManifest converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectorManifest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collector_type" -------------
	var collectorType EnumClientType

	err = runtime.BindStyledParameterWithOptions("simple", "collector_type", ctx.Param("collector_type"), &collectorType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collector_type: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectorManifestParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectorManifest(ctx, collectorType, params)
	return err
}

// DownloadCollector converts echo context to params.
func (w *ServerInterfaceWrapper) DownloadCollector(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collector_type" -------------
	var collectorType EnumClientType

	err = runtime.BindStyledParameterWithOptions("simple", "collector_type", ctx.Param("collector_type"), &collectorType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collector_type: %s", err))
	}

	// ------------- Path parameter "release_tag" -------------
	var releaseTag string

	err = runtime.BindStyledParameterWithOptions("simple", "release_tag", ctx.Param("release_tag"), &releaseTag, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter release_tag: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadCollectorParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DownloadCollector(ctx, collectorType, releaseTag, params)
	return err
}

// GetCollectorChecksum converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectorChecksum(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "collector_type" -------------
	var collectorType EnumClientType

	err = runtime.BindStyledParameterWithOptions("simple", "collector_type", ctx.Param("collector_type"), &collectorType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter collector_type: %s", err))
	}

	// ------------- Path parameter "release_tag" -------------
	var releaseTag string

	err = runtime.BindStyledParameterWithOptions("simple", "release_tag", ctx.Param("release_tag"), &releaseTag, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter release_tag: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectorChecksumParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectorChecksum(ctx, collectorType, releaseTag, params)
	return err
}

// GetCompletenessStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetCompletenessStats(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCompletenessStatsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCompletenessStats(ctx, params)
	return err
}

// GetComputerEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntity(ctx, objectId, params)
	return err
}

// GetComputerEntityAdminRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityAdminRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityAdminRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityAdminRights(ctx, objectId, params)
	return err
}

// GetComputerEntityAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityAdmins(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityAdminsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityAdmins(ctx, objectId, params)
	return err
}

// GetComputerEntityConstrainedDelegationRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityConstrainedDelegationRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityConstrainedDelegationRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityConstrainedDelegationRights(ctx, objectId, params)
	return err
}

// GetComputerEntityConstrainedUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityConstrainedUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityConstrainedUsersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityConstrainedUsers(ctx, objectId, params)
	return err
}

// GetComputerEntityControllables converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityControllables(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityControllablesParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityControllables(ctx, objectId, params)
	return err
}

// GetComputerEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityControllers(ctx, objectId, params)
	return err
}

// GetComputerEntityDcomRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityDcomRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityDcomRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityDcomRights(ctx, objectId, params)
	return err
}

// GetComputerEntityDcomUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityDcomUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityDcomUsersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityDcomUsers(ctx, objectId, params)
	return err
}

// GetComputerEntityGroupMembership converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityGroupMembership(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityGroupMembershipParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityGroupMembership(ctx, objectId, params)
	return err
}

// GetComputerEntityPsRemoteRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityPsRemoteRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityPsRemoteRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityPsRemoteRights(ctx, objectId, params)
	return err
}

// GetComputerEntityPsRemoteUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityPsRemoteUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityPsRemoteUsersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityPsRemoteUsers(ctx, objectId, params)
	return err
}

// GetComputerEntityRdpRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityRdpRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityRdpRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityRdpRights(ctx, objectId, params)
	return err
}

// GetComputerEntityRdpUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntityRdpUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntityRdpUsersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntityRdpUsers(ctx, objectId, params)
	return err
}

// GetComputerEntitySessions converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntitySessions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntitySessionsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntitySessions(ctx, objectId, params)
	return err
}

// GetComputerEntitySqlAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetComputerEntitySqlAdmins(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComputerEntitySqlAdminsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComputerEntitySqlAdmins(ctx, objectId, params)
	return err
}

// ListAppConfigParams converts echo context to params.
func (w *ServerInterfaceWrapper) ListAppConfigParams(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAppConfigParamsParams
	// ------------- Optional query parameter "parameter" -------------

	err = runtime.BindQueryParameter("form", true, false, "parameter", ctx.QueryParams(), &params.Parameter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parameter: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAppConfigParams(ctx, params)
	return err
}

// SetAppConfigParam converts echo context to params.
func (w *ServerInterfaceWrapper) SetAppConfigParam(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetAppConfigParamParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetAppConfigParam(ctx, params)
	return err
}

// GetContainerEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContainerEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerEntity(ctx, objectId, params)
	return err
}

// GetContainerEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContainerEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerEntityControllers(ctx, objectId, params)
	return err
}

// GetDatapipeStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetDatapipeStatus(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDatapipeStatusParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDatapipeStatus(ctx, params)
	return err
}

// ExportAttackPathFindings converts echo context to params.
func (w *ServerInterfaceWrapper) ExportAttackPathFindings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "domain_id" -------------
	var domainId string

	err = runtime.BindStyledParameterWithOptions("simple", "domain_id", ctx.Param("domain_id"), &domainId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportAttackPathFindingsParams
	// ------------- Required query parameter "finding" -------------

	err = runtime.BindQueryParameter("form", true, true, "finding", ctx.QueryParams(), &params.Finding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding: %s", err))
	}

	// ------------- Optional query parameter "filterAccepted" -------------

	err = runtime.BindQueryParameter("form", true, false, "filterAccepted", ctx.QueryParams(), &params.FilterAccepted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterAccepted: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportAttackPathFindings(ctx, domainId, params)
	return err
}

// ListAvailableAttackPathTypesForDomain converts echo context to params.
func (w *ServerInterfaceWrapper) ListAvailableAttackPathTypesForDomain(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "domain_id" -------------
	var domainId string

	err = runtime.BindStyledParameterWithOptions("simple", "domain_id", ctx.Param("domain_id"), &domainId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAvailableAttackPathTypesForDomainParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "finding", ctx.QueryParams(), &params.Finding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAvailableAttackPathTypesForDomain(ctx, domainId, params)
	return err
}

// ListDomainAttackPathsDetails converts echo context to params.
func (w *ServerInterfaceWrapper) ListDomainAttackPathsDetails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "domain_id" -------------
	var domainId string

	err = runtime.BindStyledParameterWithOptions("simple", "domain_id", ctx.Param("domain_id"), &domainId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDomainAttackPathsDetailsParams
	// ------------- Optional query parameter "finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "finding", ctx.QueryParams(), &params.FindingDeprecated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "FromPrincipal" -------------

	err = runtime.BindQueryParameter("form", true, false, "FromPrincipal", ctx.QueryParams(), &params.FromPrincipalDeprecated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter FromPrincipal: %s", err))
	}

	// ------------- Optional query parameter "ToPrincipal" -------------

	err = runtime.BindQueryParameter("form", true, false, "ToPrincipal", ctx.QueryParams(), &params.ToPrincipalDeprecated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ToPrincipal: %s", err))
	}

	// ------------- Optional query parameter "from_principal" -------------

	err = runtime.BindQueryParameter("form", true, false, "from_principal", ctx.QueryParams(), &params.FromPrincipal)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_principal: %s", err))
	}

	// ------------- Optional query parameter "to_principal" -------------

	err = runtime.BindQueryParameter("form", true, false, "to_principal", ctx.QueryParams(), &params.ToPrincipal)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_principal: %s", err))
	}

	// ------------- Optional query parameter "principals_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "principals_hash", ctx.QueryParams(), &params.PrincipalsHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter principals_hash: %s", err))
	}

	// ------------- Optional query parameter "Accepted" -------------

	err = runtime.BindQueryParameter("form", true, false, "Accepted", ctx.QueryParams(), &params.Accepted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accepted: %s", err))
	}

	// ------------- Optional query parameter "AcceptedUntil" -------------

	err = runtime.BindQueryParameter("form", true, false, "AcceptedUntil", ctx.QueryParams(), &params.AcceptedUntilDeprecated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter AcceptedUntil: %s", err))
	}

	// ------------- Optional query parameter "accepted_until" -------------

	err = runtime.BindQueryParameter("form", true, false, "accepted_until", ctx.QueryParams(), &params.AcceptedUntil)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter accepted_until: %s", err))
	}

	// ------------- Optional query parameter "Principal" -------------

	err = runtime.BindQueryParameter("form", true, false, "Principal", ctx.QueryParams(), &params.Principal)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Principal: %s", err))
	}

	// ------------- Optional query parameter "Finding" -------------

	err = runtime.BindQueryParameter("form", true, false, "Finding", ctx.QueryParams(), &params.Finding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Finding: %s", err))
	}

	// ------------- Optional query parameter "domain_sid" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_sid", ctx.QueryParams(), &params.DomainSid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_sid: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDomainAttackPathsDetails(ctx, domainId, params)
	return err
}

// ListAttackPathSparklineValues converts echo context to params.
func (w *ServerInterfaceWrapper) ListAttackPathSparklineValues(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "domain_id" -------------
	var domainId string

	err = runtime.BindStyledParameterWithOptions("simple", "domain_id", ctx.Param("domain_id"), &domainId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAttackPathSparklineValuesParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Required query parameter "finding" -------------

	err = runtime.BindQueryParameter("form", true, true, "finding", ctx.QueryParams(), &params.Finding)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter finding: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.From)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.To)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAttackPathSparklineValues(ctx, domainId, params)
	return err
}

// GetDomainEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntity(ctx, objectId, params)
	return err
}

// UpdateDomainEntity converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDomainEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateDomainEntityParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDomainEntity(ctx, objectId, params)
	return err
}

// GetDomainEntityComputers converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityComputers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityComputersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityComputers(ctx, objectId, params)
	return err
}

// GetDomainEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityControllers(ctx, objectId, params)
	return err
}

// GetDomainEntityDcSyncers converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityDcSyncers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityDcSyncersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityDcSyncers(ctx, objectId, params)
	return err
}

// GetDomainEntityForeignAdmins converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityForeignAdmins(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityForeignAdminsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityForeignAdmins(ctx, objectId, params)
	return err
}

// GetDomainEntityForeignGpoControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityForeignGpoControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityForeignGpoControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityForeignGpoControllers(ctx, objectId, params)
	return err
}

// GetDomainEntityForeignGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityForeignGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityForeignGroupsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityForeignGroups(ctx, objectId, params)
	return err
}

// GetDomainEntityForeignUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityForeignUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityForeignUsersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityForeignUsers(ctx, objectId, params)
	return err
}

// GetDomainEntityGpos converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityGpos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityGposParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityGpos(ctx, objectId, params)
	return err
}

// GetDomainEntityGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityGroupsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityGroups(ctx, objectId, params)
	return err
}

// GetDomainEntityInboundTrusts converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityInboundTrusts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityInboundTrustsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityInboundTrusts(ctx, objectId, params)
	return err
}

// GetDomainEntityLinkedGpos converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityLinkedGpos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityLinkedGposParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityLinkedGpos(ctx, objectId, params)
	return err
}

// GetDomainEntityOus converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityOus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityOusParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityOus(ctx, objectId, params)
	return err
}

// GetDomainEntityOutboundTrusts converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityOutboundTrusts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityOutboundTrustsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityOutboundTrusts(ctx, objectId, params)
	return err
}

// GetDomainEntityUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetDomainEntityUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDomainEntityUsersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDomainEntityUsers(ctx, objectId, params)
	return err
}

// GetEnterpriseCaEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetEnterpriseCaEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEnterpriseCaEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEnterpriseCaEntity(ctx, objectId, params)
	return err
}

// GetEnterpriseCaEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetEnterpriseCaEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEnterpriseCaEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEnterpriseCaEntityControllers(ctx, objectId, params)
	return err
}

// ListClientSchedules converts echo context to params.
func (w *ServerInterfaceWrapper) ListClientSchedules(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListClientSchedulesParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "rrule" -------------

	err = runtime.BindQueryParameter("form", true, false, "rrule", ctx.QueryParams(), &params.Rrule)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rrule: %s", err))
	}

	// ------------- Optional query parameter "next_scheduled_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "next_scheduled_at", ctx.QueryParams(), &params.NextScheduledAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next_scheduled_at: %s", err))
	}

	// ------------- Optional query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// ------------- Optional query parameter "session_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "session_collection", ctx.QueryParams(), &params.SessionCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_collection: %s", err))
	}

	// ------------- Optional query parameter "local_group_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "local_group_collection", ctx.QueryParams(), &params.LocalGroupCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local_group_collection: %s", err))
	}

	// ------------- Optional query parameter "ad_structure_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ad_structure_collection", ctx.QueryParams(), &params.AdStructureCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ad_structure_collection: %s", err))
	}

	// ------------- Optional query parameter "cert_services_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "cert_services_collection", ctx.QueryParams(), &params.CertServicesCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cert_services_collection: %s", err))
	}

	// ------------- Optional query parameter "ca_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ca_registry_collection", ctx.QueryParams(), &params.CaRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ca_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "dc_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "dc_registry_collection", ctx.QueryParams(), &params.DcRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dc_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "hydrate_domains" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_domains", ctx.QueryParams(), &params.HydrateDomains)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_domains: %s", err))
	}

	// ------------- Optional query parameter "hydrate_ous" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_ous", ctx.QueryParams(), &params.HydrateOus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_ous: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListClientSchedules(ctx, params)
	return err
}

// CreateClientSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) CreateClientSchedule(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateClientScheduleParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateClientSchedule(ctx, params)
	return err
}

// DeleteClientEvent converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteClientEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "event_id" -------------
	var eventId int32

	err = runtime.BindStyledParameterWithOptions("simple", "event_id", ctx.Param("event_id"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteClientEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteClientEvent(ctx, eventId, params)
	return err
}

// GetClientSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "event_id" -------------
	var eventId int32

	err = runtime.BindStyledParameterWithOptions("simple", "event_id", ctx.Param("event_id"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientScheduleParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetClientSchedule(ctx, eventId, params)
	return err
}

// UpdateClientEvent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateClientEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "event_id" -------------
	var eventId int32

	err = runtime.BindStyledParameterWithOptions("simple", "event_id", ctx.Param("event_id"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateClientEventParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateClientEvent(ctx, eventId, params)
	return err
}

// ListFeatureFlags converts echo context to params.
func (w *ServerInterfaceWrapper) ListFeatureFlags(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFeatureFlagsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListFeatureFlags(ctx, params)
	return err
}

// ToggleFeatureFlag converts echo context to params.
func (w *ServerInterfaceWrapper) ToggleFeatureFlag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "feature_id" -------------
	var featureId int32

	err = runtime.BindStyledParameterWithOptions("simple", "feature_id", ctx.Param("feature_id"), &featureId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter feature_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ToggleFeatureFlagParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ToggleFeatureFlag(ctx, featureId, params)
	return err
}

// ListFileUploadJobs converts echo context to params.
func (w *ServerInterfaceWrapper) ListFileUploadJobs(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFileUploadJobsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "user_email_address" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_email_address", ctx.QueryParams(), &params.UserEmailAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_email_address: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "status_message" -------------

	err = runtime.BindQueryParameter("form", true, false, "status_message", ctx.QueryParams(), &params.StatusMessage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status_message: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "last_ingest" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_ingest", ctx.QueryParams(), &params.LastIngest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_ingest: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListFileUploadJobs(ctx, params)
	return err
}

// ListAcceptedFileUploadTypes converts echo context to params.
func (w *ServerInterfaceWrapper) ListAcceptedFileUploadTypes(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAcceptedFileUploadTypesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAcceptedFileUploadTypes(ctx, params)
	return err
}

// CreateFileUploadJob converts echo context to params.
func (w *ServerInterfaceWrapper) CreateFileUploadJob(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateFileUploadJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateFileUploadJob(ctx, params)
	return err
}

// UploadFileToJob converts echo context to params.
func (w *ServerInterfaceWrapper) UploadFileToJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "file_upload_job_id" -------------
	var fileUploadJobId int64

	err = runtime.BindStyledParameterWithOptions("simple", "file_upload_job_id", ctx.Param("file_upload_job_id"), &fileUploadJobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter file_upload_job_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadFileToJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}
	// ------------- Required header parameter "Content-Type" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Type")]; found {
		var ContentType string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Content-Type, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Content-Type", valueList[0], &ContentType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Content-Type: %s", err))
		}

		params.ContentType = ContentType
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Content-Type is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UploadFileToJob(ctx, fileUploadJobId, params)
	return err
}

// EndFileUploadJob converts echo context to params.
func (w *ServerInterfaceWrapper) EndFileUploadJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "file_upload_job_id" -------------
	var fileUploadJobId int64

	err = runtime.BindStyledParameterWithOptions("simple", "file_upload_job_id", ctx.Param("file_upload_job_id"), &fileUploadJobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter file_upload_job_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params EndFileUploadJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EndFileUploadJob(ctx, fileUploadJobId, params)
	return err
}

// GetGpoEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetGpoEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGpoEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGpoEntity(ctx, objectId, params)
	return err
}

// GetGpoEntityComputers converts echo context to params.
func (w *ServerInterfaceWrapper) GetGpoEntityComputers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGpoEntityComputersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGpoEntityComputers(ctx, objectId, params)
	return err
}

// GetGpoEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetGpoEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGpoEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGpoEntityControllers(ctx, objectId, params)
	return err
}

// GetGpoEntityOus converts echo context to params.
func (w *ServerInterfaceWrapper) GetGpoEntityOus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGpoEntityOusParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGpoEntityOus(ctx, objectId, params)
	return err
}

// GetGpoEntityTierZero converts echo context to params.
func (w *ServerInterfaceWrapper) GetGpoEntityTierZero(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGpoEntityTierZeroParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGpoEntityTierZero(ctx, objectId, params)
	return err
}

// GetGpoEntityUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetGpoEntityUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGpoEntityUsersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGpoEntityUsers(ctx, objectId, params)
	return err
}

// GetSearchResult converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchResult(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSearchResultParams
	// ------------- Required query parameter "search_query" -------------

	err = runtime.BindQueryParameter("form", true, true, "search_query", ctx.QueryParams(), &params.SearchQuery)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search_query: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSearchResult(ctx, params)
	return err
}

// RunCypherQuery converts echo context to params.
func (w *ServerInterfaceWrapper) RunCypherQuery(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunCypherQueryParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RunCypherQuery(ctx, params)
	return err
}

// GetPathComposition converts echo context to params.
func (w *ServerInterfaceWrapper) GetPathComposition(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPathCompositionParams
	// ------------- Required query parameter "source_node" -------------

	err = runtime.BindQueryParameter("form", true, true, "source_node", ctx.QueryParams(), &params.SourceNode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_node: %s", err))
	}

	// ------------- Required query parameter "target_node" -------------

	err = runtime.BindQueryParameter("form", true, true, "target_node", ctx.QueryParams(), &params.TargetNode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target_node: %s", err))
	}

	// ------------- Required query parameter "edge_type" -------------

	err = runtime.BindQueryParameter("form", true, true, "edge_type", ctx.QueryParams(), &params.EdgeType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter edge_type: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPathComposition(ctx, params)
	return err
}

// GetShortestPath converts echo context to params.
func (w *ServerInterfaceWrapper) GetShortestPath(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShortestPathParams
	// ------------- Required query parameter "start_node" -------------

	err = runtime.BindQueryParameter("form", true, true, "start_node", ctx.QueryParams(), &params.StartNode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_node: %s", err))
	}

	// ------------- Required query parameter "end_node" -------------

	err = runtime.BindQueryParameter("form", true, true, "end_node", ctx.QueryParams(), &params.EndNode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_node: %s", err))
	}

	// ------------- Optional query parameter "relationship_kinds" -------------

	err = runtime.BindQueryParameter("form", true, false, "relationship_kinds", ctx.QueryParams(), &params.RelationshipKinds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter relationship_kinds: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetShortestPath(ctx, params)
	return err
}

// GetGroupEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntity(ctx, objectId, params)
	return err
}

// GetGroupEntityAdminRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntityAdminRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityAdminRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntityAdminRights(ctx, objectId, params)
	return err
}

// GetGroupEntityControllables converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntityControllables(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityControllablesParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntityControllables(ctx, objectId, params)
	return err
}

// GetGroupEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntityControllers(ctx, objectId, params)
	return err
}

// GetGroupEntityDcomRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntityDcomRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityDcomRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntityDcomRights(ctx, objectId, params)
	return err
}

// GetGroupEntityMembers converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntityMembers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityMembersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntityMembers(ctx, objectId, params)
	return err
}

// GetGroupEntityMemberships converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntityMemberships(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityMembershipsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntityMemberships(ctx, objectId, params)
	return err
}

// GetGroupEntityPsRemoteRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntityPsRemoteRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityPsRemoteRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntityPsRemoteRights(ctx, objectId, params)
	return err
}

// GetGroupEntityRdpRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntityRdpRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntityRdpRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntityRdpRights(ctx, objectId, params)
	return err
}

// GetGroupEntitySessions converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroupEntitySessions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupEntitySessionsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetGroupEntitySessions(ctx, objectId, params)
	return err
}

// IngestData converts echo context to params.
func (w *ServerInterfaceWrapper) IngestData(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params IngestDataParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.IngestData(ctx, params)
	return err
}

// GetClientJobs converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientJobs(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientJobsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "log_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "log_path", ctx.QueryParams(), &params.LogPath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter log_path: %s", err))
	}

	// ------------- Optional query parameter "session_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "session_collection", ctx.QueryParams(), &params.SessionCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_collection: %s", err))
	}

	// ------------- Optional query parameter "local_group_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "local_group_collection", ctx.QueryParams(), &params.LocalGroupCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local_group_collection: %s", err))
	}

	// ------------- Optional query parameter "cert_services_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "cert_services_collection", ctx.QueryParams(), &params.CertServicesCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cert_services_collection: %s", err))
	}

	// ------------- Optional query parameter "ca_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ca_registry_collection", ctx.QueryParams(), &params.CaRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ca_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "dc_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "dc_registry_collection", ctx.QueryParams(), &params.DcRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dc_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "ad_structure_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ad_structure_collection", ctx.QueryParams(), &params.AdStructureCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ad_structure_collection: %s", err))
	}

	// ------------- Optional query parameter "domain_controller" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_controller", ctx.QueryParams(), &params.DomainController)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_controller: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "event_title" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_title", ctx.QueryParams(), &params.EventTitle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_title: %s", err))
	}

	// ------------- Optional query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// ------------- Optional query parameter "event_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_id", ctx.QueryParams(), &params.EventId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// ------------- Optional query parameter "execution_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "execution_time", ctx.QueryParams(), &params.ExecutionTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter execution_time: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "last_ingest" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_ingest", ctx.QueryParams(), &params.LastIngest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_ingest: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetClientJobs(ctx, params)
	return err
}

// ListAvailableClientJobs converts echo context to params.
func (w *ServerInterfaceWrapper) ListAvailableClientJobs(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAvailableClientJobsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "log_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "log_path", ctx.QueryParams(), &params.LogPath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter log_path: %s", err))
	}

	// ------------- Optional query parameter "session_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "session_collection", ctx.QueryParams(), &params.SessionCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_collection: %s", err))
	}

	// ------------- Optional query parameter "local_group_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "local_group_collection", ctx.QueryParams(), &params.LocalGroupCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local_group_collection: %s", err))
	}

	// ------------- Optional query parameter "cert_services_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "cert_services_collection", ctx.QueryParams(), &params.CertServicesCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cert_services_collection: %s", err))
	}

	// ------------- Optional query parameter "ca_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ca_registry_collection", ctx.QueryParams(), &params.CaRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ca_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "dc_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "dc_registry_collection", ctx.QueryParams(), &params.DcRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dc_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "ad_structure_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ad_structure_collection", ctx.QueryParams(), &params.AdStructureCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ad_structure_collection: %s", err))
	}

	// ------------- Optional query parameter "domain_controller" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_controller", ctx.QueryParams(), &params.DomainController)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_controller: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "event_title" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_title", ctx.QueryParams(), &params.EventTitle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_title: %s", err))
	}

	// ------------- Optional query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// ------------- Optional query parameter "event_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_id", ctx.QueryParams(), &params.EventId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// ------------- Optional query parameter "execution_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "execution_time", ctx.QueryParams(), &params.ExecutionTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter execution_time: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "last_ingest" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_ingest", ctx.QueryParams(), &params.LastIngest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_ingest: %s", err))
	}

	// ------------- Optional query parameter "hydrate_ous" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_ous", ctx.QueryParams(), &params.HydrateOus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_ous: %s", err))
	}

	// ------------- Optional query parameter "hydrate_domains" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_domains", ctx.QueryParams(), &params.HydrateDomains)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_domains: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAvailableClientJobs(ctx, params)
	return err
}

// GetClientCurrentJob converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientCurrentJob(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientCurrentJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetClientCurrentJob(ctx, params)
	return err
}

// EndClientJob converts echo context to params.
func (w *ServerInterfaceWrapper) EndClientJob(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params EndClientJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EndClientJob(ctx, params)
	return err
}

// ListClientFinishedJobs converts echo context to params.
func (w *ServerInterfaceWrapper) ListClientFinishedJobs(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListClientFinishedJobsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "log_path" -------------

	err = runtime.BindQueryParameter("form", true, false, "log_path", ctx.QueryParams(), &params.LogPath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter log_path: %s", err))
	}

	// ------------- Optional query parameter "session_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "session_collection", ctx.QueryParams(), &params.SessionCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_collection: %s", err))
	}

	// ------------- Optional query parameter "local_group_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "local_group_collection", ctx.QueryParams(), &params.LocalGroupCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local_group_collection: %s", err))
	}

	// ------------- Optional query parameter "cert_services_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "cert_services_collection", ctx.QueryParams(), &params.CertServicesCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cert_services_collection: %s", err))
	}

	// ------------- Optional query parameter "ca_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ca_registry_collection", ctx.QueryParams(), &params.CaRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ca_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "dc_registry_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "dc_registry_collection", ctx.QueryParams(), &params.DcRegistryCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dc_registry_collection: %s", err))
	}

	// ------------- Optional query parameter "ad_structure_collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "ad_structure_collection", ctx.QueryParams(), &params.AdStructureCollection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ad_structure_collection: %s", err))
	}

	// ------------- Optional query parameter "domain_controller" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_controller", ctx.QueryParams(), &params.DomainController)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_controller: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "event_title" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_title", ctx.QueryParams(), &params.EventTitle)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_title: %s", err))
	}

	// ------------- Optional query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// ------------- Optional query parameter "event_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "event_id", ctx.QueryParams(), &params.EventId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event_id: %s", err))
	}

	// ------------- Optional query parameter "execution_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "execution_time", ctx.QueryParams(), &params.ExecutionTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter execution_time: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_time", ctx.QueryParams(), &params.EndTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_time: %s", err))
	}

	// ------------- Optional query parameter "last_ingest" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_ingest", ctx.QueryParams(), &params.LastIngest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_ingest: %s", err))
	}

	// ------------- Optional query parameter "hydrate_domains" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_domains", ctx.QueryParams(), &params.HydrateDomains)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_domains: %s", err))
	}

	// ------------- Optional query parameter "hydrate_ous" -------------

	err = runtime.BindQueryParameter("form", true, false, "hydrate_ous", ctx.QueryParams(), &params.HydrateOus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hydrate_ous: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListClientFinishedJobs(ctx, params)
	return err
}

// StartClientJob converts echo context to params.
func (w *ServerInterfaceWrapper) StartClientJob(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params StartClientJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StartClientJob(ctx, params)
	return err
}

// GetClientJob converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "job_id" -------------
	var jobId int64

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", ctx.Param("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter job_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetClientJob(ctx, jobId, params)
	return err
}

// CancelClientJob converts echo context to params.
func (w *ServerInterfaceWrapper) CancelClientJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "job_id" -------------
	var jobId int64

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", ctx.Param("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter job_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CancelClientJobParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CancelClientJob(ctx, jobId, params)
	return err
}

// GetClientJobLog converts echo context to params.
func (w *ServerInterfaceWrapper) GetClientJobLog(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "job_id" -------------
	var jobId int64

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", ctx.Param("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter job_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClientJobLogParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetClientJobLog(ctx, jobId, params)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LoginParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Login(ctx, params)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LogoutParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Logout(ctx, params)
	return err
}

// GetLatestTierZeroComboNode converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestTierZeroComboNode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "domain_id" -------------
	var domainId string

	err = runtime.BindStyledParameterWithOptions("simple", "domain_id", ctx.Param("domain_id"), &domainId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLatestTierZeroComboNodeParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestTierZeroComboNode(ctx, domainId, params)
	return err
}

// GetComboTreeGraph converts echo context to params.
func (w *ServerInterfaceWrapper) GetComboTreeGraph(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "domain_id" -------------
	var domainId string

	err = runtime.BindStyledParameterWithOptions("simple", "domain_id", ctx.Param("domain_id"), &domainId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComboTreeGraphParams
	// ------------- Optional query parameter "node_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "node_id", ctx.QueryParams(), &params.NodeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter node_id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetComboTreeGraph(ctx, domainId, params)
	return err
}

// GetMetaEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetMetaEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMetaEntityParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMetaEntity(ctx, objectId, params)
	return err
}

// GetNtAuthStoreEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetNtAuthStoreEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNtAuthStoreEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNtAuthStoreEntity(ctx, objectId, params)
	return err
}

// GetNtAuthStoreEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetNtAuthStoreEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNtAuthStoreEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNtAuthStoreEntityControllers(ctx, objectId, params)
	return err
}

// GetOuEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetOuEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOuEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOuEntity(ctx, objectId, params)
	return err
}

// GetOuEntityComputers converts echo context to params.
func (w *ServerInterfaceWrapper) GetOuEntityComputers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOuEntityComputersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOuEntityComputers(ctx, objectId, params)
	return err
}

// GetOuEntityGpos converts echo context to params.
func (w *ServerInterfaceWrapper) GetOuEntityGpos(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOuEntityGposParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOuEntityGpos(ctx, objectId, params)
	return err
}

// GetOuEntityGroups converts echo context to params.
func (w *ServerInterfaceWrapper) GetOuEntityGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOuEntityGroupsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOuEntityGroups(ctx, objectId, params)
	return err
}

// GetOuEntityUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetOuEntityUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOuEntityUsersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOuEntityUsers(ctx, objectId, params)
	return err
}

// Pathfinding converts echo context to params.
func (w *ServerInterfaceWrapper) Pathfinding(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PathfindingParams
	// ------------- Required query parameter "start_node" -------------

	err = runtime.BindQueryParameter("form", true, true, "start_node", ctx.QueryParams(), &params.StartNode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_node: %s", err))
	}

	// ------------- Required query parameter "end_node" -------------

	err = runtime.BindQueryParameter("form", true, true, "end_node", ctx.QueryParams(), &params.EndNode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end_node: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Pathfinding(ctx, params)
	return err
}

// ListPermissions converts echo context to params.
func (w *ServerInterfaceWrapper) ListPermissions(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPermissionsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "authority" -------------

	err = runtime.BindQueryParameter("form", true, false, "authority", ctx.QueryParams(), &params.Authority)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authority: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPermissions(ctx, params)
	return err
}

// GetPermission converts echo context to params.
func (w *ServerInterfaceWrapper) GetPermission(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "permission_id" -------------
	var permissionId int32

	err = runtime.BindStyledParameterWithOptions("simple", "permission_id", ctx.Param("permission_id"), &permissionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter permission_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPermissionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPermission(ctx, permissionId, params)
	return err
}

// GetPlatformDataQualityAggregate converts echo context to params.
func (w *ServerInterfaceWrapper) GetPlatformDataQualityAggregate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform_id" -------------
	var platformId string

	err = runtime.BindStyledParameterWithOptions("simple", "platform_id", ctx.Param("platform_id"), &platformId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPlatformDataQualityAggregateParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPlatformDataQualityAggregate(ctx, platformId, params)
	return err
}

// GetPostureStats converts echo context to params.
func (w *ServerInterfaceWrapper) GetPostureStats(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPostureStatsParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", ctx.QueryParams(), &params.FromDeprecated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from: %s", err))
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", ctx.QueryParams(), &params.ToDeprecated)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to: %s", err))
	}

	// ------------- Optional query parameter "domain_sid" -------------

	err = runtime.BindQueryParameter("form", true, false, "domain_sid", ctx.QueryParams(), &params.DomainSid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter domain_sid: %s", err))
	}

	// ------------- Optional query parameter "exposure_index" -------------

	err = runtime.BindQueryParameter("form", true, false, "exposure_index", ctx.QueryParams(), &params.ExposureIndex)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exposure_index: %s", err))
	}

	// ------------- Optional query parameter "tier_zero_count" -------------

	err = runtime.BindQueryParameter("form", true, false, "tier_zero_count", ctx.QueryParams(), &params.TierZeroCount)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tier_zero_count: %s", err))
	}

	// ------------- Optional query parameter "critical_risk_count" -------------

	err = runtime.BindQueryParameter("form", true, false, "critical_risk_count", ctx.QueryParams(), &params.CriticalRiskCount)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter critical_risk_count: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPostureStats(ctx, params)
	return err
}

// ListRoles converts echo context to params.
func (w *ServerInterfaceWrapper) ListRoles(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRolesParams
	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRoles(ctx, params)
	return err
}

// GetRole converts echo context to params.
func (w *ServerInterfaceWrapper) GetRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "role_id" -------------
	var roleId int32

	err = runtime.BindStyledParameterWithOptions("simple", "role_id", ctx.Param("role_id"), &roleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRoleParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRole(ctx, roleId, params)
	return err
}

// GetRootCaEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetRootCaEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRootCaEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRootCaEntity(ctx, objectId, params)
	return err
}

// GetRootCaEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetRootCaEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRootCaEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRootCaEntityControllers(ctx, objectId, params)
	return err
}

// ListSamlProviders converts echo context to params.
func (w *ServerInterfaceWrapper) ListSamlProviders(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSamlProvidersParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListSamlProviders(ctx, params)
	return err
}

// CreateSamlProvider converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSamlProvider(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateSamlProvider(ctx)
	return err
}

// DeleteSamlProvider converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSamlProvider(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "saml_provider_id" -------------
	var samlProviderId int32

	err = runtime.BindStyledParameterWithOptions("simple", "saml_provider_id", ctx.Param("saml_provider_id"), &samlProviderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter saml_provider_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSamlProviderParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSamlProvider(ctx, samlProviderId, params)
	return err
}

// GetSamlProvider converts echo context to params.
func (w *ServerInterfaceWrapper) GetSamlProvider(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "saml_provider_id" -------------
	var samlProviderId int32

	err = runtime.BindStyledParameterWithOptions("simple", "saml_provider_id", ctx.Param("saml_provider_id"), &samlProviderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter saml_provider_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSamlProviderParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSamlProvider(ctx, samlProviderId, params)
	return err
}

// GetSamlSignSignOnEndpoints converts echo context to params.
func (w *ServerInterfaceWrapper) GetSamlSignSignOnEndpoints(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSamlSignSignOnEndpointsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSamlSignSignOnEndpoints(ctx, params)
	return err
}

// ListSavedQueries converts echo context to params.
func (w *ServerInterfaceWrapper) ListSavedQueries(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSavedQueriesParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "scope", ctx.QueryParams(), &params.Scope)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scope: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListSavedQueries(ctx, params)
	return err
}

// CreateSavedQuery converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSavedQuery(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateSavedQueryParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateSavedQuery(ctx, params)
	return err
}

// DeleteSavedQuery converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSavedQuery(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "saved_query_id" -------------
	var savedQueryId int32

	err = runtime.BindStyledParameterWithOptions("simple", "saved_query_id", ctx.Param("saved_query_id"), &savedQueryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter saved_query_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSavedQueryParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSavedQuery(ctx, savedQueryId, params)
	return err
}

// UpdateSavedQuery converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateSavedQuery(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "saved_query_id" -------------
	var savedQueryId int32

	err = runtime.BindStyledParameterWithOptions("simple", "saved_query_id", ctx.Param("saved_query_id"), &savedQueryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter saved_query_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateSavedQueryParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateSavedQuery(ctx, savedQueryId, params)
	return err
}

// DeleteSavedQueryPermissions converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSavedQueryPermissions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "saved_query_id" -------------
	var savedQueryId int32

	err = runtime.BindStyledParameterWithOptions("simple", "saved_query_id", ctx.Param("saved_query_id"), &savedQueryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter saved_query_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSavedQueryPermissionsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteSavedQueryPermissions(ctx, savedQueryId, params)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Required query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, true, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// GetSelf converts echo context to params.
func (w *ServerInterfaceWrapper) GetSelf(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSelfParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSelf(ctx, params)
	return err
}

// GetApiSpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiSpec(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiSpecParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiSpec(ctx, params)
	return err
}

// ListAuthTokens converts echo context to params.
func (w *ServerInterfaceWrapper) ListAuthTokens(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuthTokensParams
	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "key" -------------

	err = runtime.BindQueryParameter("form", true, false, "key", ctx.QueryParams(), &params.Key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	// ------------- Optional query parameter "hmac_method" -------------

	err = runtime.BindQueryParameter("form", true, false, "hmac_method", ctx.QueryParams(), &params.HmacMethod)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hmac_method: %s", err))
	}

	// ------------- Optional query parameter "last_access" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_access", ctx.QueryParams(), &params.LastAccess)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_access: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "created_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_at", ctx.QueryParams(), &params.CreatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_at: %s", err))
	}

	// ------------- Optional query parameter "updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated_at", ctx.QueryParams(), &params.UpdatedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated_at: %s", err))
	}

	// ------------- Optional query parameter "deleted_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "deleted_at", ctx.QueryParams(), &params.DeletedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter deleted_at: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAuthTokens(ctx, params)
	return err
}

// CreateAuthToken converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAuthToken(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateAuthTokenParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAuthToken(ctx, params)
	return err
}

// DeleteAuthToken converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAuthToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token_id" -------------
	var tokenId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "token_id", ctx.Param("token_id"), &tokenId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteAuthTokenParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAuthToken(ctx, tokenId, params)
	return err
}

// GetUserEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityParams
	// ------------- Optional query parameter "counts" -------------

	err = runtime.BindQueryParameter("form", true, false, "counts", ctx.QueryParams(), &params.Counts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter counts: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntity(ctx, objectId, params)
	return err
}

// GetUserEntityAdminRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntityAdminRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityAdminRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntityAdminRights(ctx, objectId, params)
	return err
}

// GetUserEntityConstrainedDelegationRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntityConstrainedDelegationRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityConstrainedDelegationRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntityConstrainedDelegationRights(ctx, objectId, params)
	return err
}

// GetUserEntityControllables converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntityControllables(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityControllablesParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntityControllables(ctx, objectId, params)
	return err
}

// GetUserEntityControllers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntityControllers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityControllersParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntityControllers(ctx, objectId, params)
	return err
}

// GetUserEntityDcomRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntityDcomRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityDcomRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntityDcomRights(ctx, objectId, params)
	return err
}

// GetUserEntityMembership converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntityMembership(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityMembershipParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntityMembership(ctx, objectId, params)
	return err
}

// GetUserEntityPsRemoteRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntityPsRemoteRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityPsRemoteRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntityPsRemoteRights(ctx, objectId, params)
	return err
}

// GetUserEntityRdpRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntityRdpRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntityRdpRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntityRdpRights(ctx, objectId, params)
	return err
}

// GetUserEntitySessions converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntitySessions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntitySessionsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntitySessions(ctx, objectId, params)
	return err
}

// GetUserEntitySqlAdminRights converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEntitySqlAdminRights(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "object_id" -------------
	var objectId PathObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "object_id", ctx.Param("object_id"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter object_id: %s", err))
	}

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEntitySqlAdminRightsParams
	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skip: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserEntitySqlAdminRights(ctx, objectId, params)
	return err
}

// GetApiVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiVersion(ctx echo.Context) error {
	var err error

	ctx.Set(JWTBearerTokenScopes, []string{})

	ctx.Set(HMACSignatureScopes, []string{})

	ctx.Set(RequestDateScopes, []string{})

	ctx.Set(SignedRequestScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiVersionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Prefer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Prefer")]; found {
		var Prefer HeaderPrefer
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Prefer, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Prefer", valueList[0], &Prefer, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Prefer: %s", err))
		}

		params.Prefer = &Prefer
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiVersion(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v2/accept-eula", wrapper.AcceptEula)
	router.GET(baseURL+"/api/v2/ad-domains/:domain_id/data-quality-stats", wrapper.GetAdDomainDataQualityStats)
	router.GET(baseURL+"/api/v2/aiacas/:object_id", wrapper.GetAiaCaEntity)
	router.GET(baseURL+"/api/v2/aiacas/:object_id/controllers", wrapper.GetAiaCaEntityControllers)
	router.PUT(baseURL+"/api/v2/analysis", wrapper.StartAnalysis)
	router.GET(baseURL+"/api/v2/asset-groups", wrapper.ListAssetGroups)
	router.POST(baseURL+"/api/v2/asset-groups", wrapper.CreateAssetGroup)
	router.DELETE(baseURL+"/api/v2/asset-groups/:asset_group_id", wrapper.DeleteAssetGroup)
	router.GET(baseURL+"/api/v2/asset-groups/:asset_group_id", wrapper.GetAssetGroup)
	router.PUT(baseURL+"/api/v2/asset-groups/:asset_group_id", wrapper.UpdateAssetGroup)
	router.GET(baseURL+"/api/v2/asset-groups/:asset_group_id/collections", wrapper.ListAssetGroupCollections)
	router.GET(baseURL+"/api/v2/asset-groups/:asset_group_id/combo-node", wrapper.GetAssetGroupComboNode)
	router.GET(baseURL+"/api/v2/asset-groups/:asset_group_id/custom-selectors", wrapper.GetAssetGroupCustomMemberCount)
	router.GET(baseURL+"/api/v2/asset-groups/:asset_group_id/members", wrapper.ListAssetGroupMembers)
	router.GET(baseURL+"/api/v2/asset-groups/:asset_group_id/members/counts", wrapper.ListAssetGroupMemberCountByKind)
	router.POST(baseURL+"/api/v2/asset-groups/:asset_group_id/selectors", wrapper.UpdateAssetGroupSelectorsDeprecated)
	router.PUT(baseURL+"/api/v2/asset-groups/:asset_group_id/selectors", wrapper.UpdateAssetGroupSelectors)
	router.DELETE(baseURL+"/api/v2/asset-groups/:asset_group_id/selectors/:asset_group_selector_id", wrapper.DeleteAssetGroupSelector)
	router.GET(baseURL+"/api/v2/attack-path-types", wrapper.ListAttackPathTypes)
	router.PUT(baseURL+"/api/v2/attack-paths", wrapper.StartAnalysisBhe)
	router.PUT(baseURL+"/api/v2/attack-paths/:attack_path_id/acceptance", wrapper.UpdateAttackPathRisk)
	router.GET(baseURL+"/api/v2/audit", wrapper.ListAuditLogs)
	router.GET(baseURL+"/api/v2/available-domains", wrapper.GetAvailableDomains)
	router.GET(baseURL+"/api/v2/azure-tenants/:tenant_id/data-quality-stats", wrapper.GetAzureTenantDataQualityStats)
	router.GET(baseURL+"/api/v2/azure/:entity_type", wrapper.GetAzureEntity)
	router.GET(baseURL+"/api/v2/base/:object_id", wrapper.GetEntity)
	router.GET(baseURL+"/api/v2/base/:object_id/controllables", wrapper.GetEntityControllables)
	router.GET(baseURL+"/api/v2/base/:object_id/controllers", wrapper.GetEntityControllers)
	router.GET(baseURL+"/api/v2/bloodhound-users", wrapper.ListUsers)
	router.POST(baseURL+"/api/v2/bloodhound-users", wrapper.CreateUser)
	router.DELETE(baseURL+"/api/v2/bloodhound-users/:user_id", wrapper.DeleteUser)
	router.GET(baseURL+"/api/v2/bloodhound-users/:user_id", wrapper.GetUser)
	router.PATCH(baseURL+"/api/v2/bloodhound-users/:user_id", wrapper.UpdateUser)
	router.DELETE(baseURL+"/api/v2/bloodhound-users/:user_id/mfa", wrapper.RemoveUserMfa)
	router.POST(baseURL+"/api/v2/bloodhound-users/:user_id/mfa", wrapper.AddUserMfa)
	router.GET(baseURL+"/api/v2/bloodhound-users/:user_id/mfa-activation", wrapper.GetMfaActivationStatus)
	router.POST(baseURL+"/api/v2/bloodhound-users/:user_id/mfa-activation", wrapper.ActivateUserMfa)
	router.DELETE(baseURL+"/api/v2/bloodhound-users/:user_id/secret", wrapper.DeleteUserSecret)
	router.PUT(baseURL+"/api/v2/bloodhound-users/:user_id/secret", wrapper.CreateOrSetUserSecret)
	router.GET(baseURL+"/api/v2/certtemplates/:object_id", wrapper.GetCertTemplateEntity)
	router.GET(baseURL+"/api/v2/certtemplates/:object_id/controllers", wrapper.GetCertTemplateEntityControllers)
	router.POST(baseURL+"/api/v2/clear-database", wrapper.DeleteBloodHoundDatabase)
	router.GET(baseURL+"/api/v2/clients", wrapper.ListClients)
	router.POST(baseURL+"/api/v2/clients", wrapper.CreateClient)
	router.POST(baseURL+"/api/v2/clients/error", wrapper.LogClientError)
	router.PUT(baseURL+"/api/v2/clients/update", wrapper.UpdateClientInfo)
	router.DELETE(baseURL+"/api/v2/clients/:client_id", wrapper.DeleteClient)
	router.GET(baseURL+"/api/v2/clients/:client_id", wrapper.GetClient)
	router.PUT(baseURL+"/api/v2/clients/:client_id", wrapper.UpdateClient)
	router.GET(baseURL+"/api/v2/clients/:client_id/completed-jobs", wrapper.ListClientCompletedJobs)
	router.GET(baseURL+"/api/v2/clients/:client_id/completed-tasks", wrapper.ListClientCompletedTasks)
	router.POST(baseURL+"/api/v2/clients/:client_id/jobs", wrapper.CreateClientScheduledJob)
	router.POST(baseURL+"/api/v2/clients/:client_id/tasks", wrapper.CreateClientScheduledTask)
	router.PUT(baseURL+"/api/v2/clients/:client_id/token", wrapper.ReplaceClientToken)
	router.GET(baseURL+"/api/v2/collectors/:collector_type", wrapper.GetCollectorManifest)
	router.GET(baseURL+"/api/v2/collectors/:collector_type/:release_tag", wrapper.DownloadCollector)
	router.GET(baseURL+"/api/v2/collectors/:collector_type/:release_tag/checksum", wrapper.GetCollectorChecksum)
	router.GET(baseURL+"/api/v2/completeness", wrapper.GetCompletenessStats)
	router.GET(baseURL+"/api/v2/computers/:object_id", wrapper.GetComputerEntity)
	router.GET(baseURL+"/api/v2/computers/:object_id/admin-rights", wrapper.GetComputerEntityAdminRights)
	router.GET(baseURL+"/api/v2/computers/:object_id/admin-users", wrapper.GetComputerEntityAdmins)
	router.GET(baseURL+"/api/v2/computers/:object_id/constrained-delegation-rights", wrapper.GetComputerEntityConstrainedDelegationRights)
	router.GET(baseURL+"/api/v2/computers/:object_id/constrained-users", wrapper.GetComputerEntityConstrainedUsers)
	router.GET(baseURL+"/api/v2/computers/:object_id/controllables", wrapper.GetComputerEntityControllables)
	router.GET(baseURL+"/api/v2/computers/:object_id/controllers", wrapper.GetComputerEntityControllers)
	router.GET(baseURL+"/api/v2/computers/:object_id/dcom-rights", wrapper.GetComputerEntityDcomRights)
	router.GET(baseURL+"/api/v2/computers/:object_id/dcom-users", wrapper.GetComputerEntityDcomUsers)
	router.GET(baseURL+"/api/v2/computers/:object_id/group-membership", wrapper.GetComputerEntityGroupMembership)
	router.GET(baseURL+"/api/v2/computers/:object_id/ps-remote-rights", wrapper.GetComputerEntityPsRemoteRights)
	router.GET(baseURL+"/api/v2/computers/:object_id/ps-remote-users", wrapper.GetComputerEntityPsRemoteUsers)
	router.GET(baseURL+"/api/v2/computers/:object_id/rdp-rights", wrapper.GetComputerEntityRdpRights)
	router.GET(baseURL+"/api/v2/computers/:object_id/rdp-users", wrapper.GetComputerEntityRdpUsers)
	router.GET(baseURL+"/api/v2/computers/:object_id/sessions", wrapper.GetComputerEntitySessions)
	router.GET(baseURL+"/api/v2/computers/:object_id/sql-admins", wrapper.GetComputerEntitySqlAdmins)
	router.GET(baseURL+"/api/v2/config", wrapper.ListAppConfigParams)
	router.PUT(baseURL+"/api/v2/config", wrapper.SetAppConfigParam)
	router.GET(baseURL+"/api/v2/containers/:object_id", wrapper.GetContainerEntity)
	router.GET(baseURL+"/api/v2/containers/:object_id/controllers", wrapper.GetContainerEntityControllers)
	router.GET(baseURL+"/api/v2/datapipe/status", wrapper.GetDatapipeStatus)
	router.GET(baseURL+"/api/v2/domains/:domain_id/attack-path-findings", wrapper.ExportAttackPathFindings)
	router.GET(baseURL+"/api/v2/domains/:domain_id/available-types", wrapper.ListAvailableAttackPathTypesForDomain)
	router.GET(baseURL+"/api/v2/domains/:domain_id/details", wrapper.ListDomainAttackPathsDetails)
	router.GET(baseURL+"/api/v2/domains/:domain_id/sparkline", wrapper.ListAttackPathSparklineValues)
	router.GET(baseURL+"/api/v2/domains/:object_id", wrapper.GetDomainEntity)
	router.PATCH(baseURL+"/api/v2/domains/:object_id", wrapper.UpdateDomainEntity)
	router.GET(baseURL+"/api/v2/domains/:object_id/computers", wrapper.GetDomainEntityComputers)
	router.GET(baseURL+"/api/v2/domains/:object_id/controllers", wrapper.GetDomainEntityControllers)
	router.GET(baseURL+"/api/v2/domains/:object_id/dc-syncers", wrapper.GetDomainEntityDcSyncers)
	router.GET(baseURL+"/api/v2/domains/:object_id/foreign-admins", wrapper.GetDomainEntityForeignAdmins)
	router.GET(baseURL+"/api/v2/domains/:object_id/foreign-gpo-controllers", wrapper.GetDomainEntityForeignGpoControllers)
	router.GET(baseURL+"/api/v2/domains/:object_id/foreign-groups", wrapper.GetDomainEntityForeignGroups)
	router.GET(baseURL+"/api/v2/domains/:object_id/foreign-users", wrapper.GetDomainEntityForeignUsers)
	router.GET(baseURL+"/api/v2/domains/:object_id/gpos", wrapper.GetDomainEntityGpos)
	router.GET(baseURL+"/api/v2/domains/:object_id/groups", wrapper.GetDomainEntityGroups)
	router.GET(baseURL+"/api/v2/domains/:object_id/inbound-trusts", wrapper.GetDomainEntityInboundTrusts)
	router.GET(baseURL+"/api/v2/domains/:object_id/linked-gpos", wrapper.GetDomainEntityLinkedGpos)
	router.GET(baseURL+"/api/v2/domains/:object_id/ous", wrapper.GetDomainEntityOus)
	router.GET(baseURL+"/api/v2/domains/:object_id/outbound-trusts", wrapper.GetDomainEntityOutboundTrusts)
	router.GET(baseURL+"/api/v2/domains/:object_id/users", wrapper.GetDomainEntityUsers)
	router.GET(baseURL+"/api/v2/enterprisecas/:object_id", wrapper.GetEnterpriseCaEntity)
	router.GET(baseURL+"/api/v2/enterprisecas/:object_id/controllers", wrapper.GetEnterpriseCaEntityControllers)
	router.GET(baseURL+"/api/v2/events", wrapper.ListClientSchedules)
	router.POST(baseURL+"/api/v2/events", wrapper.CreateClientSchedule)
	router.DELETE(baseURL+"/api/v2/events/:event_id", wrapper.DeleteClientEvent)
	router.GET(baseURL+"/api/v2/events/:event_id", wrapper.GetClientSchedule)
	router.PUT(baseURL+"/api/v2/events/:event_id", wrapper.UpdateClientEvent)
	router.GET(baseURL+"/api/v2/features", wrapper.ListFeatureFlags)
	router.PUT(baseURL+"/api/v2/features/:feature_id/toggle", wrapper.ToggleFeatureFlag)
	router.GET(baseURL+"/api/v2/file-upload", wrapper.ListFileUploadJobs)
	router.GET(baseURL+"/api/v2/file-upload/accepted-types", wrapper.ListAcceptedFileUploadTypes)
	router.POST(baseURL+"/api/v2/file-upload/start", wrapper.CreateFileUploadJob)
	router.POST(baseURL+"/api/v2/file-upload/:file_upload_job_id", wrapper.UploadFileToJob)
	router.POST(baseURL+"/api/v2/file-upload/:file_upload_job_id/end", wrapper.EndFileUploadJob)
	router.GET(baseURL+"/api/v2/gpos/:object_id", wrapper.GetGpoEntity)
	router.GET(baseURL+"/api/v2/gpos/:object_id/computers", wrapper.GetGpoEntityComputers)
	router.GET(baseURL+"/api/v2/gpos/:object_id/controllers", wrapper.GetGpoEntityControllers)
	router.GET(baseURL+"/api/v2/gpos/:object_id/ous", wrapper.GetGpoEntityOus)
	router.GET(baseURL+"/api/v2/gpos/:object_id/tier-zero", wrapper.GetGpoEntityTierZero)
	router.GET(baseURL+"/api/v2/gpos/:object_id/users", wrapper.GetGpoEntityUsers)
	router.GET(baseURL+"/api/v2/graph-search", wrapper.GetSearchResult)
	router.POST(baseURL+"/api/v2/graphs/cypher", wrapper.RunCypherQuery)
	router.GET(baseURL+"/api/v2/graphs/edge-composition", wrapper.GetPathComposition)
	router.GET(baseURL+"/api/v2/graphs/shortest-path", wrapper.GetShortestPath)
	router.GET(baseURL+"/api/v2/groups/:object_id", wrapper.GetGroupEntity)
	router.GET(baseURL+"/api/v2/groups/:object_id/admin-rights", wrapper.GetGroupEntityAdminRights)
	router.GET(baseURL+"/api/v2/groups/:object_id/controllables", wrapper.GetGroupEntityControllables)
	router.GET(baseURL+"/api/v2/groups/:object_id/controllers", wrapper.GetGroupEntityControllers)
	router.GET(baseURL+"/api/v2/groups/:object_id/dcom-rights", wrapper.GetGroupEntityDcomRights)
	router.GET(baseURL+"/api/v2/groups/:object_id/members", wrapper.GetGroupEntityMembers)
	router.GET(baseURL+"/api/v2/groups/:object_id/memberships", wrapper.GetGroupEntityMemberships)
	router.GET(baseURL+"/api/v2/groups/:object_id/ps-remote-rights", wrapper.GetGroupEntityPsRemoteRights)
	router.GET(baseURL+"/api/v2/groups/:object_id/rdp-rights", wrapper.GetGroupEntityRdpRights)
	router.GET(baseURL+"/api/v2/groups/:object_id/sessions", wrapper.GetGroupEntitySessions)
	router.POST(baseURL+"/api/v2/ingest", wrapper.IngestData)
	router.GET(baseURL+"/api/v2/jobs", wrapper.GetClientJobs)
	router.GET(baseURL+"/api/v2/jobs/available", wrapper.ListAvailableClientJobs)
	router.GET(baseURL+"/api/v2/jobs/current", wrapper.GetClientCurrentJob)
	router.POST(baseURL+"/api/v2/jobs/end", wrapper.EndClientJob)
	router.GET(baseURL+"/api/v2/jobs/finished", wrapper.ListClientFinishedJobs)
	router.POST(baseURL+"/api/v2/jobs/start", wrapper.StartClientJob)
	router.GET(baseURL+"/api/v2/jobs/:job_id", wrapper.GetClientJob)
	router.PUT(baseURL+"/api/v2/jobs/:job_id/cancel", wrapper.CancelClientJob)
	router.GET(baseURL+"/api/v2/jobs/:job_id/log", wrapper.GetClientJobLog)
	router.POST(baseURL+"/api/v2/login", wrapper.Login)
	router.POST(baseURL+"/api/v2/logout", wrapper.Logout)
	router.GET(baseURL+"/api/v2/meta-nodes/:domain_id", wrapper.GetLatestTierZeroComboNode)
	router.GET(baseURL+"/api/v2/meta-trees/:domain_id", wrapper.GetComboTreeGraph)
	router.GET(baseURL+"/api/v2/meta/:object_id", wrapper.GetMetaEntity)
	router.GET(baseURL+"/api/v2/ntauthstores/:object_id", wrapper.GetNtAuthStoreEntity)
	router.GET(baseURL+"/api/v2/ntauthstores/:object_id/controllers", wrapper.GetNtAuthStoreEntityControllers)
	router.GET(baseURL+"/api/v2/ous/:object_id", wrapper.GetOuEntity)
	router.GET(baseURL+"/api/v2/ous/:object_id/computers", wrapper.GetOuEntityComputers)
	router.GET(baseURL+"/api/v2/ous/:object_id/gpos", wrapper.GetOuEntityGpos)
	router.GET(baseURL+"/api/v2/ous/:object_id/groups", wrapper.GetOuEntityGroups)
	router.GET(baseURL+"/api/v2/ous/:object_id/users", wrapper.GetOuEntityUsers)
	router.GET(baseURL+"/api/v2/pathfinding", wrapper.Pathfinding)
	router.GET(baseURL+"/api/v2/permissions", wrapper.ListPermissions)
	router.GET(baseURL+"/api/v2/permissions/:permission_id", wrapper.GetPermission)
	router.GET(baseURL+"/api/v2/platform/:platform_id/data-quality-stats", wrapper.GetPlatformDataQualityAggregate)
	router.GET(baseURL+"/api/v2/posture-stats", wrapper.GetPostureStats)
	router.GET(baseURL+"/api/v2/roles", wrapper.ListRoles)
	router.GET(baseURL+"/api/v2/roles/:role_id", wrapper.GetRole)
	router.GET(baseURL+"/api/v2/rootcas/:object_id", wrapper.GetRootCaEntity)
	router.GET(baseURL+"/api/v2/rootcas/:object_id/controllers", wrapper.GetRootCaEntityControllers)
	router.GET(baseURL+"/api/v2/saml", wrapper.ListSamlProviders)
	router.POST(baseURL+"/api/v2/saml/providers", wrapper.CreateSamlProvider)
	router.DELETE(baseURL+"/api/v2/saml/providers/:saml_provider_id", wrapper.DeleteSamlProvider)
	router.GET(baseURL+"/api/v2/saml/providers/:saml_provider_id", wrapper.GetSamlProvider)
	router.GET(baseURL+"/api/v2/saml/sso", wrapper.GetSamlSignSignOnEndpoints)
	router.GET(baseURL+"/api/v2/saved-queries", wrapper.ListSavedQueries)
	router.POST(baseURL+"/api/v2/saved-queries", wrapper.CreateSavedQuery)
	router.DELETE(baseURL+"/api/v2/saved-queries/:saved_query_id", wrapper.DeleteSavedQuery)
	router.PUT(baseURL+"/api/v2/saved-queries/:saved_query_id", wrapper.UpdateSavedQuery)
	router.DELETE(baseURL+"/api/v2/saved-queries/:saved_query_id/permissions", wrapper.DeleteSavedQueryPermissions)
	router.GET(baseURL+"/api/v2/search", wrapper.Search)
	router.GET(baseURL+"/api/v2/self", wrapper.GetSelf)
	router.GET(baseURL+"/api/v2/spec/openapi.yaml", wrapper.GetApiSpec)
	router.GET(baseURL+"/api/v2/tokens", wrapper.ListAuthTokens)
	router.POST(baseURL+"/api/v2/tokens", wrapper.CreateAuthToken)
	router.DELETE(baseURL+"/api/v2/tokens/:token_id", wrapper.DeleteAuthToken)
	router.GET(baseURL+"/api/v2/users/:object_id", wrapper.GetUserEntity)
	router.GET(baseURL+"/api/v2/users/:object_id/admin-rights", wrapper.GetUserEntityAdminRights)
	router.GET(baseURL+"/api/v2/users/:object_id/constrained-delegation-rights", wrapper.GetUserEntityConstrainedDelegationRights)
	router.GET(baseURL+"/api/v2/users/:object_id/controllables", wrapper.GetUserEntityControllables)
	router.GET(baseURL+"/api/v2/users/:object_id/controllers", wrapper.GetUserEntityControllers)
	router.GET(baseURL+"/api/v2/users/:object_id/dcom-rights", wrapper.GetUserEntityDcomRights)
	router.GET(baseURL+"/api/v2/users/:object_id/memberships", wrapper.GetUserEntityMembership)
	router.GET(baseURL+"/api/v2/users/:object_id/ps-remote-rights", wrapper.GetUserEntityPsRemoteRights)
	router.GET(baseURL+"/api/v2/users/:object_id/rdp-rights", wrapper.GetUserEntityRdpRights)
	router.GET(baseURL+"/api/v2/users/:object_id/sessions", wrapper.GetUserEntitySessions)
	router.GET(baseURL+"/api/v2/users/:object_id/sql-admin-rights", wrapper.GetUserEntitySqlAdminRights)
	router.GET(baseURL+"/api/version", wrapper.GetApiVersion)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+z9e3MbN7I/Dr8VHJ6tyuVwKNlyvGud2qqvItmOsrGtleTNno38kOAMSMIaAhMAI4nx",
	"k/f+KzSAuXBmyBnedPH8kVgkcUd/uhuNRveXjs+nEWeEKdk5/NKJsMBTooiATxOCAyJ6kSAjIvQXAZG+",
	"oJGinHUOO2fwPTKluiiWJECKIxkRn45mCCM/lopPkaJTwmOFKEOS+JwFEsWSsjFSE4JuMVUo6RZhiSIi",
	"0Pmb478+f7Hf63Q7VHdl+uh0OwxPSdJ1p9uR/oRMsRnbCMeh6hzudztTyug0nsLfahbpGpQpMiai8+ef",
	"3U6E1aTHh5+JrzwaFCd2OSHI/IxogPgIBkqYomqGhkSPnEdEYEUCxFkyRt1qOkJTv0+DTrcjyO8xFSTo",
	"HCoRk/yg5/uNGf09znSvux1RmKudiVSCsjFM5PeYiFnPD6nev95kFuhBeQGfYspksf1fJ4QhjG5wqHsY",
	"oYEezgBRiSIsJQm6CLMZOjHVEZaS+xRmeUvVBOlRB3FIAoRZgEaUUTkhAfrMhxKNuEAE+xNkxoJuaRii",
	"Cb4hiNxFmAUkQJHQi6YokYgyP4wDvY4DvVoDaHCgpzfoocIgRziU+VGqCZEESTwlyWChQ87CGRJExYJp",
	"QsIopFJBG2Y5aTCQyXbB2qX7ZRev7xavlLTM9tl9GHIeEswWbASPV96EDx8fyQbogW5s8fWCrbPwn/mw",
	"hwNPKhH7KhbE83kY6r71yn8p7RoH/aR4P1M8O4y/CDLqHHb+ey9llnvmV7mHI9oD9iU1nwyojxXpjWio",
	"iOgtHqiPPUHGVCoxqzFOH/dd6R0PkwjlSSJuqE9knYESofqu/I6HCn9bll46NihgmPL6g4ljGlSMJPCb",
	"7G3g39PeGmbn+ZwpofsVlSOEgv1MwU0MrlKS6bERFnhac6gaEmFBH37fxEigoYpx3CymKfh9UySV1VKq",
	"hqKoCsni0Zgi29+iO+LHmlQXb5QrtZPtCrFUHmVjIlXVgHSRvi2y7dFwH4feWPA4qsEHoHQfSu+WD4R8",
	"7IH6Wjmwcd+qt1smKUmk1AS1fLFsyd0ulFRYqIXUDiV2QulSYWUUzIpxqDltanMbJojWSj2siurtG6iD",
	"BJFxqCQaztDAFu9jNTBaZQ9dEIJM68iMAAVEYRoaRfYGh1Trq3YclWpj2vA21jogIWkwS1t887NMG97G",
	"LM2xthfSKVXlJ1IWT4dEaE2eMCX08UFxBOX1iV4fjQWREWeS9NAHfQjAN5iGeBgSmCYcK/6uDwODqhma",
	"zksV/2fLT/O5echrGjWYhi4Oo4zwmDKsi686Ceh5RYNEfgpcKG84K87iggulSc3nYTxlPXSMGRoSY3eZ",
	"xqGiUUjA2CL/V5NVRFiAMJrMIn2g07PQzREG5z4uAiJ66Biakulsr5guqIegS2FBUAAN6TMlZ1lDiLVQ",
	"XFMW9K5Y1aJwofrD2SqEa9bELUZhlcwqlm20/kVvsz2LBlhhJMjvMZGKBD10OkKMm0L6RCv4DQ30mRZa",
	"N0dZu3OaQAaw590rNgQDlsGsrmxPvYYDaCBgNPB5zNTAtNRDF3yaLJZpnLAg4pQpiQKOGFdXTMZRpHdV",
	"r+tgLHA0GUDr1SsK8y4ls44eaqfbIUwT2m/uI7Ta6XZgcJ1P1WYkZ7WAgiWGi1MwGhBkfjcrHIJ1AiZJ",
	"ieyhE7tyxnhApbVuVDJw09UqR/5KhkWlXe3UqEilAQmQNlGGtBmKo4gIy8n4yBK0tHRDAr2pli2QIOFx",
	"sj4Ta0Topno6vypGtmR6gf5GcxtrXk25npue43rp7GjGiLmMqTUDr66dTimOgiZqgy2+eYGaNrxJgfpn",
	"t5PQiG5uiAPPsh39UR+dCYM/cRSFugXK2d5naTRccoenkTnWESG4kJ3D32ylO5VYLjRUpkRKPCaW2f18",
	"8eE9ivAs5DjQyAwDzVhALLApFnKCw5AEvc6fn7qdiVJR32mNL/b3jWGaSDi9HnYORvhvP4xevvB++Ouz",
	"v3ovfnj53BsejHzvuf/q5cHo5Us8wi873Q4IGIWnUeew83z/+Qtv/7n37NXls1eHz/96+OKg97eXL//T",
	"+bPJwsKEvVuBNR7NSuaJ4/vvf8QBOjeD/f77KwYwMLMdEhTERFM1Z8TZ6kc8DPmtxoAgWHImD6+Yl18r",
	"KtGUSmlkIZricMTFlAS63BlWE/3lHM4kiMNMJSsO9nKV9aaAyJFaZFIJ22Eo81ty5+mvQQBjNDAceADC",
	"g6GBVQgGaERJGHx3xfQqDinDYuY5ylpASdxXRHlSCYKnOYrq/Kb0ctm9RhMwzpp2E672KYcEPRsNUtt7",
	"ydVDyRZ9+EeyM65VIyL1eDFlrks7fCPhzL0O4OXYfO+dUBlxSd3RLx1VYQx/dju+vKlaGw2cPV/e5NfC",
	"dPisa/59bv89uGI+CcNnXf3/5/B/+9UL+PAD/P/lFev1zLgXjGqFlfHlDdLDza7Nn1qQa93Bo2zEPaBF",
	"z7LHGvwkHWBq9geui1XJt/oT/IGDAFYeh2e5AnaWRobosc19UeubyqWZXxytl/FwNuUimlAfLieMFiqd",
	"Dqoyel7uYk6vE7U3JLcToiZEXDHQrqxyBnDWPWj9QqOYcdVDR2GIGA9IXrUzdxloAMtjcWmuYnSLoFhB",
	"rSuWLicomKazv5ubnewJybSMQ8ntHQxB6ZKbDqTpwXIDq205igBOWYMZFMlgbSasGZtUmAVYBAhKZ2Zl",
	"qvX0GEdcDGkQELYlqfd/PLbqs7nfirS+A6YgLQSw7xMpkeV4ksfCJ2XC7+ARCb83bkUTNqKFF5eaX0yn",
	"cO/mY9AAhzMtSXCsJhoUPiiu9kJQiRnohPyK2TXCyQIhNcEKUYUCTmTpyo64sCSo6VIwHMKVEBEejH+L",
	"Co4TWzndZoJZEJLASX6tyzNyFxFfT1izuCGWxBBpierzw6NSfU7tgqMLWHD0WlfJUkIsYxyGM8dn9PFL",
	"c0WqeV/V0nCBMptkV0o3SRy9TPFM0wya8oCOZlbjEcSpLyrdmi7SZ2OwDABXoBKF9JqEM9gtd0ZUHIqY",
	"1q9YwHUrkk+Jmui/bgVnY0tijHsZYpoX6VGIKVum4DCeMic96U9NZfZ7jqxCskR2Z3sa8mCWzEF5Ix6z",
	"YPvQSDGewwj0Xqr4v3hE1P+eK/RGzyTZBkNkahZRH8je51Mi0UjwqfXKoZxJLfsFMV4MNECnJ+gWO/cF",
	"R4p2Da6Y4ijk/BrFkYaLUyccTZuPJUtrNtrSt2eVtdX1tIDqmU/1gdww1CmOIk2f0EjMVEbuVy9pYopd",
	"NK7eXHvWSLTBDuba+7PrFM7Z+4wZ689uhzPyYQT0voxYVux4Uw3PLdmfn5brs87cZzVJLXGzam3KoBIL",
	"axxxhm4n1J847dPZKROsX7GhYfXGXSc9nlp6VJx7U8xmzvYgN8CApjQIQnKLBcnzIM6R7soNTvbQWUi0",
	"eNGCA481e9QrWiaDXzx/9Yi4kJ7pOz1Ta4OQhhslwlKLHDjvq/klAWUerMM+ESAw9ATQLWUBv71i+pii",
	"BI0izZY0T8KKGIukForputvNjZnW7bigf5BNCJaQjynLbenHbAclouPZI9q07FxS6eEwOcLUeNJl1WWt",
	"C1lnzak+h6PXRotKNRe9W0aEGC36imEUCa6MfpW0rnedx8oeSnMKeReUL9OtEU+mXzsgMBJZy9IV8wUB",
	"D1AcSl2N3EVUQPfXhH0HRJGsmjm/J0tjDKPFo36y+2VXJ/ZHRB0XSrU6pSVkFGKfFM1BGQqab/UITeIp",
	"Zp4gOIDbtMzPiWctHCHKLiYKZofi1hcm6Ci9bH7w27fyO3Pg4b4fC72coDxEgusNnVNuO90OVWQq69Ok",
	"Xfh09FgIPNOfc1gqG95Pl5dnyBRAPg+A2+I7c3H4cj97jfhsv+QiMY/NBc7FqVex2wKnO8O6GErsdFM7",
	"IHi6lWx7Btdl3Z2/OfYODg5eoaRcGWWlerXlotmeA6yIZ70patLHMs+OGncP5oYV2Rru9uFfoEva+4f0",
	"mgHMwgPy+6CLBoz8PjAWwvmLq8Vjs6cJWQ1L8HJO6iF/Qvxr0CisXmXkrTRKKwxYmlvJMb0hDCwFGEmi",
	"B6A5VUil6l0xDw0oG7jWqCGGpMkpVv5ET5AhEgJHdDf+CxtFCJo9PLbD7r4l6niC2ZjIozDsviPTIREf",
	"RgPoni3oPzFHwEBWGgaj7PAX7uPwkh/zaRQrIpIBwPdvBY+jAWxZhJU+ancOO/+/byn7/zPKvjv89urq",
	"9n+++7Z7dSW/hz+//0sZEOr49NWnO2f7a0Z3XTQYK/N/ov8Jlfk/yVNkhl3UcPqpP2hTYR2s1FtO53xV",
	"c1gp6zF30oazaDLBQNgJjzK9967Yhpa7DgtbPFPguk03wEsnqOuvtB9L+X7F7XUp80ru192IU7OFPckY",
	"zarXWewmU9JrHWcfkN7ZS29ccqm/St+789K5YheEZO77syqUvfOHO3A81CqnEa++c+wRBLx5tO61AGzJ",
	"CS6WGvtEeZL4gqiiesUICWQ/wlLechH0BZGmVFHepS3UFNz5QZhb+hL9bopp2MdBIIiUudtK+KVshiMq",
	"pOqb2/8vxZ+p7AdU6hUKymcCDsOV1SNBmU8jHJb+Knhoxp2okcl4KVMHz0sZ87zmKPE07FtXJWG1u9qL",
	"akk8dwhx1oEyBdpdEdYzzUx5QELYsaXGFlPUoB0MKMuGrEfi/R7jkKqZF4VY6aXz8HgsyLiUNtzQcRg2",
	"tSqlvjDNjEYayZ45zkPF8gElm99kUXHg5VbATbzOGG0Lf8SCLGjkU4HWintSY59GFNjVZkhJa2+ea7He",
	"NMFwRzmTExqlVWsMPLPpJQflmFWINMUVDjMyxtkIl0qRREyu4hrW7Th5t5oT1uKlWGj8HGJJctfOUYl3",
	"QBlLSl++/mZ+/bTWOObt4CshvcFMi4BOqKLEi9c+zLFlikBaa+rzFvpdTH058oYTDwZmhldjjll2WRTt",
	"LKhtSFDc6kFDYu9p4KU2NvZVoU+btZVweLOxcs9DMqYMHC5X678MmoTF0x6OA6q8kI+91GjknHupMfx2",
	"OzIGO6TuC9MwFqTExde2Z59HVnlOg3U0niaTk0Y5N89ruEgMoLMI9GU3EjnBIprAVWe3AwLHfKgchhYK",
	"EY1I2awCeLZm3mbpOt0OZjic/aH/rmzwMx961Wa1imnFQujZWGsb7NzPfAgHpdici8BncOA9G6BTZ471",
	"0GB/gM4JDmbw4dkAncew9/Dx+QAd82kUEkXg88FAa/8+CY1r4ODFAF3SKQnQh1jBFz8M0BswtsGnl7on",
	"O3P44q8DdOSmD1/8bYDOsFAULj7TrtLd8J5197vPus+7B90X3R+6L7t/7f7tU5kkgoWbjrCHfUVvQAR6",
	"i0yTabHMksFxxhthII85MzrXJ60fQ86DnzQ5INDpM2RjGwQ7Y0CynyJz+Kneb0HltYd9n0RKr26WgMy3",
	"0EzMMh9wqA8GpU0u17Vq81qr4CY/9EDD79Ggrmqc1kzYjSwRQtgPZZkM6nYwxT6u+M0nQiky1Xo0qSpi",
	"TWSVP4NBr/L3TOCJMopTRESCSlI5wnHEq34RPI4qfsu/mjSYYPNnw1HIcUYmG90NHDWUJlypuKhaFBvF",
	"oczanqqdVUU4V5XTFTGzZ7mlBpf0sWPT+dmaFUPQqJRV6sz8OaAKK5ohtCBpBpK+LD3F3zdMAh4PQ/KE",
	"cVI9wW0AJYo8n7MRHXtwJHt4IMkJ+i8dQXDwgYWzuddX6fpek1kp1Trj2NIGwBxd4lG+cBmlJMo8on94",
	"KziFy6R+ci6sWIEMKVUaEiUxmnbeXFjDypOuj+faMLgrHUpqVZxJRab9ZGErymcMoQqPa5keS/du7k3/",
	"6tv48sXmt9G+CV5j5dPZ6eO1mC3fgebrZlt+cKsHoy0Erphn2tB50d7d7dwKqki6TuA+G5B+iIckrMVV",
	"0mBrdUrnx15RvCFj8gwfKNo0skuTE/lZlQHi5PXTJorII+yGCs6mNtZMueaQFrmmrLyQ/iFP5UWnjjk2",
	"Ucmvcqtedi0yxWJWNZQyq8cCdvbw1MvCvta411nK+st/NHy6pEz2WXQtKnVteDIifgmxJtw5OVAHJoDh",
	"lN+UW5Zci9X3Y5I23H9n9toUn6ua41JGAYaNvrlWLLtorNlAue5as3Jtzcrn0ylVq3aWCaWSU5czZsul",
	"bZjnazV46ryjWuPRmmdLfRqV3gPT6OZFrVYSe1c9Kis3yv75ab6rxWiM1SRzuf7AjgN0rHdlStSEVwgZ",
	"8ECVi+ikKFC4ivqpha8p+9ILBg6va6yXCdW30bWaTLGfWam6R6el5cDZwDgXrw5FxzXqLReLwzCJ8lQk",
	"Z3P6tVht0KJZ9IbwWHxj/fDUgKjKpBEQiIDZ3FBzTWb9G+zeDxV/n2KGx+AG2V/UTB2ri33/ubidJtYX",
	"iPrZTzxiKpqU8TAxO1QUUYRhppoaY7qdm2lzK02R5B6oRbOltS3SWs1+N0t7yf05CcakKcUllfVZrtSm",
	"ETyrZ8dIWgopu/YIC8x5Mni+RvVRWHbFf0NC7lM1q7dQ3Q41Uyj67JmxlUhPazNoMmqoA+45jFyoWVh+",
	"jrmlgYmQudIGjzhTHvXLPY3CipOfrvQGT2lYbnV1D3lqH61Sd41wFk1Kzn9snJt8hriHem/LbRNDcFNt",
	"uOiaZj1bE04vi9bg1K5bg/bT9dbUMrWPkzZLL9k4NUXHTxzQqhsRSf8gdRFQ6mizIFQLZrPmHITxoLHL",
	"D7CsrAth5ZiBPzUg+8SNc8VoNN3OCAeknFiB8pvaeedwU8NrsnQNvBQp9ZaiRrsJAedbHPKwwpn5HrhN",
	"IhaKDEcIIyVKuAr2rz+MRlWXrFWT2Mr+rsUnaiwQwG/D0r8prW1Q/On94SKARxayOIIQq4orajau3UGs",
	"eFzx8GATEmOCQ56norqruIjvN1rDeRKsIcTmKAD711rbZsFx5WgX8AnwRNgwD9E/X1QIv0YcRk5wVGVu",
	"ritbUy3Nvkl4UPYl58IQ9D/zYXq/XLhlWH7hbFwQYkGCPrzTqGVNNv6Ruu/Gy2LcTJNsNZ5uo9SslOmk",
	"uXXJ3CaWtlvMVrE5UxgkWGgqX+aWpM7l/IRL5ax4yZ4nX9YwAa5pHAczJLzLNdGW1rNDLi24koE3Yxou",
	"3Svn6dzAvJ/1ka42hcrG1LqIpG6IkPWupJbzMC+gMgrxbBO8bDV+VO4wZ2oqLK8bVi2wrmWsajUGlaxb",
	"KVuqy4zSunqmmx0NrF3T4ZRywtrEuhlul53MIi7XkIOtxrEqOVQ1R2rGh1Ku04zX5DlLgy3KcI/m3CKR",
	"SA/P2F2Rl61UH8Vh2FcilprHFJ3Qs4preRa1CgW4IpFZeekktdgqF9oVGcBKe8pMsL4TT0VqodIOGLlT",
	"/YQfreUSYH2C649TiDiscpEp5PtpeJNcxZc2RPtPmH43Tq/LV9mmprOxDdYl6Xk6XN4/jxf1vUMyNeen",
	"h+fy+VXxZ1u79nGmOT5W19Fs/UzM0eYwy7gYm3bqHFFrCaJljSRpHFeWMUkCxsb2g4PnC874/STPYr2z",
	"cppzcLVpNGFnST6+zR1Cl0rqpa8JajG+bjZB3sprtZLnXuaZcOkKmN/epZEM1z+Mlx/qtuPW+qT1jTn+",
	"u3l+W2xxW1y1DhfdhHq0lLEuZKR12Wd3Pr1r7d7uU33bIK9awJsacSRXsZ8JpdqE4bgwDd4UMzqykqhw",
	"72a/Lz7LM0aExpaepFdnhWhwNV6sXIwfRCJB/CqvYbgFev7DSxlPF02q0Z11htlCPBTsgqWURCu5o1JV",
	"8M0lb2YavogoO3EWhlMe89WkiFClsV9HXJhEKaa/XjZeSd3bpbqDNmJr+4N++WJTg86cfoq3vxt4LZFJ",
	"69pMizP55krvJtLEdisOq9bKuLiU29zKegez6uFWSuCHd5Cm2Mf9imhjRyb/E8SngagFEMuGCBsqZXH8",
	"ghqN5sIdLG3bBj6o066LkbC8TRstoVajLrLCslYdtpa3aUsm2TGXNWy0Qsfe882+x9MkA6EpaOJp31Zs",
	"W3nQhxqDzsWIWDbkccRrNDmO+PKWrK62tC3w8F7WWnq7tuyB8OL48jYckS0BTAW75XdDMHH9Af9lV0Bp",
	"aIsas8sGwlg2Rx7XaJDHS9sx4TFqtGXjaCxrzwUNK2kqF/McUQaBgiFDk8mml6Xu7PJCkyTIdpjRh+Bu",
	"a/nwwbl+8eAXKcFzh6LVWf2c6ldk2tURD5cNLvuKt+BSFkIaiXqxGGo+dq/vgWGntLLIHRGsYkG8UYjH",
	"jz/SCWFJQODle1H3bV/tzQC8gDqnR1FnEItIb0RD4sVRyPEDvUxobquoY3Itj/P4YI7zdpdXiGedeY65",
	"xHK2iCpygXYfHF5PgF1enJ6UrtybdNiF384WxuNOfv1HVYiMs3WT4XaTMIT9mKm52AGNAoGmm5WxZ21R",
	"rAUUgk/GVE5IUO0Z01z4palEH6CnickSpTbKwhctRmm46ge3LEeWhj82IeFu55hPh/ytwNHk3E7TQLi+",
	"z9rqyH8j+HQx+nMlKjlArtQG2EHS1k9YTkp7PCeb6OeSL5595vfKuWfKnG0+K3gGBFReeya59cPTR451",
	"OUkVOafGjbNG/MA1yNb8dlwVWrzbOZ1GWJ8MjqQk6nhRCPKFyx1xCRr6+s/bt7HovqCK+jjs67H2/erV",
	"WBZB8y7iMhakT1lA7mrunqJE9P8ggpe7J5eaJRauN3+ITpVND0G1zyupfG96hZTRDNYKmCfxNPRcipSH",
	"GFkH7v7rexDRIOpTKWN9DhS0dhUpee3y9XfXSYQ+VkrQYaxI32YnXtdpJOpjX9YesWy8JjLqT4nC+iDd",
	"pE79ZVxKk5KOmQehG01u0LKbk6gfi3C76mc6phsSmMwPD08EzPGn+s76yXyanJXX2VmChT/J3CnVOEdt",
	"Do/ZS+Tl1GyiByo8lruxA8aMjigJ5gKb5BeoMj5l8pS11OJzQUiDpx3zDlKrqtUmcE35URiLMWn2Kj6/",
	"PEk4hzmDWDBuHIy2ZN3LonnyYPF6NO3Iho5YrvuXL4B7+j7HEuUlJeI/RPDKKKZbJx8z7tOq6KaboK0F",
	"iyTX0mK28B75KFaTi5XiFmZDHpb7286bQDf1VjcOcT/JAlLLkp9PFbihccwlGFw+CrBum+zsq/sTZ5MW",
	"NnAnT5W92vKomOOwRs42Xu8ddFnqw014eZdL90ydIk9yX9d4twr5gopXnSYLK5VIDwHRERpAEwP9FeMK",
	"DXT/g16nzvVOOtiXL0oHa76ucbneZLAvX6wz2DSpcH606fdlCQPqDc5UGcwNr8no3MXQ3FVvab7ho0zm",
	"4DTjrh123bxjteemG1hn3cs9tty3S72va49TN7DSOE262FhQNbvQ8DUD/Ond0fEFHTO4Vy72P0h+O0R/",
	"+fHo4vXLF6/fH384eX3S1zX7F6dv3x9dfjx/bdJ7a2bamRAcQMx5w9w6afMp64noPwjwnp9/vfyRYEHE",
	"pXsLPISPb9yC/fzrJaSvyo3qyNwn/AHG70NkWkB/+fnXy/7lh3+8fm9GA1wKVgV+T7ufKBUZkzCESD6x",
	"iU7nOsn8eoj+cv7mWFNi/+To8vXl6btFE842WzJlvR4ksIVK+p2b3HBCpFtB9BeYXv/0ZEH3ufrFAWhC",
	"oGzEjT8EU9hXSc5fTZJxFHGh/p+MiK+I4JHsUZ42nkk39jpxkUIXplKn24FDNiywPNzbs431hroW5KxL",
	"/ap6lO8ZR7Iqd8ajs1Pj3RUIekMkKu8bswAd8+k0ZlTN0GujJfau2GtrDED4BtMQD2mof6cSBYRxyN0t",
	"KRtDR4Ok/gCaG6TND5A+1fWu2BU7NouF9OJp4qScQR58AgAdcVExQJN6gAjZQ5ccjYlCExJG6JaqyRXL",
	"VClMoouikGBJ0GdOGeKxuGK/XYTYv4Z0/FD007duqccTqXrhbO/Hn6DI3ncw5v/+b3SUSxqnv7yckOxQ",
	"9TLbjZJI3XIECQzAHzJX9RD9/OslMlhC8BRfwmoZekbnLrX0FXvDBfo9pv41UvobxAXizPBo5OMwlF1Y",
	"dt0c5OweztCMxwINBb+VRKApniGb+VHSaRQSqZDgsSI99IaLKzblgiBgZmb7Q87GKKQ3xEwG5K7xmbI9",
	"CaJXjLCABIibrN5UImkGLtKB6wX7bxiXZSnAldya6bZvaRgio++aqWTIaMTDkN/qTwaSKHkthMBPkaCf",
	"Li/PXH+HV2wwGFyxZbzMFjsd6TVCPCKmqfdE3XJxjRQeAilRllvDLpSG0UpiVx3hMaZMqgRcUxwQFCsa",
	"UpP+EDyFk0H3yvZbL7yhlTS5fJ6WumjCb8kNEYgqvcqZtdc9kBniLJwl+drBQ5lMIy6wmCETlNv0bLs0",
	"4dARHikiEEaSKISnzpsNSEqTgM2Ce8UE8ebSJJoNMocj5AsC3tE4TPd7joD11xd50oB5zxOS5gJFlFiX",
	"6/lV6aH3XJmZYz3MOdpDQ6KU9dfOUHOBkmcIh5Ijq6yjFAiabdie9RokrZqpM9VDl7q2qzifSdJ41Jon",
	"YF2EJbolms4luiGCjjLFbNNXzAxNd3s7IUwvDIEhW5qQRNxAXv3iWvqcSSrN9k0EIQgcHSMslDzUo0yy",
	"oOr9R6cnDsJQPU0S24V9x1dsiCV5+QIR5nO9LVovQYnEhHlLYnuKKPEJsLYsEwei1j1qHOU6A9IBql0A",
	"7kM9yTIol0vuK7ZYsTALVkfnsr1esUuusTTPzzIsgBESIKWFDwOvT4SZka56iXvoNfYn6eekVGDZVk5K",
	"6WI+nxJpV+uWZ7fuMtmz2wn1Jxr/gHLL//K6zcAuZfeK6a1USf1/kNl8A1hCN45SYZMnWE70hkSCG65h",
	"EoebESA54XEYoCG5YkBxARG2nXgYUh99G9JrgjA4xGrl5jvkBmGauCaztA2UacJyElv/ikVYylsugu96",
	"6APz82urx58sp9kQHzPYLd2T7kNx2Li8GNISFMAdcD+eEqYspQ55rDR/1bWA/cMmzKHZLjbwYsr8MA70",
	"KpE7DKL0ivGRa6KUHlz9zKZ/PE10EUFGIA7MsxIrC/QwD6/Yb79ycQ2OzA5IecJJtZVliuHE3yPMi+Ue",
	"For6IZF7z54dPHu2/8PBwYvnL5+98mxPnu7JUxPipT15R2enTvspcHd0JkkccE/zCvTaLAksOBVScz5k",
	"8nPofaOMKgowgOlokvMufjrynv/wMiP0U2LBRmu1DVyTmZHw0UxNtN5lvicC/R1NptjvMXL7rXlc10U4",
	"on1oqH9NZt8luP4QWdfvf5CZU4rBembo3/YUUnbt9izlN/4EU6YhQSWKhAkyhQSJQjxDWCnsX0tQrq+Y",
	"JORab+iUB3Q0y/E/k3tD628fz0976BTWBexAGpPmvYiPFWHGf72kKmZG6ifffzw/NevJOAoI5N3Xcp0F",
	"9kGLayc7w6WrrSehQZlf8f92G3yI3r6+RHs4ons3z/e0TrrnYuWDSrb3rPdMF08YLyR+BlsXVC2tme5o",
	"D5KrfesS7tiZ/4+bcj8W9DsgR/QRXo9lBm5F/igW4PgPmwYiZ55a3meoJelXM8Bvv0vpRUuUDKkwcteU",
	"UowQNdWtYLpiqfFFjx5ULvN0YY4pp00CeyBoohVSxR39WfK7Yln6A+nLwwCePWCGpvgOhIquK+2o7EMJ",
	"iXAQGEFWMoMrNpwhP1bKpIkfIRyGpqZEI8Gn2TmhkiklZaBnUxPmfotFUElYz/ef73vPnnv7zy6fHxz+",
	"8Orw5f5/KkkpVzhR0/rJEP4Oo+kxfvvtd5Xk5Ur/dvjs4NNu6OpHHsxgufXSWuIKsVyDuJLJo6FuexEh",
	"5Yknx7tQnnUZRhPhWchxYPLN51WiHjo14/O1JLudEKPVC2LsaWYsPoe8/2aU2Qla1hdrqsFsdotnXXM8",
	"nSUMzZKb3jClz2k8tyV5IqKJMt2Dfq1Jj0wjpSUHQuX7D4XTrXlDGQ7DWRfltGArKRgOQUkC9gqtGCYK",
	"urA9MQVWCdOHhRGHo4lJDp/l5vmRW027D03/3fbcN99+WyQiN3DTj53NNzlN8Jsu+ianLX+D/sfw+j4N",
	"KpvI6NHfdNE8PiqrJdD8pouyU3GL2ul2QuoTJsEo6IxqEfYnxHve2y8YuW5vb3sYfu5xMd6zdeXeL6fH",
	"r99fvIY64P4GsW46eZWok3lD37mBaA/6iI8j2jnsHPT2ewedbifCysRbd4LIGCA8EocQxN/ej8+Zz42R",
	"otwm9frjL0f2sDkeG/1c68HoW/gBR1FINVA5+vGn16kBC86v3/U6MEajmZwGSVev9WggC03E9QLoIT3f",
	"r8xvkpTbY1odA9Dp6b/Y319eZYgDz+6uqfNseZ2YWTf0P0hgKh0srzTiYkiDwISdfPH81fIainNvitnM",
	"jQ9eqvxQZ1L6SC0YDj1zePaIENz4QMp4OsVilu6q3qYOJAuWncPfOvZjusGdT39qshF4Skwa9YqLvLTI",
	"ngVJBAq+uapLyC3wbAiVvS/WM5QGf+4V8jnJSmK81OJNEqGpKrSHf10d2erwxFTal6VjekMYOjqxbyAL",
	"5PaWqKPA+AKfYIX/aZq4gAEUZp0fxwUX8NwL+TyMp9aglYYa6KL0fX/P2deN41NiAZdcqP5w5u4X8LK7",
	"WBzRHoxJ9qClnm7AG4Kv5fzwfiRjykDKJjoBHyGB2Zigb+EoJ+kN+U7Dde5q7H/RCRlBlimNWhvQNm1l",
	"Slks0cE+CvBMVk1MYTDhp9Oq96JmfhKvjfgomQG5W3kGFWMmLFhpxEuwYDfqmkad2qXhKGOvwXMccN/d",
	"tLj495q7mqP63mdp3PDSGdS7eNdE5brpRXhMmbntWeaPkqunl8e7pSzgt2WOgjZDTJNc3UFJjrc/67gY",
	"/1m4CPrwj4cuDPZf1BFtyhtp4ftAxMdbolLGWsKBMzJFs1ZkeWsHHh2ZK6cNy5kC+zCMHZ2eOMhDFL4E",
	"8Yn86ZgUt1qFdY4tKYrmIZ+TZhDlY+9Lklv7z0qxpZeLshG39omYWRkFtq+j0yN0fIQYD0ivVEZRfIxf",
	"m3eATRfJsJTJLBCaj9k3PFW8ZTFZmJeInp6G8Un2XMC1Fl/bwZehC7PuQD4ZVJkf5XYBtaSCBlTPUL8H",
	"6WMXgmMvjeInFwIFg2bXReB02kVcpEEn4FyeZJE0Z3cfM2SbzuJpGZSOM6NZDVVmYxpKd1vJCvmGtWz4",
	"+Ybjc2riSqiHB7DEvUN+XMB/iDD2c2T3aNDMcDiT1IRXW+s02O1EcQnu34R4nHHW4WioTzAI+v0DrIUQ",
	"PwI0jSKyL/SJ48iNcROmgwdNoDkSg7kjnE4+q3dFNCKLiCq7xVIS5aUZf0vZ8y8UnBjgSl9qnUZy83Dc",
	"BpIqbo2uAU9h35qWVzlXD7TKNuiigcLjgbmuH0zJdOjiFA12c8Qu68FmeGrcfCQIRGsivRENFRG97KGy",
	"rCOFxzvpxz5Bgu3cSYfZjdxIh5k3v+U90mDz/dQSyNY+5OEGkt/akRrVsYHyoM66ZoTys/zckxqN70yy",
	"8CYn/ZTr1Dngl3zzCA/896+XaK68gI1nNRMocOoKbFFD+QRJmkuEzjHARiLM7HAdc8pLGlMslTX2XE+k",
	"+pEHs0ZE35Bu/yzxPk4dFeBSTh/2Af5alylMJG9/+HMrkG06pxZpG0Gaocrilq+Arwplbe9Lhv86K5QR",
	"AUUsncD3S7Fkis1hqenR8fFcxzW3EO2/qgFJ6ykHf2rSMFwRKt0pLebGtJOJl9o5xoxxZePcIoyMLoYC",
	"MqIMXA6TDesBu5woFfVd0LsX+68Shgdv7zoHI/y3H0YvX3g//PXZX70XP7x87g0PRr733H/18mD08iUe",
	"4ZeaEp0jbOdQn5VeePvPvWevLp+9Onz+18MXB72/vXz5H3jdV1tjgsl6twJHEehHBcbx/ffHnI1C6qvv",
	"vzcu8c5VV1Djl1NnDa4eCsZP7GA3gPFu+bnrnOiVuSHZDtBwZozbRSvXMty2ouTrsSKXUczulbvC7czp",
	"ibPnZgcoiM8FMABhKb788iYv8Rbe4Cx9AVxpkzLOcEtlpSm2Eb0zD7eKCCp14FSqf8JRsqh/9loFtOUa",
	"Wa5hnUB3qbLupckfqo2P50TFghnz44RKxQX1cYiMAUlOaCQRHSHG0cfzX5Cx2pgnORHxIYzJMuvkcWYQ",
	"BX53P/bF1la1Nt9ZzRqVSUdSyzDV8qYdGq4yGoOfw+zDU2z696nYNGC/0yH3XHynhPumGb1M54W7enNl",
	"B7WREsSm9FisL+UOKBCC+L3ud8nF0BtgZFqDtX49yWvVNEtR1TWQ9Tmd46UF15570nqGk1x8sZa53Otx",
	"qQ49J1wmvXTdKksx3Azwgj4ATVR6td0X/wDP/iRhyhL/niz7hopWh0PuEnARw4AK76D8sS2+Qdia8fRz",
	"l5K1wje3GL0fk0Y5AbV6wGo4tmephf4fcP6yBeFxHCu/RVx22npn+1rN+W4ln/puPXeTxGdx0EWD/BLp",
	"byJBNTH2rymDz4TdUMHZ1GTknf/GlgKnFfBj6aURl3Z+nExmthPXjuxC7aTD/E7svMudzXNnXkc5cbjZ",
	"Hu//fUsd15YMQ1zRjmDXbiXnlvY9y8NwiHHirtUs1tUs9tI0MtUKhn0gw0d11Aw0nCEraCDgXD21A44O",
	"P87+YTh2DVPvbiXnPQiyexXWreTcoeSsI/cy2Z4Wx0vPxCYuRlDnCoeNDtHtsfqh2NWzB2rNYi1CW/G3",
	"mvjLWcae7npkXXgXXx6cvD47f318dPn6BILYnX28RJRJRXDQQ4njRYYekwXsLXXAuHBFT9IxrO6TsaLa",
	"78bryYj4Jdp/U5eNsqWo4bjxbPPO/kFAgn6OntdcorLUJ4JM+c3W+1lNAhmX3qAVQ9tzPamg9tWkz0Lf",
	"roqeanKYlq+0fKXlK18jX2mu+eV/cl+v9mAjGf3SlxsXacH2BceOX3BUv11I9u9JPeS4WD5fiXyzRENi",
	"Vyl44O84slBrT785802tsSWcbqVBZtjkJs/qEPvV0916umCdgAcRl5IOQ2IDxyJdGZnKpQZnKHWG1eTS",
	"llka9wANZ/Ye2kSghyQPMn9DjahEg5FJQn6PYQ/sCB6DXbM64fEj8Ol91DdpJThJGKj57Qzi0W4x3miK",
	"8+2FroEALEl2BjhUpTOXi2PV/DghTz9czQaJqzLYzSKCqiCIvS/mU19/AlXdREPGzCQQ3rAPZzrAaufN",
	"3Hhqy7vSVJG1XrVlEIrNNzYBK+ICxSz5JKi8RjFTNEyi6mpls9IUm8i+cyqvN/YezgynD+Oonxo4m1O2",
	"mL1Vz6zv0mhv/KEdrFuGqjb90K6254uT1+192o4NDhmECYOFphwrDqha/iQuCYYN5VHIx1WxuPTvv/Dx",
	"rv0uV3l0VsdX0zpp2jNC+rcLGWY+QVJK+5Fypv9KT9j6Uxq6W38yiVmc16Y5mO/Mb7Nsh2FDXXxxm2DB",
	"ZLhwbxsNQ0b/ggwnabopm0djLkR2D52OIEmEjCFCf9A1kTMhx1dgome7pBMugLZj+GULYAa0gZDfZbM1",
	"Cfu2P9lnaEawyC5unanD6Faa+Rafey7rBqdH6l11tjPHmwzgd9WfMQFtv6uMUXAnoQCBC268q9J3fTai",
	"bGoCMSlwAOM0QKYZlLRrmT/5XXNrRn4fuII2cQ78KmNIAmpT8Y4wDWNBqo0mxvz66Dy1NK9seomldQAv",
	"5OM25N6u7SKJdpbVBEHF22Jgvaw6aXJYh8QlYln0Uk+ipLiN9C8RhqyyLi8jFZkH2CiBUPH9nmvnxPa6",
	"ShhYQ3806CIN2S0YPxtzSDeiJ+a6anaUBI/KvLuc7RkSbnZt37K6Vd9oznOODMO7IFj4k11xvD9iQTxF",
	"GNZ1vpg/dpF26g/IOwjdlbJE/fsl/Nwmn2qTT7XJpx5M8ilgGG3+qYefHyfDYR9mCirD3ivvexJZtHoK",
	"Kr0Ee19MbhG4x/hzka0YnC5kNqOQZjRadTfJqEhOdnEXaqR3xU5HaGBTwfQzvQ1Qshou76wkyhrYCAsi",
	"TpkyljZhTHuZTq+YSUOPkaRsHBI7rh76mKTpHph3SANkr2wy3UGjLi9xLuW4ZQx1B11/wDZtPjRFibxi",
	"tnHN6guTuNTDn+8OGp5yEU1yYzXUK5WIfRULYitrRWNwxUzSardBhSZxKLm9Y5JooLm9NXgAK8+UlMaA",
	"Xa6IVKUXK952JVThfH0sNQ0J5MuG1kmAOKtSPbIvKetTfbfq6sPtQZJfRxNMD51wYujxlotrc15dQgtV",
	"47VP4UoGl9wjlpi1knw20Jp1etL0NDfeLHkNMWTDN1Zs3QeKsJQmbmG5PbAwn06jNbx0/WjtxgwPKJHc",
	"RXAA7KEPLJzBEsq11rAwNGt37xx2NJV3uh3C4qlm1fajiYX1qVtnDlTaRc7BOtZrqVET6G+mkLbcZLOP",
	"4WUbH1lSBk1N40arc6kW0rtiMHnN+bECz68FKwCI03/+3aK2Sj3V2tjqSjfociusgSTKRX6No4gIBMwh",
	"uwZm+00GZ7sIkO/cCuXtrIbRNkvp4tn+ftldezJuZzC22gUJ0NDwfxNJXBOi3vOppqr9cveItTRczojV",
	"cEu2IuHrbg9uJ4RVrFUqNnvoVNl9kAvlJGSKREdhCH8Z56qczHLmOc1RqG9KjSgJA9lFw9impE8f9tpX",
	"nqnmDAfKgESEBfr4YjnSNWWQDR+ac/TSQxeGtq6YFdZ/16x8YMYT8SjWc0ZqwiWx/QREYRpKhF20NXOe",
	"joiAKTOfGElVrsmnR4v87/BAtczNr/DMZNFz5szj5WVm8O4ab6Phit8lcidO9pZ0sPY5an3qlEQBoEu1",
	"DyqvGKGggxl9BXHh6Bl9S5VuQFd096yWQHUz3+XoPfVgsOO4Yk7Pgt5lHEVcKJnh0AXVZsnRrxEhZPZu",
	"95RVctC0tOLSMVoxWSCr2jRTHntyNwSjCyiOBtDpIEcG8JVRQjQTM2zPcDH4MhmKfZRgNn5+dexsPpUe",
	"yC9zqn5KfxEPZ6CaUz+jmM8zwTkpK52Khi4ngpArFtDRiIDRJ2nDLjkwVedFfnjFPPT992bpvv/elmkq",
	"L45SFv4N8NZv5pj4FUPFKTiNL6e463lReIyhx5Uls6ajc9tfsvXIsAo9qjrc4jvjgENVGfrnRgpbvtZQ",
	"/27J0T5HaQ02WzLYpOLO3X/C168tt9+lfcacetGlOZ2UWGjyJ6vVbDT6VFc7SbhhdZWpwitzhLfpwb86",
	"NFXkBT9BP2K5KzitkVJ4HhZJenA8DMnmEoRb0GSzhC8A0HFuDG1a8DYt+Lbh689R3NPB8bbT/C+RhW1+",
	"/xbI9wHkuTChjwbGIefBRKs4XiyXQNc8iP5R1/hJ19BHLeHMeuXPTj7KUhzW8GsZUSEVuI93UYiTP8HB",
	"u4+DQBApuym3yJYM+ZiyboVnTNfFH9iZl0z5Q2o3u5249iULuJsIn9k92lUQ0wwZ7KTLDXl/xrFG5MJ9",
	"A3LeSGfgUtTmrU8YXQPvIF2ndZvfsdu8kx5OqmZEj/vpnrLSI4wYuZ2Xhb2K5PR6sGs8h25yG2S2AsjV",
	"YrGmW122oiTKk8QXpMK3bUmae1iLB5Nd1CC3xeVm89qj9+QWWbpeBZ4LVNC9L/qfBgHSyB2VQHlL4Wgq",
	"JXBs46Lds3Gzmzp+LLUzQ0wy97kigtc6FNldZLKYo6xvZPWx5y1RCwisZXdfQ6IyJwHvQXEpXHbpDitd",
	"kS2nrRdzBs4q3bIEmhFW/qQq5kwpfFLy/qYqnMyaWtNqulLjQLqNlJ1WvNx/aJatay170xFepLl8ZIQJ",
	"HobS2M9Ggk/RNA4V9UYQxADp7SFMWdIuoOMcYhnrsb4b4Y1FWbL6/ibDIdl5pjCpM9ddHBrmZm4DsC5m",
	"GYTF0950hD3sK3oD/Xm2ZpvR5CHB3FJdbYL7amR0qTnjdZYVUdaIER0FwcPnQgUetHSSu+dAv4u+b3Ow",
	"F6OVchX1myxLy3nuifM0g9JW1Y+MkFoaQ27BMG1kD/u+3Sq6hdPuuxE+Srq7cLFAWrHdgqcBeBw1vntz",
	"hNKtKiXAr1tgW6iRxcCFBWNW+JGgHLuuqU0Lca6iTUpwRw5svMqU2/NEy5jWYUwp3jRrqiCy7QnzVPOr",
	"Mie8vouoIJY9fiORqYEUhwR7GJ5Y8TE875Tylotg0bXIhemutV49OOXS7DLInWSTvhpJGFdfxJtXzmuR",
	"v2npg7gwNzcZDOzC8py9bG961Z594m3OHTI7+NYe/YARndLvBVEbAHZGnvhEKEWmUajlVu03SJWvj46J",
	"UOjStlftf62LuVLtu6Sv7tIzTyXlr5RyZR6uU3Qlfnb2yCG3UDXR1r58aF8+3B/Sy99BPBbAhwQLiP03",
	"xJJsJGVUqfHmVxoRiWY8FsYlAs58JsJBRMQU64bDWQ+hC0h5YCLbwM+Ku+ySNttBVinsoTOXpQ4KQ7DN",
	"gEiUhPTNBFjoIj+Wik/RhI4nJnB6mqaxi0Y01H2MddsTKhUXM/McPxdpz/5SdZRM9ZYTt6abMi4FFYlO",
	"ZVnSt2IkliQjsGnn2C3QW70+J9aeU8wXZEpnArb+ZBZgUek3NCSnsJALCpcZdorK+ounpKw/mISfKQ5/",
	"SnA4Fz3Skm4tpRsCUC1NKZnER7blQc2OBPeJhPCHmbjq5EYXKH9YdWx7W03Q38fLjtqvTszMklOAiyO9",
	"cgM8blB51TxHdXIWudxENHKPo/SnCZfK/eJzNqLjWJCgr0/z+it4AuRPiH9NmSkyjcz7tc982AetspjI",
	"KH3upj+lD97uMXXo7h5mRTt9eua2b0ch+nP0sZM+b4iQu8p0A/ZCuaPECllk7Wb3TFhwAO6G5pjLylxO",
	"MQV2sZuODdvup8eCR/gq8/7Doa8d1dwIQy+gMgqN4vs0g5k/kBeLqVqWnICTb3b4PFEibPVLc18wr1NW",
	"XIGYsW7uqFZgAWUObnZEK5G1/jKIQ1J2wDMcoTL/d43beduJsVGt7L6QeRfpZ9f3/l9G2uG0byM3e6OT",
	"oGgJCyieHc0jt+2Zn1676JdAl/b8qTgK+RhpirccAcEwZO+KXbH3XJFD5GMNXzSNNWGThJJ76A0XcO8o",
	"F4XSx+jF/guE5RVTEzKDsxDjKok2jrhAOAz5rYmor/vKN1YWwP4XPjbL+hqWbGO5ppPImjVCu86zlGwg",
	"Vyyv+8lubsoTKuTjcZaTFDetBm95/lVf/G4O7GYHHPk1x7p9cbYJsMcNsG66tUn8+O1coguFIJFSHD1o",
	"8JunXGapT80N48bgD4aDMownB/2yH/UyLPxRH2rLfnOn622koW8VjifKe+xTRsuCIB22XIkHfTF/1Iu1",
	"kD9TLDJZV9wKZY4X67oita4YS+426iqh3QXR3kxSqFX3/C1RCzd8R9wmNX20PtT36jRQmyA3659qmWSV",
	"h2rCALfio5q8OV8VRFlNZ8d2mQp1plVLWgaxrdgMa1hOMprMXnLn4X3mw8UX8hDRNCmPdHn72Cyh0aq7",
	"92NX62fdSXsP/3ju4YHX9mkw6KIBuSN+rEv3FTV38OYRlv1LqOR7woLk75CP+1qOwO36PDeFwtAF5KdJ",
	"LvGNUxU4AASP4sp+G3eUjSjnMx/2Qj72QGSvVFtqScuZl0razoqj8HHojQWPo7Xb8olQwAypT+T6rWFP",
	"kDGVSszWbivwN9cWDrwksen6AzMp/DMay2rUYN9XrlIXEO2ZjFOrbZQ5jtBgnf5Xru3YnEkrvurqCbVG",
	"fcKCNWprFuoZFtp5Qhfz7gYTdJWnf03/GJXTmnrikzzX1ta0FZbXeVU7EkRrAUmvS5VvaKKx9n0JHbfq",
	"d6t+t+p3q3636nerfrfqd6t+t+r3U1a/SzXFr1H/dvbtR3pltsSDmZFblABUn7kWui1fuJI/Q8F1naq2",
	"EfylmvWs4k08vzQP6TKtMLv2au1enZJlCb2sd8mWHPgfO+9ZbKeo4kZ6+vXY0aUp+TXxI7s4LUNqGVI9",
	"hmQJZk2OxK8Je8QcKS4N0jwmTLMY8NieD3kKM15sMT0nUYh9y5MuYYXuCYd67J7Zo0boa5FUHTO5MXE0",
	"QJixGXGhQeb+7utd+3NRSHFByQ2RMB7r2o6mmNGRFhpmLNar1DVZ6jfqfnxnq96bC6kbiOcm8SAlx0Yd",
	"NZM5JxuXpZuEKnYZYzTpFcHKl/PhHI0uZMYNH35+qoeKvS+ChARL0ld4XBcjAb9lIcdBOTbQLVUT+2Ua",
	"hmHOtd62cJwBVHP/+iFl2IRBs+n1Hj/1Jks7nGUW72sm5G6RFoFgkcJj9K0k0xsiEBfoqgPR2tRV57vy",
	"IWYIfeH4Fpqz6iJpD0J0yHhaE1KuuIlktjKusmLo2I2ghRYsX7LELbQeJrSMoZzZp4yVUUohFCkRPmEK",
	"jwniIwQXrQgHU8okRP2zN7iZUILlSEl7vFBYbSkBTNV77OR0FfB4GJL0fMXi6TAX/m+VfApfU2hPFwIT",
	"ZWkIsrDIuch4yAZC3GYO9jmajqHQ2uGsXVMLIlnbEm0U66/umVpCHBUBrB0ZPtxQtmVA2QOO7gk6nqi1",
	"AlfLmVRkKueANMHSyAxkekCK18DVka5xbobUxqtu41XvDNNZUn0y2IYgE5uMST/BNySPas7yuK+L8Rbe",
	"Lbx3De+nAGyfM6kEpowEXkBCMjZZ4taX4vNQL0rzTNco7Vo2ku/HaRsnSROtvG8Zwq4ZQjkxPx0FIMsn",
	"tqMGLFxBpHhjvSDDG1xiq5YhtAzhHhhCLOcy1jxeJgCPM/AwJJtjAFm9IJOkqh7CM+Np4d3Ce5fwzpHe",
	"U4H2tpPONZPfba65Ftv3h+2nIbQDn0+3ZpXX+DYPDwk6Of7wDnFWA9knPp+2h/QW2LsGNlDokzmSA7A3",
	"fhYvQXRjya3x3R65W3jfB7yfylnbBKKYkumQCDmh0ToYh7bmRTeVCCPTPuKjGqiGVKjv0gG12G6xvTNs",
	"AwmjaZb6HjvCI+kJMuWKbNVnxnSBzvgtERcTEobpTXsNzJ/Jc6jfaust5HcN+SrKfVLQ385d2gLQN1bm",
	"HQtoFfqWA9w7B3gq2r0Ioq3a5M5Pzuo50JwHUSvbW2TvGtmaPp+MNNdg3o4cT5dpFcl9HkSt0G6hfQ/Q",
	"fipi2r1M3BCw4Ukw9hW9IemjxxWAfeGG1QK7BfbOgC1Tqnv0uP499KwL/6ZF9sU/f1n7RcvF72H7qKUF",
	"+K4BnpDuY4M4G9HxwhRsEmVCASBTIbY5zdNe0ufblEmFmU9Kk0McRdExtHAG0fCLGM33f+Z+RDZYPnoX",
	"Q6CqMOS3JpoIZzd6Czg7TEfzd/L74Q0OYwK5qcti9ydFOwuDNmwlSkKDKNg4ijyz4h6MuE7k68cYJ/Gh",
	"RLEuEHqGwnO4BtRsMbJCRbjBXwWF0IybAeQFmcNjZ5thTIu03DgxKVu4QzuKaJr/9prMyvPGa/aT+WVB",
	"YJMWwRtBMGCjFjQaITkvLBWmrEmQkyGW1F8U6sS2uCjWiS3SBjv5CoOdOPKoinbiCPIhK5glmNnhkwnb",
	"fR1stY8m2sPj/eC66tXEg4e3VooiGpE9mztqAZZt9MdYCMIUMuUdjl0zZSA9sb9dmB52oNNBOjoXYK2P",
	"GQ5nkso+VvlYdlqeQsKmblH9S5djaaBCN3cvSb/VSZPd1e1x9xH0VkRSaUQ7PX1LEXNR7CxR7CKCnU3g",
	"uPfFZiyE0D1KYf8aEux5I8oCysbVNP76LuLCBG20ZZHJrpiNcWpaRDaoZJ7YTQNHUOIMq8kb1+MSK4kt",
	"hy4zgTXn7B12QI1CVhZjZlJ5jbDvkwjOk9YmU9mj/vEISpP6mRIBEoLKay/tqGwsF3qphzObubKH9MmR",
	"s3CGZD6nJaISDezsd5ErciWJ6sub+4k/+5Xo0haZGeyhUYotx28M8JBG3tazk50Aj6lMWpGwoJVjzJZy",
	"sxtM4dE1RMWVy6y+rnRu3aCm5Wim6XI7r6uccjPNneQbLk5crYU87aHiuyIXbMpf108Iuyvzc0FpeYqW",
	"5cebUbEMfl8VuwqIwjRcxqZMKRKAIonwkMc5Rp/nVb1SZmVml3IqeWJ7LizjrqDf7dx5Y+7ZHqx+d5Km",
	"QqubytuupjQZtSkLyJ3+w2llH5miYfOM2+ichCbe3IRGSCtrEiwvQwLcmQSIMzR4I/j0zNlnBmD+HFzy",
	"zDeUIRcw3ISoIvPM3WwewEHrnnI3/L2Ycq6sz9z0trn52X4KJFBnpJlF3+I4M73MjbIUNIJP+9FWhlXV",
	"peI77jA1TvYnWE520mfj81bdzuqRWo6xbGQMNiN2jtRyvdQgNmzL9+MND6uqw7Od0tmbbeieFX2lAmUn",
	"3W2oG610jYkw/dRLrW5EoYcbWOStwGxUx4rVRnWa3S7Ya4V1zxKcEZsSfuvJ4et1YJwKREYTcRa6kj4S",
	"tpiqoUPOQ4JZee74Ovnluw9sKUIq1Y6XoE2yv9MjoWG++dNNkBxVvppzoYywuA4pIwtPhibFJQ5jYu+G",
	"hVYUJGHml6QRc8bQsLmhQYzD+eN2iW0rOSheuEb+Bf3UsWkVz2jHeuUlVUQfcfRRy8rzYx4zOHqdTiPs",
	"KxIcSUlU8u3c0a7RAe4BmMlWy+xVX1vNrvuPZEwZo2yM9IJo1Q3xERKYjQn6ljI/jCW9Id/pA+n5m2Pv",
	"4ODgFTKXbv+LTsgIx6EJouzuLpNWppTFEh3sowDPZNU9iODTDaucc9dO5vKnZGrkbuWpVUxG8U1OZV2d",
	"ZAXxq3v2bikL+G0d+VtDAaHyOvGqqiMzW+e+1U2imXuIhH9bHv/kBeBmHA6tClHpbWjm07oafnWuhpYw",
	"yv0MDVU8MC8k3aPyJ0UYfAS9x7gbyTiKjEk65fTmVRlBJ9kpF9FgmpkDxKru8Xk5k+bqrHUYK/eTh9kv",
	"8Ja396y7cIJvOp/2ZvGekG5oukj9zbC+WDylz0ZrePYWPHqTyubQNiQhZ+Mkg0nVLd6c5Mq+u2vdeFs3",
	"3p3ITD9DdA9acC6F725c82tjuXXKb9F8D2gu88h/jHgOfE/OmL8FOJ8cI91yIzif+Bd2MC2YWzDvCMwn",
	"xyiluseM5REXhI7ZZuOv8FhJGhDzS2ojmksyfMXSmCyZypTl4H/FljGAN2YKbYyWlgnslglY7BSjtDxm",
	"RjCOuLd5hX0RR8jo8Vfs7dkHiC+hC6/EBt5GvFXwW3Zwj+zg7dmHJ6TsJ3wBspZsIO/JIlaABXFZJa4Y",
	"H7kqa/EDM+6WD7R8YId8YEyZJd4nAv+1IypDA7sGfxtwucX+vegA8yGXHyP0xxFf6cLNqvCNjHhvdV8t",
	"Tluc7ginmkYfOzzrKuRVinhTiLaKdAvSnYL0SSjQlA15zAJPiViul1/ItoRMS/MemEvxe2qqX5pxtDBu",
	"Ybwz188s3T5yOIeUXZPAq6kbV2IZdGTTVlNXtF+gVqswtyDeJYgtrT4BvZnHKynNHz421pg/xC1EW4ju",
	"DKIfPj5+aKpNKcuuqVW15Q+2fqsutzDeLYznKPeRQ7ruvVHFfVFDidve97Rg3SlYH9s9D0lG4uP6T4Ar",
	"H/+mE0PHR9VvgNNix7h9CfzVvQTOU0n5g+BcmUeIn509csotVE20tQ6RrXC8P6SX+0I+FsDf6NKLs5Dg",
	"MER+SCEJiT8hQRySAJmK5eGBj6HwhS27YpQnRu5UP+nPxmR6JFGbthGFsawfIeKQ7CSuZGE3NhyhqV6M",
	"SaAr2fvMh/ZvoOdVqtv00p4NxOCiCzZuJ+Q+Do3z8Npt4cCTSsS+igVZuzGfCAXsjPpErt8a9gQZU6nE",
	"bO22An8zbTll2R7LV2+Ax00qt3FO144p1iyk5/KQYpYXOPbkBVRGIZ492fBimw0SZlWAjOoCX6BvEwH+",
	"3RaS9XJZom4cA7gkwvOKBhzJIV9BhmPMqx6mdl752GqC3jm6q52fF3iIzc8L09tRIt41kPQkIhBtDDeG",
	"0tBru3f1gVPQvPe+wL/ORGW4fhEYJ/B9GTAwCxCWkvtUixiksLyWaDhDoILm8WEaMfh4nZBd01MkM+8n",
	"dfWnZk/aGH2YlV6BPrqLjmGZvf/Mh3b/hzN0elKeq7XICFuO8nRoDOwRKxDYZsN5Qo+V0Twdb1sYzDPJ",
	"1kmZOnieZupMT79Vyf1d3MICV6wITTjP+h6aXpDN29/qBV8Fim18wbU0iRHBKhbL0xOGIbJF0SjE48w9",
	"F2XS5A0ts+a9MXXe6Cqd7SbYW06IdgKensB6Gfi+qkDQuX3PJ8we0fGO8gU7Ot37Yv+CiyXFx+MQVN7N",
	"SiZLtpWyKR3DlqTTr4KCcEoBgXxY7tgADKWTqYHES1imDBZ3kdebMDwM2yC1D/0S2tAGwjmYfyOR3T6X",
	"Ol5xRKiaQBJ9uG/hAgVUwp9U9RqxhSysaUi8OAo5DmonyNV1kKmjzzLlaUPe0JB8hDI/myIr3CLFkog+",
	"mWIa9nEQCCLloIsGZkHSv/pTIiUeE/uNUH1Fp/CJsCD5G7LcUzYmst5dFCRwzN5Hwbv++7mRgnXYUQ6y",
	"4prvpNskHf4OLt7yZLOr6Vm63EE+Pkf2O+gqg6od9Nbmx2vvjdLDRCq5vM98+EjuizZ7MtBCFhkpi6yY",
	"TbUAd9ViC8hdHRTSfdlzqUhrZOBHrqxRL9LE++mdUVbxqMhVZttIlQ9Iw995NJnlV1GTV1RhSxIO5XbA",
	"KnjKLuCDoisQp2ufOmvcZM6pukCQkpgUZHOEKSuuNHOKcJESn+3EBFhglnWI0ow/uH9eZ2/s5rjdykRZ",
	"QVRf9Ie++dD/zIfuWm+zlo1js9WAK2QKd1EszVNrGRGfjmbgbAsF+AhZ2kBDoolO2msjSB4Cdt3EUc40",
	"lmpLtidPs8CFVhLC4qlexQLpdXNf/UGj4jeeXgV9SoAk3Nkf77y5nz91C6m/CqtzOSHo9MRaVAonzV6F",
	"Maiwb7WNQi9fVBmFShnDBb4BtjAvkxQv8oqSawz9kybiS+5YwWqXGLUSJsHFhHXczg7NdtorSZX0/AFf",
	"IN+jkR+WDZjPJd8V49kjLNg883ng8HrNgho4es2CJTJ1v6XjIh3rxd2CBB1HfANvtd6efah+ofU24u3D",
	"rK/uYZYmifLnWDbOx8N8kzGPh0b54SpfXqV54vBoBLkHjRJooLMYNW16uPZ51W7x6qj1EWN2N+8lP3xc",
	"Bt32bWQL3l2Dt+xF5OPCb70wWpW4/fBxFTnbRtRqQborkObDaT0ucCpKhPcHEXwdiCaNZIVs5inFLVWT",
	"mri9pET8Rw+nBW8L3l2ANwXAY4XwhhKuNJexbQytFqi7A+p8AK2HDVKNNE8SLPzJQmgqeL2iKUKj0VSA",
	"dysGrGCUxWCN1biES4ASSF5AvXNoZ6l3J5RFzpur1EEOivTdt9XXC7WuEN3dqWkVSSWwIuMZUlzvaQ+d",
	"kBHW86cSDUbxH3/MKsONKHN5WrwshWqdbofcYV+V3W1+2orTCQ4Cqivg8Cz3+3IXgOHEg/3t6Z3tPFUP",
	"8IfBQyzdCYeOhIHoDdiRvwxsttzzZ9GEiO35ypzHTCKMppjFOESmN4N0FFBBfBXOEB5jyqThPJqQh1gW",
	"ecp5zI6h9j8zPGCV2/E8cCjzwzgg/fy38w8iuhb3ZQymCIv7esgXMzqiJLA4hv+3uN0Ubs9jhnCOgLPX",
	"owZFNa9EDfJIMCbg/8IlNftQIZTPiYoFoMgIYEEiQaTWQdgYMHODBeWxBJks4f5Ut22NylN8TVAcJddE",
	"IblDGqpeJLgPnjdQulSvPsNqcpwZ4RI5bt0HrA4PTnh6iO7itvxxRCx80geZs95Lre7i0VinvEVjUViM",
	"idraWJzSoVcbnLkm/DbZFbvCWrmqGp6u11fLnLV2o2ZskRc5aje0DmFhzOUIZ0qLibx7FR8VqN4ecUxq",
	"kvzqOlrQO6BXl5Kg13K+OhqLPllkl/J+lRY54UIRzcOwqj7MHFkacvzIVjJzGQk+de/BNAUNNL3AizD4",
	"VMoOL2wLZ8b/aSkvhNbNScnQ+2lQxQaTcWyD8xAW1BqFm/36YyiNZ6hxSTmTExr1rykLNvOcy/GFx8jr",
	"1qPQlnHVYFzFdR1bfnU//IvH0Sb84XQ7Czzi9M+tT9zX5xMHZFHhFecSUj5U8+Q8MvZwMKXME3Q8WS+d",
	"jpxJRabSIAf6QRMsETSPTPNI8WVAOtLFz81g2guG9oJhNyDOEumjBrNzG8LDkGzOaS4BdMZ1bhmQj3Mj",
	"aaHcQnk3UPbn6O7xY3nb7q/QdV04txf/LZh3D+Y5B4BHB+XA59PtqNgazeSO+LEi6OT4wzvE2TIon/h8",
	"2mrYLZJ3imRNm+ePX7+ekulww/IYC4IwMg2bMnVl8js7mBbFLYp3g+JpQnGPHsITGq0FY9NyVhRTmcVx",
	"TfDCMFoAtwDeKYAt1T1eEEfSE2TKFdm+Vn3Gb4m4mJAwRKbLGir2mTyHoq2a3eJ7p/guEusTMGqLINoe",
	"zM9PzmpcS50HUYvlFss7xbKmzCeAXpsmdC3sYl/RG4JcUybTCzxegyP0kIScjY0rYt3D84UbVgvoFtC7",
	"AbRMSe6RwNnGFN/as5VTaF8a/2PwxLNOx5oBmBSzBRibOidY4c6jCp14b5kWX7Mg4jSbANRsa96/2CT2",
	"QqcuinzVswpINbEw17nNc16akyLJqbd6OgrTfJ9hm13C5keDv+HIRjlL8k3kslRU5aTg474GAaQ+h0TI",
	"/fTeKe1CURWulMNi9/nUV0jBPTZO3k8mEfjTz9298XTnhva9lPZXpAaTQ2SluoA0D5DWuY+U9qb/lWs7",
	"9uOZBBorrp5Qa9QnLFijtmZtnhX6Dzotx6f7TqI3l80R4rk3SZre5vXanRL+OZ+Tw6oe23p8oHvbS9J0",
	"VapKOa3MYlCfYMdEIUbuVCbTl26xd8Wu2HuuyCHysWbOaBpLffJF2EWgR2/cqbhrzsHEdXFLwR6oYsEQ",
	"Ri/2XyAsr5iakBmoVIwrRO4iEwSGC4TDkN+ap326r3xjJgNXSdIPN9x19buHr9AVkpK1Sl2r1LVKXavU",
	"PSWlzjbgXqjxVXbfVTZEKFuVslUpH0zWcJNrK9Gx8karXaqKfiyEJbBqmxqEWDAFkwxYcDESqwlhCp5q",
	"B04RfMiqYmIAPDazqc4csuuE/HN4a/G1/sHLgipDuDvG1ibS9yzKk1N6giOQP0ejVB8Uplhcu9A4SAvx",
	"Bw3P1yxIzm8PCZctHtfF43uu6IgSI0qOzk4RH1kqNTGbliBzHlkjyqickGCx2NI050pWJyk3FPfGlmtv",
	"hlojQmtEaI0IrRHhyRkRmtsB1rJCtOniH1y6+HVtHJ/asKqrWzvmNbFdnsS2nCu86ixmYgNixMht8URm",
	"fnzwZ7ILPcz8qWwjIZmDenliH1Dk5fZkuNuToQFts4Phl0zO9jo+ggtdBFvTYOvNUWFU3LoxsRDj9Wc+",
	"RKcn5dm5N5ORuwpLez5mPgk3n4l8+1PqdqK4hAkcw4QkwijBWCkzMOVaftDyg1J+UE1Gq4isvZCPl+bs",
	"CfnY5MaH5woYXUywiH7Sa4JEzBZKs1/4eDsEnP/WzmJ5Bo0GZNuS4CKRpNnoL3wMif2fslAK+Ziy7R3i",
	"ftHN63PRjyHngcEUZJDUxy7kCxIQpigOJRyjEGcEDm8owlLechEUn/xBi41PTOQOTyPjugkz7k+JmvAA",
	"8mP5gmiN2P5x2Hk3u4ijA3Fx4IsDdaYHsi+C//qv/+p0O3rUdid8zsO+/vz/hnpqEz01kpBFj3JNklUo",
	"z49hUc4LKNlD9mo9nCHOwhkamMEOEJVIxlHEhSKwVi6Jlp1MMXtWt8NVVN7lB0bQpV78M7v4NmGZpGwc",
	"EjeSS322HVESBvDWeggpBwNEmVQEB3rIbnCdks7dIpf1H2W7dbkMa3XIVQSXLYXu0v0qY54phn7L70im",
	"4qcaHPUS8r4BOaIhD2YwgZCPx5SNEWU2nUaGLHvpBn7PxfdmAnov3Yi6aBgrMDMMuZoYC0Ie8aud1zMw",
	"SPKexWrSJ3eRaXqEQ6m5ibnk6St+TfQMyeznyfCtTz/Qn08//nH67D09lafs/Af/+PTl6XX0738d//yq",
	"R2Y/P/Of/2v27+fh9elnTt9f/vP5u8/vnr3//H/q3efXf/zfxf7++5Pr218uw8/vP4/V//36bv/923d/",
	"fPj19Pn7y+vbU3pLg3+/D316+vJ0+v5m+PxuBJ+vf6TDt69u/vN2chP8+sP1f379Yf8///751p+Gf/zn",
	"4odoODuVp9NwEhyfvnx3+fHu/efTPz5cHs3esf3es19/5X/9d/T6FfZuXr775yv10/Hf6PXd9GZ6cXAW",
	"n/x1+PPsPX0xORP9/7O7rtnrYeeHFy+fH/zw8qX3/NkB9l68eLXvvfJf/s3D/osX/sGr4csfXu0bqdFI",
	"jucXuyxb1tzKZ9j551tVReL9OcNPHIOM2Ki60JpiCwoD8WNB1axz+NunnGG2KPMyGsRRrCY1012FfMxj",
	"tVXhzGN4kJ+RzpgFyFx/JDzYvXJGP/96WSqQ9SiX8iNF7tReFGKa50Sd38Ba6vjnBEvEOHJtwePWT51F",
	"eZoKFPv99xex7xMpv//+il2axm1rYNe1eU9y3Wi2bdisWTyYwy/csM8ycUWl5tfm9GBKoRmPTQdDLQ5M",
	"jj5jFMYjRVKJwGPVWzyjNah6MV0Wtns1wpwShT3IHrX3xTpRLEvIEWLII6IoEQiyi/t8OuTIJs0pHLB+",
	"geIugfixLvve5dd5oqk/2/PYovPYYvpJaJjhcCbp1o9oJ0D0lae0BBPNEs7NI0wJUh9hEuk6mZxuPmeM",
	"+JBHENK7ldox9CJeCkJcKp+FLloagZk5z3k16Z7NlBtaE+/F/Jcgt032uZXMUWnGayBLTcpPFafrJ6V6",
	"55BbGuFI/5qkpNq6qVF/kouk4hxM6si81ph+j2gE4irPbAU/AWlRIh9UlCKm9H5JxQXZQNK395dIa7fo",
	"QrdXDbT3SpeCQm0KuK8OJ3kiKQdMrszDjfFVhZ6d5Z/JrVM9rLXZaNr4ffeH8/KsNI8E7jzegIz88LFa",
	"MH6IW3n41cnDDx8rhOCHj48GCtBCrNYUd0kjznRMAjScOdgsRMxx0n8r01qZtgOs+hmCe4yAHUd8Lay+",
	"PfvgkjCNRsRXtVD6VnfaArQF6A4Aqgn0sWLTRLZeP8NSYzGaxNRuIdpCdOsQHTtqe4wghfds62DUJGFo",
	"DNGPstVyW4TuCKGxfDwarv5tRE1AliwsI0EgxJe7cJy7uXx9dv76+Ojy9YmeLHpL1MWEC0WkOsNq4rxf",
	"e8jdtxpC0hjO9IeGRN0SwpC65dYzgLL0anaKVRHSZ5nhLgvZAo9trV9OaaATCMPCnONO3QvWbslT4EXd",
	"EBY076R1PHh6DCJL+gYQubwsxsVlW1wih3kipnRJjiQTrTAMkVt840WYqdorDa10lml7pZhKtj81G3TR",
	"wEVWeoCBjcp6SMa+Sh+RIAGEVeyNaKiI6GU5TqlLk/5nFx3NuU2t2k3mhf9XF5V1zoslD8AG4UzSmrUC",
	"tLbce3PBTPKczfHt/Lc75t57X9IPyz0wMatk5t9IFBCFaShLT1HpJO/rPXSW7luHrfvUYnK0sFsUFDTv",
	"05PE5yMZABLE5wIeNgiiBCU3xNG2PlX0yn0tcziq/YD14PmyB6xRiJWusffF/QVmEE343u8xDvVZWyq8",
	"INEsvHmURFAiwTICwVLGY0HGWJkHKMg2hKAh+yxyTG8IQ67TUlDb306wwv80LRy5dldS3VL1rItS5Ww3",
	"2lh+eD+SMWVM69l6FPBkl4+QwGxM0LeU+WEs6Q35Th83z98cewcHB6/sifN/0QkZ4Tg0wZxcHOGklSll",
	"sUQH+yjAM7noWFnuZ67bMSHxurWOlRUzIHcrz6D6jLrSiB9u6LnaAedyUHR48RKEtSrTGgdeu5p5LoUz",
	"TMbJD82DkGVCuxQgjgdW+uBnuPZCqeBetmNdDP8RC1Lyuj0vGbiEUKmLuX8Si39CpeJiprmAXs0hlsTy",
	"e4lv4ME5FHO/lTJ80+MFdLjS2dy+SJAuxHHEZSxIn7KA3OlvFCWi/wcRvA82e3Nmp4r6OOwLKq/Trx/g",
	"gX6ZzfMXfksEGsIzVAj6lwz+f62yEQuG7La6vdGyQHNxrBBGMiI+HVEfuPHeAnY8EnzamB93O3femHuZ",
	"Jk7SGdWZ4McoajzBOFK8ycwUX3Neis/NqqyXlE53Yh/JA2HztpLShcxDbTedloB5Nx1v3AJ1/5Fta9fT",
	"qPBuKQv47WZC4urN87Li5+nGwX20h2zLZLWsplJRP2tyOqfy2pXYop1J8JA0vh+ASuU3A+fQ3kp6h7sG",
	"yJR9RLcCrZ3+sdrpEwg04a48JK1tfse2ecdbEhZpP+/CHg9EsvdF/7OCDV5XW2J915O5L7u7oebW4n6f",
	"yoDd/13R9gIru6aGMvs6PNuqNq5baGzQrC44Vz7ewLuyc84VOj6qflymCxzj9oHZV4g6Qxnlr8zsrw/X",
	"r68EITt7X20XZyme2kfVrWvufWC5/Dn1g4e0xNNw+XncJHQjggTo4ujdLygS/IYGRFScyi/wNDxzRXYR",
	"wUfPop8MquHhSlf2XOVNn7K+qhMT0EZ24+sGWtzgyUnv5l6OFMojgR6DeUHarEo5qjbhuuHxFjg8aI3T",
	"5FwiCsO147/f/VKkfNNilvYXxuyexqGiERZqDy6HHWFXEb7ruziTd5lRQVB/PbRE9R1ShsGeU7gBcVGi",
	"5yLeYeMWoKdfWJmSiNMukdL6kZrXP1jOIbm1hmwoPwUQNsLovaMHR+AmfYQjwNUiq+YBu/clx8vdIcwY",
	"6YrUegLfgwmE3FEJ16KZyL4F4s0j1tQuIHbLwsq80iYBhNJvKKugyqMUUc2PbPuvNuqcA5Tt3QocRcAc",
	"CutxzNkopL7qoUsXBZpKpMRME5XimRDRVCB+y+ap62GA1dA0wnmgNpLFCzPH2JzDIA9pYJXfRHL6nI3o",
	"ODYYy7pIugFpOtKVbADpamy+JWr7wNyqSGlNIYuOT6uT52YNkXl5VuWyNS+UNmh2BPknJV9sPQlDs2KS",
	"jhniLEm1KauAc0HHTP/3gb3OFN26cEvHtcIhTE/O48xzjWxY0j20rAlLN/Zejk83JABzECVyKUkaN0Fb",
	"Okli4/yDQVkptw/ckOCfto/VjHQr+f92a3kG2PQiXTj3dWF2sy7SX5Q7o3dR6hHwFTgEuI/b78nledlF",
	"X9Ln0WbWz4aRkA/CIWxtv66UH7SZzbdtPstx0wz7P55FE+CkWxMA3YVGMmsjS4c3q7R9Wb4+WyO/d0Oa",
	"rJmbDFg3OE3PzWOZ5erZjo4Z2SnVUGnMggctsmobr/LbXh9bVcrR3hf42IcW69mpcmaqzHjQcGZOHuXm",
	"qRyocsRZ6+znOeptL/W3Z21Zlbq251eTH1HpmTZLvuueaCtSZH8ENbkh4ZtKD1iagPK/ijTZf5jSpPWz",
	"2wZzcLS/fdEzH32nSgydkxt+TWT2ZTsf5QfoMoKbq09JwEPHBR9bLJ/yD/ZXRWye6O0ZUBbncpS8XDem",
	"+sB6DkE+wgm+cZb63Ct+Pf3ATDG9353jlO5wtCS3aA3TVD1mAqPSzCSziRXb4vZhGZtp9YJ7hn5toM2H",
	"9fuKNIYsdyNY+JNKc+MF/AxgMZH8DMKkVh/AOYML+xU6PekiY4ixcTxnUYkPrmlw6bsh021SJjFwFvo0",
	"m+v8fUutZuuFA4Q8hDCXK3bBpwQdnSCbT1YeosGPWMJbpo+SCP2vi8Gv/4ZAwuZLE99UDJJG/ogFybZz",
	"9B/X0tF/jqLI/HFCbqhPBiZXbOmz0dmc6exRBXVY30QGZGKdJ1eTC62JbDlLzTABC/8M20wAvZM7EhKO",
	"Fl6NZC5Bwln2ypsETvwTkTzPQW+4QMm4u8bdGbQYzsIZIjdEoCFBNzik5g09yIweOmUonaGt5vM4DHRp",
	"QtWECISz3jCgJ8FVvB9SwhT61udhSHzFxXcG3cWbRD3VXUVNyS2UlyzU5m/0ltzJSTPp+7h9i4i/xyPC",
	"9LrMFrnmnkPgBHB8+hARho7OTtFBbx+SYWBFhyHJ7rz+VbddtsVHEb0wP9XJZn7nuWGl6cztgA/1AHoH",
	"V8yAWB5eMYQ8FIvwEO1dsV6v95sSMTMwsLU/AdmVqA1VbouP6nJXL7td24SYzk7RqXn2sQuCUvyasOX3",
	"uBp5yJQt9+jWGLg0bS1RmqwrBcLuWIYUtxqZ7QENZz0E6eTt11QaTjfhjGu1TfO4o2BKmeV0FWrHJq8H",
	"4Yj3Z80L4oHtGR6KAye1H9yT8hBL1ceQkL/JY/JKBesJ3R5fk93cHU+m2O9PiZrw3dwfZ7Z8I/1B2Jpt",
	"P8pPqf6rfpGfMskGWr9mmR7UbB/m7/ieHBJUJtIoK1mTL+/3phzIQsu9WBLzmMQZ/SQdQwjJIZYkmHeG",
	"zQbZ1CKm6olJIow3ZmWFAffdg5CCodNJ2uVG0ZWNoOn9PMtoIw/mRiWL9hbLG72ZB0oGGvgo857AtQBd",
	"UHb3vhhqrnkjX4CmSsazGIumgTwWm77CbY3wO7mc14SF3C6tKS/KjOcpw0rfiVSErXC0Wc94XsVk1zkS",
	"wplq/SAXsKaVES70r218i6/uUQcQRXlwi6MT5PKlPcyX8AVc7OFgSpkn6Hii1optIWdSnysMbsAqMsES",
	"QevItI4UXwIjsIecm6G0YS3asBY7gXCWRB83lH3OpBKQ3dHT8nkMMNsatjPdobS72mA/TqufJLVb8Lfg",
	"3yX4F9Lwo+cGEKsHD0OyuahVjgFkQlctx3lmHC2yW2TvCtk5snsCSN529LmPsiJGQRHMbeC5Fso7h/Jc",
	"uK3HB+TA59OtqOM+PD0hfqwIOjn+8A5xtgTIJz6ftsp2i+Nd4hgo8ymo1lMyHRIhJzRaC8djweMoC2Mq",
	"EUamccRHSxD8LhlEi+AWwbtB8DRLc48YwJH0BJlyRbYujc/4LREXEwLxZXWPy0XzmTyHkq14bsG9S3AX",
	"SfUpyGoRRFuzgJ+fnNU2d58HUQvoFtC7BHRKno8bwpKkj743fD3NEPYVvSHI9rFcOl+Q5PF3C+MWxjuA",
	"sUwp7jGD+PfQ266vycU/f2nob3Lxe9i6nLSI3jmi5yn18SCbCEmNu/nCB5sA0jiKuFDEPMy0Ncvz9B1F",
	"9F+25R28hDk6Oy1+aV8y9zMzLLwQSNOALyhWdJzvdgxpNKq07RjcDwMUGcrY9fPR/KvWL52ff738kWBB",
	"hHGhPvztkwbKT++Oji/omGFIGQyvX8/NYpxgZb/Qv5PAfg0VP7ktL/Omhkeh1GBkiCVBGm3GFT8M08jI",
	"XQQ8V+umikNhk5sd3U6IgLA/sHpUoiGhbIwmXCoSaHjFIuwcdvaA0995Co8hOIYZinXQTpYVXcX7+89f",
	"Zt7YF9+Eu7SJ+chHOc/yzCvslHvZV/eZD1rB/hiFHAeuBbvNSWSDozigCiqwER3rL6QkCp1KHpp4r93O",
	"W60T6F8grgcIchNJ9OgE/ajXM/OVCxFi/raRQfSHE1hL/dfbsw9Q+fTIprDKZLNKV8V+8f7SvMu6UFyY",
	"DohQ6JJMIy0e9RcfPtqhuHWwi9/tnOD/TyWJCoGliTmQ1AziFmSCzxSBHocDTnDQCEKy2T8vB/lALddQ",
	"H0dQiHu4wq1wzEvMqSzOBLsHcuaBZ146KC3C+CAZr/wkEBWSWJwN9loZSFxBIzg5IzWlNCe1WBNkUElJ",
	"YnK2QkBiSQY4JFCvy/ZNLUlEBG5sbWwtIAAA//8Bk5ez2/oDAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
